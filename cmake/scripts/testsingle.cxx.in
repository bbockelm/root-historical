#! @CMAKE_BINARY_DIR@/bin/
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * C++ Script testcint.cxx
 ************************************************************************
 * Description:
 *  Automatic test suite of cint
 ************************************************************************
 * Copyright(c) 2002~2004  Masaharu Goto
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// Usage:
//  $ cint testall.cxx

#include <stdio.h>
#ifdef G__ROOT
#include "@CMAKE_BINARY_DIR@/include/configcint.h"
#else
#include "../inc/configcint.h"
#endif

#ifndef G__VISUAL // ??? fprintf crashes if stdfunc.dll is loaded ???
#include <stdlib.h>
#include <string.h>
#endif

#ifdef DEBUG2
#ifndef DEBUG
#define DEBUG
#endif
#endif

char* debug = 0;
bool bKeepOnGoing = false;
bool bIgnoreDiffErrors = false;
bool bHideKnownErrors = false;
#ifndef DEBUG
bool debugMode = false;
#else
bool debugMode = true;
#endif

#include <string>

const char *shellSeparator = "&&";

#ifdef G__ROOT
// ROOT disable the autoloading of the standard header from the compiled
// dictionary (see G__autoload_stdheader) however the cint test requires it
std::string mkcintoption = " -Z1 ";
std::string cintoption = " -Z1 -I@CMAKE_BINARY_DIR@/include -I@CMAKE_BINARY_DIR@/cint/cint/include ";
#else
std::string mkcintoption = "";
std::string cintoption = "";
#endif // G__ROOT
std::string compileroption = "";
std::string prefixcmd = "";

enum ELanguage {
   kLangUnknown,
   kLangC,
   kLangCXX
};

//______________________________________________________________________________
int clear(const char* fname)
{
   // -- Erase a file.
   FILE* fp = fopen(fname, "w");
   fclose(fp);
   return 0;
}

//______________________________________________________________________________
int exist(const char* fname)
{
   // -- Check if a file exists.
   FILE* fp = fopen(fname, "r");
   if (fp) {
      fclose(fp);
      return 1;
   }
   return 0;
}

//______________________________________________________________________________
int rm(const char* fname)
{
   // -- Delete a file.
   int stat;
   do {
      stat = remove(fname);
   }
   while (exist(fname));
   return stat;
}

//______________________________________________________________________________
char *cleanAndCreateDirectory(const char *tname) 
{
   // Create an empty directory with the same name, without extension
   // as the test.

   char com[4096];

   char *dir = new char[strlen(tname)+1];
   strcpy(dir,tname);
   char *cursor = strstr(dir,".");
   if (cursor) {
      *cursor = '\0';
   };
   
   char com[4096];

   sprintf(com,"rm -rf %s",dir);
   run(com);
   sprintf(com,"mkdir %s",dir);
   run(com);
   
   return dir;
}

//______________________________________________________________________________
void cleanDirectory(const char* dir)
{
   // Delete a test directory
   char com[4096];
   sprintf(com,"rm -rf %s",dir);
   run(com);
}

//______________________________________________________________________________
int cat(FILE* fout, const char* fname)
{
   // -- Display a file on a given output file.
   FILE* fp = fopen(fname, "r");
   char b1[4096];
   while (fgets(b1, 4096, fp)) {
      fprintf(fout, "%s", b1);
   }
   fclose(fp);
   return 0;
}

//______________________________________________________________________________
int run(const char* com, bool show_when_debug = true)
{
   // -- Run a system command.
   if (debugMode && show_when_debug) printf("%s\n", com);

   //printf("%s\n", com);
   fflush(stdout);
   int ret = system(com);
   if (ret) {
      printf("FAILED with code %d: %s\n", ret, com);
      if (!bKeepOnGoing) {
         exit(ret);
      }
   }
   return ret;
}

//______________________________________________________________________________
int readahead(FILE* fp, const char* b, const int ahead = 10)
{
   // -- FIXME: Describe this function!
   if (!fp) {
      return 0;
   }
   int result = 0;
   fpos_t p;
   fgetpos(fp, &p);
   char buf[4096];
   int a = 0;
   for (int i = 0; i < ahead; ++i) {
      char* c = fgets(buf, 4096, fp);
      ++a;
      if (!c) {
         break;
      }
      if (!strcmp(b, buf)) {
         result = a;
         break;
      }
   }
   fsetpos(fp, &p);
   return result;
}

//______________________________________________________________________________
void outdiff(FILE* fp, FILE* fpi, int a, const char* b, int& l, const char* m)
{
   // -- FIXME: Describe this function!
   for (int i = 0; i < a; i++) {
      fprintf(fp, "%3d%s %s", l, m, b);
      if (!fpi) {
         break;
      }
      char* c = fgets((char*) b, 400, fpi);
      ++l;
      if (!c) {
         break;
      }
   }
}

//______________________________________________________________________________
void checkdiff(FILE* fp, FILE* fp1, FILE* fp2, char* b1, const char* b2, int& l1, int& l2, const char* m1, const char* m2)
{
   // -- FIXME: Describe this function!
   int a1 = readahead(fp1, b2);
   int a2 = readahead(fp2, b1);
   if (a1 && a2) {
      if (a1 <= a2) {
         outdiff(fp, fp1, a1, b1, l1, m1);
      }
      else {
         outdiff(fp, fp2, a2, b2, l2, m2);
      }
   }
   else if (a1) {
      outdiff(fp, fp1, a1, b1, l1, m1);
   }
   else if (a2) {
      outdiff(fp, fp2, a2, b2, l2, m2);
   }
   else {
      fprintf(fp, "%3d%s %s", l1, m1, b1);
      fprintf(fp, "%3d%s %s", l2, m2, b2);
   }
}

//______________________________________________________________________________
int diff(const char* title, const char* f1, const char* f2, const char* out, const char* macro = "", const char* m1 = ">", const char* m2 = "<")
{
   // -- FIXME: Describe this function!
   FILE* fp = fopen(out, "a");
   FILE* fp1 = fopen(f1, "r");
   FILE* fp2 = fopen(f2, "r");
   char b1[4096];
   char b2[4096];
   char* c1 = 0;
   char* c2 = 0;
   int l1 = 0;
   int l2 = 0;
   fprintf(fp, "%s %s\n", title, macro);
   for (;;) {
      if (fp1) {
         c1 = fgets(b1, 4096, fp1);
         ++l1;
      }
      else {
         c1 = 0;
      }
      if (fp2) {
         c2 = fgets(b2, 4096, fp2);
         ++l2;
      }
      else {
         c2 = 0;
      }
      if (c1 && c2) {
         if (strcmp(b1, b2)) {
            // --
#ifndef G__VISUAL
            checkdiff(fp, fp1, fp2, b1, b2, l1, l2, m1, m2);
#else // G__VISUAL
            fprintf(fp, "%3d%s %s", l1, m1, b1);
            fprintf(fp, "%3d%s %s", l2, m2, b2);
#endif // G__VISUAL
            // --
         }
      }
      else if (c1) {
         fprintf(fp, "%3d%s %s", l1, m1, b1);
      }
      else if (c2) {
         fprintf(fp, "%3d%s %s", l2, m2, b2);
      }
      else {
         break;
      }
   }
   if (fp2) {
      fclose(fp2);
   }
   if (fp1) {
      fclose(fp1);
   }
   if (fp) {
      fclose(fp);
   }
   return 0;
}

//______________________________________________________________________________
int ediff(const char* title, const char* macro, const char* dfile, const char* compiled = "compiled")
{
   // -- Call the system diff to compare 2 files (dfile and compiled).
   FILE* fp = fopen(dfile, "a");
   fprintf(fp, "%s %s\n", title, macro);
   fclose(fp);
   char com[4096];
#if G__VISUAL
  const char* extraoption = "--strip-trailing-cr ";
#else // G__VISUAL
  const char* extraoption = "";
#endif // G__VISUAL
   sprintf(com, "diff %s --old-group-format=\"%s %s:%%c'\\012'%%<\" --new-group-format=\"%s interpreted:%%c'\\012'%%>\" --unchanged-line-format=\"\" --old-line-format=\" %%3dn: %%L\" --new-line-format=\" %%3dn: %%L\" %s interpreted>> %s", extraoption, title, compiled, title, compiled, dfile);
   int ret;
   if (bIgnoreDiffErrors) {
      // for now we want to continue despite diffs in the text
      ret = system(com);
   } else {
      ret = run(com,false);
   }
   return ret;
}

//______________________________________________________________________________
bool check_skip(const char* sname)
{
   // -- FIXME: Describe this function!
   if (debug) {
      if (debug[0] == '+') {
         if (debug[1] == '+') {
            if (!strcmp(debug + 2, sname)) {
               debug = 0;
            }
            return true;
         }
         else {
            if (strcmp(debug + 1, sname)) {
               return true;
            }
            else {
               debug = 0;
            }
         }
      }
      else
         if (strcmp(debug, sname)) {
            return true;
         }
#ifdef CONTINUE_TEST
         else {
            debug = 0;
         }
#endif // CONTINUE_TEST
   }
   return false;
}

//______________________________________________________________________________
int buildDictionaryLibrary(ELanguage lang, const char *dir, const char* sname, const char* macro, const char* src, const char *suffix = "")
{
   // Generate the shared library with a dictionary for the test.
   // Run makecint then run the generate makefile.

   char com[4096];

   const char *hopt = lang == kLangCXX ? "H" : "h";

   sprintf(com, "cd %s %s makecint -mk Makefile%s %s -dl test%s.dll %s -%s ../%s %s", 
           dir, shellSeparator, suffix, mkcintoption.c_str(), suffix, macro, hopt, sname, src);
   run(com);
   sprintf(com, "cd %s %s make -f Makefile%s",dir,shellSeparator,suffix);
   run(com);

}


//______________________________________________________________________________
int ci(ELanguage lang, const char* sname, const char* dfile, const char* cflags = "", const char* exsname = "", const char* cintopt = "", const char *dir = ".")
{
   // -- Compare compiled and interpreted result.
   if (check_skip(sname)) {
      return 0;
   }
   printf("%s %s %s\n", sname, cflags, exsname);
   char exename[4096];
   strcpy(exename, sname);
   char* posExt = strrchr(exename, '.');
   if (posExt) {
      strcpy(posExt, ".exe");
   }
   // compile source
   const char* comp = 0;
   const char* flags = 0;
   const char* macros = 0;
   const char* ldflags = 0;
   const char* link = "";
   if (lang == kLangC) {
      comp = G__CFG_CC;
      flags = G__CFG_CFLAGS;
      ldflags = G__CFG_LDFLAGS;
      macros = G__CFG_CMACROS;
   }
   else if (lang == kLangCXX) {
      comp = G__CFG_CXX;
      flags = G__CFG_CXXFLAGS;
      ldflags = G__CFG_LDFLAGS;
      macros = G__CFG_CXXMACROS;
   }
   else {
      printf("ERROR in ci: language is not set!\n");
      return 0;
   }
#if defined(G__WIN32)
   link = "/link";
#endif
   char com[4096];
   sprintf(com, "%s -Dcompiled %s %s %s %s %s %s %s%s %s %s", comp, cflags, 
      compileroption.c_str(),
      flags, macros, sname, exsname, G__CFG_COUTEXE, exename, link, ldflags);
   //fprintf(stderr, "ci: run: %s\n", com);
   run(com);
   // run compiled program
#ifdef G__WIN32
   sprintf(com, ".\\%s > compiled", exename);
#else // G__WIN32
   sprintf(com, "./%s > compiled", exename);
#endif // G__WIN32
   //fprintf(stderr, "ci: run: %s\n", com);
   run(com);
#ifdef DEBUG2
   //fprintf(stderr, "ci: run: %s\n", exename);
   run(exename);
#endif // DEBUG2
#ifndef DEBUG
   //fprintf(stderr, "ci: rm %s\n", exename);
   rm(exename);
#endif // DEBUG
#if defined(G__WIN32) || defined(G__CYGWIN)
   if (posExt) {
      strcpy(posExt, ".obj");
   }
   rm(exename);
   if (posExt) {
      strcpy(posExt, ".exe.manifest");
   }
   rm(exename);
   if (posExt) {
      strcpy(posExt, ".pdb");
   }
   rm(exename);
#endif // G__WIN32 || G__CYGWIN
#ifdef G__BORLAND
   if (posExt) {
      strcpy(posExt, ".tds");
   }
   rm(exename);
#endif
   // run interpreted program
   sprintf(com, "%s @CintName@ -I%s %s %s -Dinterp %s %s %s %s > interpreted", prefixcmd.c_str(), dir, cintoption.c_str(), debug ? "-DDEBUG" : "", cintopt, cflags, exsname, sname);
   //fprintf(stderr, "ci: run: %s\n", com);
   run(com);
   int ret = ediff(sname, cflags, dfile);
#ifndef DEBUG
   //fprintf(stderr, "ci: rm %s\n", "compiled");
   rm("compiled");
   //fprintf(stderr, "ci: rm %s\n", "interpreted");
   rm("interpreted");
#endif // DEBUG
   return ret;
}

//______________________________________________________________________________
int io(const char* sname, const char* old, const char*dfile, const char* macro = "")
{
   // -- Check output of interpreted program.
   if (check_skip(sname)) {
      return 0;
   }
   printf("%s\n", sname);
   // run interpreted program
   char com[4096];
   sprintf(com, "%s @CintName@ %s %s %s > interpreted", prefixcmd.c_str(), cintoption.c_str(), macro, sname);
   run(com);
   int ret = ediff(sname, "", dfile, old);
   //diff(sname, old, "interpreted", dfile, "", "o", "i");
   rm("interpreted");
   return ret;
}

//______________________________________________________________________________
int mkc(ELanguage lang, const char* sname, const char* dfile, const char* macro = "", const char* src = "")
{
   // -- Check difference in output between compiled and interpreted code, with dictionary.
   if (check_skip(sname)) {
      return 0;
   }
   printf("%s\n", sname);

   char *dir = cleanAndCreateDirectory(sname);
   buildDictionaryLibrary(kLangCXX, dir, sname, macro, src);

   char com[4096];
   // run interpreted program
   sprintf(com, "-DHNAME=\\\"%s\\\" -DDNAME=\\\"%s/test.dll\\\"", sname,dir);
   int ret = ci(lang, "mkcmain.cxx", dfile, com, "", "", dir);
#ifndef DEBUG
   cleanDirectory(dir);
#endif // DEBUG
   delete [] dir;
   return ret;
}

//______________________________________________________________________________
int mkco(ELanguage lang, const char* sname, const char* hname, const char* old, const char* dfile, const char* macro = "", const char* src = "", const char* cintopt = "")
{
   // -- Check output of interpreted code, with dictionary.
   if (check_skip(sname)) {
      return 0;
   }
   printf("%s\n", sname);
   char *dir = cleanAndCreateDirectory(sname);
   buildDictionaryLibrary(lang, dir, hname, macro, src);

   // run interpreted program
   char imacro[4096];
   sprintf(imacro, "%s -Dmakecint", macro);
   int ret = io(sname, old, dfile, imacro);

#ifndef DEBUG
   cleanDirectory(dir);
#endif // DEBUG
   delete [] dir;
   return ret;
}

//______________________________________________________________________________
int mkci(ELanguage lang, const char* sname, const char* hname, const char* dfile, const char* macro = "", const char* src = "", const char* cintopt = "")
{
   // -- Check difference in output of compiled and interpreted code, with dictionary.
   if (check_skip(sname)) {
      return 0;
   }
   printf("%s\n", sname);
   char *dir = cleanAndCreateDirectory(sname);
   buildDictionaryLibrary(lang, dir, hname, macro, src);

   // run interpreted program
   char imacro[4096];
   sprintf(imacro, "%s -Dmakecint", macro);
   int ret = ci(lang, sname, dfile, imacro, "", cintopt, dir);

#ifndef DEBUG
   cleanDirectory(dir);
 #endif // DEBUG
   delete [] dir;
   return ret;
}

//______________________________________________________________________________
int mkciN(ELanguage lang, const char* sname, const char* hname1, const char* dfile, const char* macro = "", const char* hname2 = "", const char* hname3 = "")
{
   // -- Check difference in output between compiled and interpreted code, with up to three dictionaries.
   if (check_skip(sname)) {
      return 0;
   }
   printf("%s\n", sname);
   
   char *dir = cleanAndCreateDirectory( sname );
   buildDictionaryLibrary(lang, dir, hname1, macro, "", "1");
   if (hname2[0]) buildDictionaryLibrary(lang, dir, hname2, macro, "", "2");
   if (hname3[0]) buildDictionaryLibrary(lang, dir, hname3, macro, "", "3");

   // run interpreted program
   char imacro[4096];
   sprintf(imacro, "%s -Dmakecint2", macro);
   int ret = ci(lang, sname, dfile, imacro, "", "", dir);
#ifndef DEBUG
   cleanDirectory( dir );
#endif // DEBUG
   delete [] dir;
   return ret;
}

//______________________________________________________________________________
int testn(ELanguage lang, const char* hdr, int* num, const char* ext, const char* dfile, const char* macro = "")
{
   // -- Test series of files with enumerated suffix.
   char sname[4096];
   int ret = 0;
   int i = 0;
   while (num[i] != -1) {
      sprintf(sname, "%s%d%s", hdr, num[i], ext);
      ret += ci(lang, sname, dfile, macro);
      ++i;
   }
   return ret;
}

//______________________________________________________________________________
int main(int argc, char** argv)
{
   // Put this default first so it can be 
   // over-ridden
   cintoption += " -O0 ";

   const char* difffile = "testdiff.txt";
   const char* filename;

   for (int i=0;i<argc;i++){
     cout<<"Argv["<<i<<"]: "<<argv[i]<<endl;
   }

   if ( argc != 3 ) {
     fprintf(stderr,"Wrong number of arguments. Please use\n");
     fprintf(stderr,"%s -f <filename> \n",argv[0]);
     return 1;     
   }


   if (!strcmp("-f", argv[1])) {
     filename = argv[2];
     /*
     filename = argv[3];
     cout<<"Long: "<<filename_long<<endl;
     cout<<"Short: "<<filename<<endl;
     // Find last occurence of / and copy the filename
     // to a new variable
     char * pch;
     pch=strrchr(filename_tmp,'/');
     int pos=pch-filename_tmp+1;
     int sub_len = strlen(filename_tmp)-(pch-filename_tmp+1);
     strcat(filename1, filename_tmp+pos);
     fprintf(stderr,"Filename is %s. \n",filename1);
     filename1[sub_len+1]='\0';
     filename = &filename1;
     */
   } else {
     fprintf(stderr,"Wrong comand line. Please use\n");
     fprintf(stderr,"%s -f <filename> \n",argv[0]);
     return 1;     
   }

    clear(difffile);

int ret = 0;

 if (!strcmp("simple01.cxx", filename)) {
  fprintf(stderr,"Bin hier.\n");
  ret += io("simple01.cxx","simple01.ref",difffile,"-DTARGET=\\\"simple01.cxx\\\"");
 }
 else if (!strcmp("simple10.cxx", filename)) {
  ret += ci(kLangCXX, "simple10.cxx", difffile);
 }
 else if (!strcmp("simple11.cxx", filename)) {
  ret += ci(kLangCXX, "simple11.cxx", difffile);
  ret += mkci(kLangCXX, "simple11.cxx", "simple11.cxx", difffile);
 }
 else if (!strcmp("simple12.cxx", filename)) {
  ret += io("simple12.cxx", "simple12.ref", difffile);
 }
 else if (!strcmp("simple13.cxx", filename)) {
  ret += io("simple13.cxx", "simple13.ref", difffile);
 }
 else if (!strcmp("simple14.cxx", filename)) {
  ret += ci(kLangCXX, "simple14.cxx", difffile);
 }
 else if (!strcmp("simple15.cxx", filename)) {
  ret += ci(kLangCXX, "simple15.cxx", difffile);
 }
 else if (!strcmp("simple16.cxx", filename)) {
  ret += ci(kLangCXX, "simple16.cxx", difffile);
 }
 else if (!strcmp("simple17.cxx", filename)) {
  ret += ci(kLangCXX, "simple17.cxx", difffile);
 }
 else if (!strcmp("simple18.cxx", filename)) {
  ret += ci(kLangCXX, "simple18.cxx", difffile);
 }
 else if (!strcmp("simple19.cxx", filename)) {
  ret += ci(kLangCXX, "simple19.cxx", difffile);
 }
 else if (!strcmp("simple20.cxx", filename)) {
  ret += io("simple20.cxx", "simple20.ref", difffile);
 }
 else if (!strcmp("simple21.cxx", filename)) {
  ret += io("simple21.cxx", "simple21.ref", difffile);
 }
 else if (!strcmp("simple22.cxx", filename)) {
  ret += io("simple22.cxx", "simple22.ref", difffile);
 }
 else if (!strcmp("simple23.cxx", filename)) {
  ret += io("simple23.cxx", "simple23.ref", difffile);
 }
 else if (!strcmp("simple24.cxx", filename)) {
  ret += io("simple24.cxx", "simple24.ref", difffile);
 }
 else if (!strcmp("simple25.cxx", filename)) {
  ret += mkci(kLangCXX,"simple25.cxx","simple25.h",difffile);
 }
  else if (!strcmp("cpp0.cxx", filename)) {
  ret += ci(kLangCXX, "cpp0.cxx", difffile);
 }
 else if (!strcmp("cpp1.cxx", filename)) {
  ret += ci(kLangCXX, "cpp1.cxx", difffile);
 }
 else if (!strcmp("cpp2.cxx", filename)) {
  ret += ci(kLangCXX, "cpp2.cxx", difffile);
 }
 else if (!strcmp("cpp3.cxx", filename)) {
  ret += ci(kLangCXX, "cpp3.cxx", difffile);
 }
 else if (!strcmp("cpp4.cxx", filename)) {
  ret += ci(kLangCXX, "cpp4.cxx", difffile);
 }
 else if (!strcmp("cpp5.cxx", filename)) {
  ret += ci(kLangCXX, "cpp5.cxx", difffile);
 }
 else if (!strcmp("cpp6.cxx", filename)) {
  ret += ci(kLangCXX, "cpp6.cxx", difffile);
 }
 else if (!strcmp("cpp8.cxx", filename)) {
  ret += ci(kLangCXX, "cpp8.cxx", difffile);
 }
 else if (!strcmp("bool01.cxx", filename)) {
  ret += ci(kLangCXX, "bool01.cxx", difffile);
 }
 else if (!strcmp("switch.cxx", filename)) {
  ret += ci(kLangCXX, "switch.cxx", difffile);
 }
 else if (!strcmp("refassign.cxx", filename)) {
  ret += ci(kLangCXX, "refassign.cxx", difffile);
 }
 else if (!strcmp("ostream.cxx", filename)) {
  // cout << pointer
  ret += ci(kLangCXX, "ostream.cxx", difffile);  
 }
 else if (!strcmp("setw0.cxx", filename)) {
  ret += ci(kLangCXX, "setw0.cxx", difffile);
 }
 else if (!strcmp("inherit0.cxx", filename)) {
  ret += ci(kLangCXX, "inherit0.cxx", difffile);
 }
 else if (!strcmp("inherit1.cxx", filename)) {
  ret += ci(kLangCXX, "inherit1.cxx", difffile);
 }
 else if (!strcmp("inherit2.cxx", filename)) {
  ret += ci(kLangCXX, "inherit2.cxx", difffile);
 }
 else if (!strcmp("virtualfunc0.cxx", filename)) {
  ret += ci(kLangCXX, "virtualfunc0.cxx", difffile);
 }
 else if (!strcmp("virtualfunc1.cxx", filename)) {
  ret += ci(kLangCXX, "virtualfunc1.cxx", difffile);
 }
 else if (!strcmp("virtualfunc2.cxx", filename)) {
  ret += ci(kLangCXX, "virtualfunc2.cxx", difffile);
 }
 else if (!strcmp("oprovld0.cxx", filename)) {
  ret += ci(kLangCXX, "oprovld0.cxx", difffile);
 }
 else if (!strcmp("oprovld2.cxx", filename)) {
  ret += ci(kLangCXX, "oprovld2.cxx", difffile);
 }
 else if (!strcmp("constary.cxx", filename)) {
  ret += ci(kLangCXX, "constary.cxx", difffile);
 }
 else if (!strcmp("const.cxx", filename)) {
  ret += ci(kLangCXX, "const.cxx", difffile);
 }
 else if (!strcmp("scope0.cxx", filename)) {
  ret += ci(kLangCXX, "scope0.cxx", difffile);
 }
 else if (!strcmp("idxscope0.cxx", filename)) {
  ret += ci(kLangCXX, "idxscope0.cxx", difffile);
 }
 else if (!strcmp("access0.cxx", filename)) {
  ret += ci(kLangCXX, "access0.cxx", difffile);
 }
 else if (!strcmp("staticmem0.cxx", filename)) {
  ret += ci(kLangCXX, "staticmem0.cxx", difffile);
 }
 else if (!strcmp("staticmem1.cxx", filename)) {
  ret += ci(kLangCXX, "staticmem1.cxx", difffile);
 }
 else if (!strcmp("staticary.cxx", filename)) {
  ret += ci(kLangCXX, "staticary.cxx", difffile);
 }
 else if (!strcmp("static_object.cxx", filename)) {
  ret += ci(kLangCXX, "static_object.cxx", difffile);
 }
 else if (!strcmp("static_string.cxx", filename)) {
  ret += ci(kLangCXX, "static_string.cxx", difffile);
 }
 else if (!strcmp("static_call.cxx", filename)) {
  ret += ci(kLangCXX, "static_call.cxx", difffile);
 }
 else if (!strcmp("minexam.cxx", filename)) {
  ret += ci(kLangCXX, "minexam.cxx", difffile);
 }
 else if (!strcmp("btmplt.cxx", filename)) {
  ret += ci(kLangCXX, "btmplt.cxx", difffile);
 }
 else if (!strcmp("loopcompile1.cxx", filename)) {
  ret += ci(kLangCXX, "loopcompile1.cxx", difffile);
 }
 else if (!strcmp("loopcompile2.cxx", filename)) {
  ret += ci(kLangCXX, "loopcompile2.cxx", difffile);
 }
 else if (!strcmp("loopcompile3.cxx", filename)) {
  ret += ci(kLangCXX, "loopcompile3.cxx", difffile);
 }
 else if (!strcmp("loopcompile4.cxx", filename)) {
  ret += ci(kLangCXX, "loopcompile4.cxx", difffile);
 }
 else if (!strcmp("loopcompile5.cxx", filename)) {
  ret += ci(kLangCXX, "loopcompile5.cxx", difffile);
 }
 else if (!strcmp("mfstatic.cxx", filename)) {
  ret += ci(kLangCXX, "mfstatic.cxx", difffile);
 }
 else if (!strcmp("new0.cxx", filename)) {
  ret += ci(kLangCXX, "new0.cxx", difffile);
 }
 else if (!strcmp("template0.cxx", filename)) {
  ret += ci(kLangCXX, "template0.cxx", difffile);
 }
 else if (!strcmp("template1.cxx", filename)) {
  ret += ci(kLangCXX, "template1.cxx", difffile);
 }
 else if (!strcmp("template2.cxx", filename)) {
  ret += ci(kLangCXX, "template2.cxx", difffile);
 }
 else if (!strcmp("template3.cxx", filename)) {
  ret += io("template3.cxx", "template3.ref", difffile);
 }
 else if (!strcmp("template4.cxx", filename)) {
  ret += ci(kLangCXX, "template4.cxx", difffile);
 }
 else if (!strcmp("template5.cxx", filename)) {
  #if defined(G__MSC_VER)&&(G__MSC_VER<=1200)
    ret += 0;
  #else
    ret += ci(kLangCXX, "template5.cxx", difffile);
  #endif // G__MSC__VER && (G__MSC_VER <= 1200)
 }
 else if (!strcmp("template6.cxx", filename)) {
  ret += ci(kLangCXX, "template6.cxx", difffile);
 }
 else if (!strcmp("minherit0.cxx", filename)) {
  ret += ci(kLangCXX, "minherit0.cxx", difffile);
 }
 else if (!strcmp("enumscope.cxx", filename)) {
  ret += ci(kLangCXX, "enumscope.cxx", difffile);
 }
 else if (!strcmp("baseconv0.cxx", filename)) {
  ret += ci(kLangCXX, "baseconv0.cxx", difffile);
 }
 else if (!strcmp("friend0.cxx", filename)) {
  ret += ci(kLangCXX, "friend0.cxx", difffile);
 }
 else if (!strcmp("anonunion.cxx", filename)) {
   ret += ci(kLangCXX, "anonunion.cxx", difffile);
 }
 else if (!strcmp("init1.cxx", filename)) {
  ret += ci(kLangCXX, "init1.cxx", difffile);
 }
 else if (!strcmp("init2.cxx", filename)) {
  ret += ci(kLangCXX, "init2.cxx", difffile);
 } 
 else if (!strcmp("include.cxx", filename)) {
  ret += ci(kLangCXX, "include.cxx", difffile);
 }
 else if (!strcmp("eh1.cxx", filename)) {
  ret += ci(kLangCXX, "eh1.cxx", difffile);
 }
 else if (!strcmp("ifs.cxx", filename)) {
  ret += ci(kLangCXX, "ifs.cxx", difffile);
 }
 else if (!strcmp("bitfield.cxx", filename)) {
  ret += ci(kLangCXX, "bitfield.cxx", difffile);
 }
 else if (!strcmp("cout1.cxx", filename)) {
  ret += ci(kLangCXX, "cout1.cxx", difffile);
 }
 else if (!strcmp("longlong.cxx", filename)) {
  ret += ci(kLangCXX, "longlong.cxx", difffile);
 }
 else if (!strcmp("explicitdtor.cxx", filename)) {
  //fails due to base class dtor
  ret += ci(kLangCXX, "explicitdtor.cxx", difffile);
 }
 else if (!strcmp("nick3.cxx", filename)) {
  ret += ci(kLangCXX, "nick3.cxx", difffile);
 }
 else if (!strcmp("nick4.cxx", filename)) {
  ret += ci(kLangCXX, "nick4.cxx", difffile);
  ret += ci(kLangCXX, "nick4.cxx", difffile, "-DDEST");
 }
 else if (!strcmp("telea0.cxx", filename)) {
  ret += ci(kLangCXX, "telea0.cxx", difffile);
 }
 else if (!strcmp("telea1.cxx", filename)) {
  ret += ci(kLangCXX, "telea1.cxx", difffile);
 }
 else if (!strcmp("telea2.cxx", filename)) {
  ret += ci(kLangCXX, "telea2.cxx", difffile);
 }
 else if (!strcmp("telea3.cxx", filename)) {
  ret += ci(kLangCXX, "telea3.cxx", difffile);
 }
 else if (!strcmp("telea5.cxx", filename)) {
  ret += ci(kLangCXX, "telea5.cxx", difffile);
 }
 else if (!strcmp("telea6.cxx", filename)) {
  ret += ci(kLangCXX, "telea6.cxx", difffile);
 }
 else if (!strcmp("telea7.cxx", filename)) {
  ret += ci(kLangCXX, "telea7.cxx", difffile);
 }
 else if (!strcmp("fwdtmplt.cxx", filename)) {
  ret += ci(kLangCXX, "fwdtmplt.cxx", difffile);
 }
 else if (!strcmp("VPersonTest.cxx", filename)) {
  ret += ci(kLangCXX, "VPersonTest.cxx", difffile);
 }
 else if (!strcmp("convopr0.cxx", filename)) {
  ret += ci(kLangCXX, "convopr0.cxx", difffile);
 }
 else if (!strcmp("nstmplt1.cxx", filename)) {
  ret += ci(kLangCXX, "nstmplt1.cxx", difffile);
 }
 else if (!strcmp("aoki0.cxx", filename)) {
  ret += ci(kLangCXX, "aoki0.cxx", difffile);
 }
 else if (!strcmp("borg1.cxx", filename)) {
  ret += ci(kLangCXX, "borg1.cxx", difffile);
 }
 else if (!strcmp("borg2.cxx", filename)) {
  ret += ci(kLangCXX, "borg2.cxx", difffile);
 }
 else if (!strcmp("bruce1.cxx", filename)) {
  // This test currently fails because the char** argument is
  // registered as a char *&
  ret += ci(kLangCXX, "bruce1.cxx", difffile);
 }
 else if (!strcmp("fons3.cxx", filename)) {
  ret += ci(kLangCXX, "fons3.cxx", difffile);
 }
 else if (!strcmp("Test0.cxx", filename)) {
  ret += ci(kLangCXX, "Test0.cxx", difffile, "", "MyString.cxx");
 }
 else if (!strcmp("Test1.cxx", filename)) {
  ret += ci(kLangCXX, "Test1.cxx", difffile, "", "Complex.cxx MyString.cxx");
 }
 else if (!strcmp("delete0.cxx", filename)) {
  ret += ci(kLangCXX, "delete0.cxx", difffile);
 }
 else if (!strcmp("pb19.cxx", filename)) {
  ret += ci(kLangCXX, "pb19.cxx", difffile);
 }
 else if (!strcmp("autocc.cxx", filename)) {
   #ifdef AUTOCC
    ret += ci(kLangCXX, "autocc.cxx", difffile);
    system("rm G__*");
   #else
    ret += 0;
   #endif // AUTOCC
 }
 else if (!strcmp("maincmplx.cxx", filename)) {
  ret += ci(kLangCXX, "maincmplx.cxx", difffile, "", "complex1.cxx");
 }
 else if (!strcmp("funcmacro.cxx", filename)) {
  ret += ci(kLangCXX, "funcmacro.cxx", difffile);
 }
 else if (!strcmp("template.cxx", filename)) {
   ret += ci(kLangCXX, "template.cxx", difffile);
   ret += mkci(kLangCXX, "template.cxx", "template.h", difffile);
 }
 else if (!strcmp("vase.cxx", filename)) {
  ret += ci(kLangCXX, "vbase.cxx", difffile);
  ret += mkci(kLangCXX, "vbase.cxx", "vbase.h", difffile);
 }
 else if (!strcmp("vbase1.cxx", filename)) {
  ret += ci(kLangCXX, "vbase1.cxx", difffile);
  ret += mkci(kLangCXX, "vbase1.cxx", "vbase1.h", difffile);
 }
 else if (!strcmp("t674.cxx", filename)) {
  #define PROBLEM
  #if defined(PROBLEM) && (!defined(G__WIN32) || defined(FORCEWIN32))
   // Problem with VC++6.0
   ret += mkci(kLangCXX, "t674.cxx", "t674.h", difffile); 
  #else
   ret += 0;
  #endif // PROBLEM && (!G__WIN32 || FORCEWIN32)
 }
 else if (!strcmp("t648.cxx", filename)) {
  #define PROBLEM
  #if defined(PROBLEM) && (!defined(G__WIN32) || defined(FORCEWIN32))
    // long long has problem with BC++5.5
    // also with VC++6.0 bug different
    ret += ci(kLangCXX, "t648.cxx", difffile); 
  #else
    ret += 0;
  #endif // PROBLEM && (!G__WIN32 || FORCEWIN32)
 }
 else if (!strcmp("t977.cxx", filename)) {
   #define PROBLEM
   #if defined(PROBLEM) && (!defined(G__WIN32) || defined(FORCEWIN32))
    // VC++ problem is known
    ret += mkci(kLangCXX,"t977.cxx","t977.h",difffile);
   #else
    ret += 0;
   #endif // PROBLEM && (!G__WIN32 || FORCEWIN32)
 }
 else if (!strcmp("t980.cxx", filename)) {
  #define PROBLEM
  #if defined(PROBLEM) && (!defined(G__WIN32) || defined(FORCEWIN32))
   // problem with BC++5.5
   ret += ci(kLangCXX, "t980.cxx", difffile);
  #else
   ret += 0;
  #endif // PROBLEM && (!G__WIN32 || FORCEWIN32)
 }
 else if (!strcmp("t1030.cxx", filename)) {
  #define PROBLEM
  #if defined(PROBLEM) && (!defined(G__WIN32) || defined(FORCEWIN32))
   #if (G__GNUC==2)
    // works only with gcc2.96
    ret += mkci(kLangCXX, "t1030.cxx", "t1030.h", difffile); 
    ret += mkci(kLangCXX,"t1030.cxx","t1030.h",difffile,"","","-Y0");
   #else
    ret += 0;
   #endif // G__GNUC == 2
  #else
    ret += 0;
  #endif // PROBLEM && (!G__WIN32 || FORCEWIN32)
 }
 else if (!strcmp("t1031.cxx", filename)) {
  #define PROBLEM
  #if defined(PROBLEM) && (!defined(G__WIN32) || defined(FORCEWIN32))
   #if (G__GNUC==2)
    // works only with gcc2.96
    ret += mkci(kLangCXX, "t1031.cxx", "t1031.h", difffile);
    ret += mkci(kLangCXX,"t1031.cxx","t1031.h",difffile,"","","-Y0");
   #else
    ret += 0;
   #endif // G__GNUC == 2
  #else
    ret += 0;
  #endif // PROBLEM && (!G__WIN32 || FORCEWIN32)
 }
 else if (!strcmp("t215.cxx", filename)) {
  ret += ci(kLangCXX, "t215.cxx", difffile);
 }
 else if (!strcmp("t358.cxx", filename)) {
  ret += ci(kLangCXX, "t358.cxx", difffile);
 }
 else if (!strcmp("t488.cxx", filename)) {
  ret += ci(kLangCXX, "t488.cxx", difffile);
 }
 else if (!strcmp("t516.cxx", filename)) {
  ret += ci(kLangCXX, "t516.cxx", difffile);
 }
 else if (!strcmp("t603.cxx", filename)) {
  ret += ci(kLangCXX, "t603.cxx", difffile);
 }
 else if (!strcmp("t627.cxx", filename)) {
  ret += ci(kLangCXX, "t627.cxx", difffile);
  ret += mkci(kLangCXX, "t627.cxx", "t627.h", difffile);
 }
 else if (!strcmp("t630.cxx", filename)) {
  ret += ci(kLangCXX, "t630.cxx", difffile);
 }
 else if (!strcmp("t633.cxx", filename)) {
  ret += ci(kLangCXX, "t633.cxx", difffile);
  ret += mkci(kLangCXX, "t633.cxx", "t633.h", difffile);
 }
 else if (!strcmp("t634.cxx", filename)) {
  ret += ci(kLangCXX, "t634.cxx", difffile);
 }
 else if (!strcmp("t674.cxx", filename)) {
  ret += ci(kLangCXX, "t674.cxx", difffile, "-DINTERPRET");
 }
 else if (!strcmp("t676.cxx", filename)) {
  #if !defined(G__WIN32) && !defined(G__CYGWIN) && !defined(G__APPLE)
   //recursive call stack too deep for Visual C++
   ret += ci(kLangCXX, "t676.cxx", difffile); 
  #endif // !G__WIN32 && !G__CYGWIN && !G__APPLE
 }
 else if (!strcmp("t694.cxx", filename)) {
  ret += mkci(kLangCXX, "t694.cxx", "t694.h", difffile);
  //fails due to default param
  ret += ci(kLangCXX, "t694.cxx", difffile, "-DINTERPRET"); 
 }
 else if (!strcmp("t695.cxx", filename)) {
  //fails due to tmplt specialization
  ret += ci(kLangCXX, "t695.cxx", difffile); 
 }
 else if (!strcmp("t705.cxx", filename)) {
  ret += mkci(kLangCXX, "t705.cxx", "t705.h", difffile);
  ret += ci(kLangCXX, "t705.cxx", difffile, "-DINTERPRET");
 }
 else if (!strcmp("t714.cxx", filename)) {
  ret += ci(kLangCXX, "t714.cxx", difffile);
 }
 else if (!strcmp("t733.cxx", filename)) {
  ret += io("t733.cxx", "t733.ref", difffile);
 }
 else if (!strcmp("t749.cxx", filename)) {
  #if !defined(G__WIN32) || defined(FORCEWIN32)
   //NOT WORKING: in debug mode on WINDOWS!
   ret += ci(kLangCXX,"t749.cxx",difffile);
  #endif // !G__WIN32 || FORCEWIN32
 }
 else if (!strcmp("t751.cxx", filename)) {
  ret += ci(kLangCXX, "t751.cxx", difffile);
 }
 else if (!strcmp("t764.cxx", filename)) {
  ret += ci(kLangCXX, "t764.cxx", difffile);
 }
 else if (!strcmp("t767.cxx", filename)) {
  ret += ci(kLangCXX, "t767.cxx", difffile);
 }
 else if (!strcmp("t776.cxx", filename)) {
  ret += ci(kLangCXX, "t776.cxx", difffile);
 }
 else if (!strcmp("t777.cxx", filename)) {
  ret += ci(kLangCXX, "t777.cxx", difffile);
 }
 else if (!strcmp("t784.cxx", filename)) {
  ret += ci(kLangCXX, "t784.cxx", difffile);
 }
 else if (!strcmp("t825.cxx", filename)) {
  ret += ci(kLangCXX, "t825.cxx", difffile);
 }
 else if (!strcmp("t910.cxx", filename)) {
  ret += ci(kLangCXX, "t910.cxx", difffile);
 }
 else if (!strcmp("t916.cxx", filename)) {
  ret += ci(kLangCXX, "t916.cxx", difffile);
 }
 else if (!strcmp("t927.cxx", filename)) {
  #if !defined(G__VISUAL) || defined(FORCEWIN32)
   #if G__CINTVERSION < 70000000
     ret += io("t927.cxx","t927.ref5",difffile);
   #else
     ret += io("t927.cxx","t927.ref",difffile);
   #endif
  #endif // !G__VISUAL || FORCEWIN32
 }
 else if (!strcmp("t928.cxx", filename)) {
  #if !defined(G__WIN32) || defined(FORCEWIN32)
   ret += mkciN(kLangCXX, "t928.cxx", "t928.h", difffile, "", "t928a.h", "t928b.h");
  #endif // !G__WIN32 | FORCEWIN32
 }
 else if (!strcmp("t930.cxx", filename)) {
  ret += ci(kLangCXX, "t930.cxx", difffile);
 }
 else if (!strcmp("t938.cxx", filename)) {
  ret += ci(kLangCXX, "t938.cxx", difffile);
 }
 else if (!strcmp("t958.cxx", filename)) {
  ret += ci(kLangCXX, "t958.cxx", difffile);
 }
 else if (!strcmp("t959.cxx", filename)) {
  ret += ci(kLangCXX, "t959.cxx", difffile);
 }
 else if (!strcmp("t961.cxx", filename)) {
  ret += mkci(kLangCXX, "t961.cxx", "t961.h", difffile); 
  //mkc(kLangCXX,"t961.h",difffile);
 }
 else if (!strcmp("t963.cxx", filename)) {
  //Borland C++5.5 has a problem
  //with reverse_iterator::reference
  ret += ci(kLangCXX, "t963.cxx", difffile);
 }
 else if (!strcmp("t966.cxx", filename)) {
  #ifdef G__P2F
   ret += mkci(kLangCXX, "t966.cxx", "t966.h", difffile);
  #endif // G__P2F
 }
 else if (!strcmp("t968.cxx", filename)) {
  // problem with BC++5.5 & VC++6.0
  ret += mkci(kLangCXX, "t968.cxx", "t968.h", difffile);
 }
 else if (!strcmp("t970.cxx", filename)) {
  ret += mkci(kLangCXX, "t970.cxx", "t970.h", difffile);
 }
 else if (!strcmp("t972.cxx", filename)) {
  ret += mkciN(kLangCXX, "t972.cxx", "t972a.h", difffile, "", "t972b.h");
 }
 else if (!strcmp("t980.cxx", filename)) {
  #if !defined(G__WIN32) || defined(FORCEWIN32)
   ret += mkci(kLangCXX, "t980.cxx", "t980.h", difffile);
  #endif // !G__WIN32 | FORCEWIN32
 }
 else if (!strcmp("t986.cxx", filename)) {
  #if !defined(G__WIN32) || defined(FORCEWIN32)
   ret += ci(kLangCXX, "t986.cxx", difffile, "-DTEST");
  #endif // !G__WIN32 | FORCEWIN32
 }
 else if (!strcmp("t987.cxx", filename)) {
  ret += mkci(kLangCXX, "t987.cxx", "t987.h", difffile);
 }
 else if (!strcmp("t991.cxx", filename)) {
  ret += mkciN(kLangCXX, "t991.cxx", "t991a.h", difffile, "", "t991b.h", "t991c.h");
 }
 else if (!strcmp("t992.cxx", filename)) {
  ret += mkci(kLangCXX, "t992.cxx", "t992.h", difffile);  // problem gcc3.2
 }
 else if (!strcmp("maptest.cxx", filename)) {
  ret += mkci(kLangCXX, "maptest.cxx", "maptest.h", difffile); // problem icc
 }
 else if (!strcmp("t993.c", filename)) {
  ret += mkci(kLangC, "t993.c", "t993.h", difffile);
 }
 else if (!strcmp("t995.cxx", filename)) {
  ret += mkci(kLangCXX, "t995.cxx", "t995.h", difffile);
 }
 else if (!strcmp("t996.cxx", filename)) {
  ret += mkci(kLangCXX, "t996.cxx", "t996.h", difffile);
 }
 else if (!strcmp("t998.cxx", filename)) {
  ret += ci(kLangCXX, "t998.cxx", difffile);
 }
 else if (!strcmp("t1002.cxx", filename)) {
  ret += mkci(kLangCXX, "t1002.cxx", "t1002.h", difffile);
 }
 else if (!strcmp("t1004.cxx", filename)) {
  ret += ci(kLangCXX, "t1004.cxx", difffile);
 }
 else if (!strcmp("t1011.cxx", filename)) {
  ret += ci(kLangCXX, "t1011.cxx", difffile);
  ret += mkci(kLangCXX, "t1011.cxx", "t1011.h", difffile);
 }
 else if (!strcmp("t1015.cxx", filename)) {
  ret += ci(kLangCXX, "t1015.cxx", difffile);
 }
 else if (!strcmp("t1016.cxx", filename)) {
  ret += ci(kLangCXX, "t1016.cxx", difffile);
  ret += mkci(kLangCXX, "t1016.cxx", "t1016.h", difffile);
 }
 else if (!strcmp("t1023.cxx", filename)) {
  ret += ci(kLangCXX, "t1023.cxx", difffile);
 }
 else if (!strcmp("t1024.cxx", filename)) {
  ret += ci(kLangCXX, "t1024.cxx", difffile);
  ret += mkci(kLangCXX, "t1024.cxx", "t1024.h", difffile);
 }
 else if (!strcmp("t1025.cxx", filename)) {
  #if !defined(G__WIN32) || defined(FORCEWIN32)
   ret += mkci(kLangCXX, "t1025.cxx", "t1025.h", difffile);
  #endif // !G__WIN32 | FORCEWIN32
 }
 else if (!strcmp("t1026.cxx", filename)) {
  ret += ci(kLangCXX, "t1026.cxx", difffile); // problem with BC++5.5
  ret += mkci(kLangCXX, "t1026.cxx", "t1026.h", difffile);
 }
 else if (!strcmp("t1027.cxx", filename)) {
  ret += io("t1027.cxx", "t1027.ref", difffile);
  //ret += ci(kLangCXX,"t1027.cxx",difffile); // problem with BC++5.5
  //ret += mkci(kLangCXX,"t1027.cxx","t1027.h",difffile);
 }
 else if (!strcmp("t1032.cxx", filename)) {
  ret += ci(kLangCXX, "t1032.cxx", difffile);
  ret += ci(kLangCXX, "t1032.cxx", difffile);
 }
 else if (!strcmp("t1034a.cxx", filename)) {
  ret += ci(kLangCXX, "t1034a.cxx", difffile);
 }
 else if (!strcmp("t1034.cxx", filename)) {
  #if !defined(G__WIN32) || defined(FORCEWIN32)
   if (sizeof(long double)==16) {
     // sizeof(long double)==16
     ret += io("t1034.cxx", "t1034.ref64", difffile);       
   } else if (sizeof(long)==4) {
      // sizeof(long double)==12
      ret += io("t1034.cxx", "t1034.ref", difffile);
   } else if (sizeof(void*)==8) {
      // sizeof(long double)==16
      ret += io("t1034.cxx", "t1034.ref64", difffile); 
   } else {
      // sizeof(long double)==12
      ret += io("t1034.cxx", "t1034.refXX", difffile);
   }
  #endif // !G__WIN32 | FORCEWIN32
 }
 else if (!strcmp("t1035.cxx", filename)) {
  ret += ci(kLangCXX, "t1035.cxx", difffile);
  ret += mkci(kLangCXX, "t1035.cxx", "t1035.h", difffile);
 }
 else if (!strcmp("t1036.cxx", filename)) {
  ret += ci(kLangCXX, "t1036.cxx", difffile);
 }
 else if (!strcmp("t1040.cxx", filename)) {
  ret += mkci(kLangCXX, "t1040.cxx", "t1040.h", difffile); // gcc3.2 has problem
 }
 else if (!strcmp("t1042.cxx", filename)) {
  ret += io("t1042.cxx", "t1042.ref", difffile);
 }
 else if (!strcmp("t1046.cxx", filename)) {
  #if !defined(G__WIN32) || defined(FORCEWIN32)
   ret += ci(kLangCXX,"t1046.cxx",difffile);
   ret += mkci(kLangCXX,"t1046.cxx","t1046.h",difffile);
  #endif // !G__WIN32 | FORCEWIN32
 }
 else if (!strcmp("t1047.cxx", filename)) {
  ret += ci(kLangCXX, "t1047.cxx", difffile);
  ret += mkci(kLangCXX, "t1047.cxx", "t1047.h", difffile);
 }
 else if (!strcmp("t1048.cxx", filename)) {
  ret += ci(kLangCXX, "t1048.cxx", difffile);
  ret += mkci(kLangCXX, "t1048.cxx", "t1048.h", difffile, "-I.. -I../../inc -I../../src -I../../reflex/inc");
 }
 else if (!strcmp("t1049.cxx", filename)) {
  ret += ci(kLangCXX, "t1049.cxx", difffile);
 }
 else if (!strcmp("t1054.cxx", filename)) {
  ret += ci(kLangCXX, "t1054.cxx", difffile);
 }
 else if (!strcmp("t1055.cxx", filename)) {
  ret += ci(kLangCXX, "t1055.cxx", difffile);
 }
 else if (!strcmp("t1061.cxx", filename)) {
  ret += mkci(kLangCXX, "t1061.cxx", "t1061.h", difffile);
 }
 else if (!strcmp("t1062.cxx", filename)) {
  #if !defined(G__WIN32) || defined(FORCEWIN32)
   ret += mkci(kLangCXX, "t1062.cxx", "t1062.h", difffile);
  #endif // !G__WIN32 | FORCEWIN32
 }
 else if (!strcmp("t1067.cxx", filename)) {
  ret += ci(kLangCXX, "t1067.cxx", difffile);
  ret += mkci(kLangCXX, "t1067.cxx", "t1067.h", difffile);
 }
 else if (!strcmp("t1068.cxx", filename)) {
   ret += ci(kLangCXX, "t1068.cxx", difffile);
   ret += mkci(kLangCXX, "t1068.cxx", "t1068.h", difffile);
 }
 else if (!strcmp("t1079.cxx", filename)) {
   ret += ci(kLangCXX, "t1079.cxx", difffile);
   ret += mkci(kLangCXX, "t1079.cxx", "t1079.h", difffile);
 }
 else if (!strcmp("t1084.cxx", filename)) {
   ret += ci(kLangCXX, "t1084.cxx", difffile);
 }
 else if (!strcmp("t1085.cxx", filename)) {
   ret += ci(kLangCXX, "t1085.cxx", difffile);
 }
 else if (!strcmp("t1086.cxx", filename)) {
   ret += ci(kLangCXX, "t1086.cxx", difffile);
 }
 else if (!strcmp("t1088.cxx", filename)) {
   ret += ci(kLangCXX, "t1088.cxx", difffile);
 }
 else if (!strcmp("t1094.cxx", filename)) {
   ret += ci(kLangCXX, "t1094.cxx", difffile);
 }
 else if (!strcmp("t1101.cxx", filename)) {
   ret += ci(kLangCXX, "t1101.cxx", difffile);
 }
 else if (!strcmp("t1115.cxx", filename)) {
   ret += mkci(kLangCXX, "t1115.cxx", "t1115.h", difffile);
 }
 else if (!strcmp("t1124.cxx", filename)) {
   ret += ci(kLangCXX, "t1124.cxx", difffile);
 }
 else if (!strcmp("t1125.cxx", filename)) {
   ret += ci(kLangCXX, "t1125.cxx", difffile);
 }
 else if (!strcmp("t1126.cxx", filename)) {
   ret += ci(kLangCXX, "t1126.cxx", difffile);
 }
 else if (!strcmp("t1127.cxx", filename)) {
  #if !defined(G__APPLE)
   // This not work on macos and on 64bit linux because of var_arg
   if (sizeof(void*)<8 || (G__CINTVERSION > 70000000) ) {
      ret += ci(kLangCXX, "t1127.cxx", difffile);
      ret += mkci(kLangCXX, "t1127.cxx", "t1127.h", difffile);  //
   }
  #endif // !G__APPLE
 }
 else if (!strcmp("t1128.cxx", filename)) {
   ret += ci(kLangCXX, "t1128.cxx", difffile);  // looks to me gcc3.2 has a bug
 }
 else if (!strcmp("t1129.cxx", filename)) {
   ret += ci(kLangCXX, "t1129.cxx", difffile);  // g++3.2 fails
 }
 else if (!strcmp("t1134.cxx", filename)) {
   ret += ci(kLangCXX, "t1134.cxx", difffile);
 }
 else if (!strcmp("t1136.cxx", filename)) {
   ret += ci(kLangCXX, "t1136.cxx", difffile);
 }
 else if (!strcmp("t1140.cxx", filename)) {
   ret += ci(kLangCXX, "t1140.cxx", difffile);
 }
 else if (!strcmp("t1144.cxx", filename)) {
   ret += ci(kLangCXX,"t1144.cxx",difffile);
   ret += ci(kLangCXX,"t1144.cxx",difffile,"","","-Y0");
   ret += ci(kLangCXX,"t1144.cxx",difffile,"","","-Y1");
 }
 else if (!strcmp("t1148.cxx", filename)) {
   ret += ci(kLangCXX, "t1148.cxx", difffile);
 }
 else if (!strcmp("t1157.cxx", filename)) {
   ret += ci(kLangCXX, "t1157.cxx", difffile);
 }
 else if (!strcmp("t1158.cxx", filename)) {
   ret += ci(kLangCXX, "t1158.cxx", difffile);
 }
 else if (!strcmp("t1160.cxx", filename)) {
   ret += ci(kLangCXX, "t1160.cxx", difffile);
 }
 else if (!strcmp("aryinit0.cxx", filename)) {
   ret += ci(kLangCXX, "aryinit0.cxx", difffile);
 }
 else if (!strcmp("aryinit1.cxx", filename)) {
   ret += ci(kLangCXX, "aryinit1.cxx", difffile);
 }
 else if (!strcmp("t1164.cxx", filename)) {
   ret += ci(kLangCXX, "t1164.cxx", difffile);
 }
 else if (!strcmp("t1165.cxx", filename)) {
   ret += ci(kLangCXX, "t1165.cxx", difffile);
 }
 else if (!strcmp("t1178.cxx", filename)) {
   ret += ci(kLangCXX, "t1178.cxx", difffile);
 }
 else if (!strcmp("t1187.cxx", filename)) {
   ret += mkci(kLangCXX, "t1187.cxx", "t1187.h", difffile);
 }
 else if (!strcmp("t1192.cxx", filename)) {
   ret += ci(kLangCXX, "t1192.cxx", difffile);
 }
 else if (!strcmp("t1193.cxx", filename)) {
   ret += mkci(kLangCXX, "t1193.cxx", "t1193.h", difffile);
 }
 else if (!strcmp("t1203.cxx", filename)) {
   ret += ci(kLangCXX, "t1203.cxx", difffile);
 }
 else if (!strcmp("t1205.cxx", filename)) {
   ret += ci(kLangCXX, "t1205.cxx", difffile);
   ret += mkci(kLangCXX, "t1205.cxx", "t1205.h", difffile);
 }
 else if (!strcmp("t1213.cxx", filename)) {
   ret += ci(kLangCXX, "t1213.cxx", difffile);
 }
 else if (!strcmp("t1214.cxx", filename)) {
   ret += ci(kLangCXX, "t1214.cxx", difffile);
 }
 else if (!strcmp("t1215.cxx", filename)) {
   ret += ci(kLangCXX, "t1215.cxx", difffile);
   ret += mkci(kLangCXX, "t1215.cxx", "t1215.h", difffile);
 }
 else if (!strcmp("t1221.cxx", filename)) {
   ret += ci(kLangCXX, "t1221.cxx", difffile);
 }
 else if (!strcmp("t1222.cxx", filename)) {
   ret += ci(kLangCXX, "t1222.cxx", difffile);
 }
 else if (!strcmp("t1223.cxx", filename)) {
   ret += ci(kLangCXX, "t1223.cxx", difffile);
 }
 else if (!strcmp("t1224.cxx", filename)) {
   ret += ci(kLangCXX, "t1224.cxx", difffile);
 }
 else if (!strcmp("t1228.cxx", filename)) {
   ret += io("t1228.cxx", "t1228.ref", difffile);
 }
 else if (!strcmp("t1247.cxx", filename)) {
   ret += mkciN(kLangCXX, "t1247.cxx", "t1247.h", difffile, "", "t1247a.h");
 }
 else if (!strcmp("t1276.cxx", filename)) {
   ret += mkci(kLangCXX, "t1276.cxx", "t1276.h", difffile);
 }
 else if (!strcmp("t1277.cxx", filename)) {
  // works only with gcc2.96
   ret += mkci(kLangCXX, "t1277.cxx", "t1277.h", difffile); 
 }
 else if (!strcmp("t1278.cxx", filename)) {
   ret += ci(kLangCXX, "t1278.cxx", difffile);
 }
 else if (!strcmp("t1279.cxx", filename)) {
   ret += ci(kLangCXX, "t1279.cxx", difffile);
 }
 else if (!strcmp("t1280.cxx", filename)) {
   ret += ci(kLangCXX, "t1280.cxx", difffile);
 }
 else if (!strcmp("t1281.cxx", filename)) {
   ret += ci(kLangCXX, "t1281.cxx", difffile);
 }
 else if (!strcmp("t1282.cxx", filename)) {
   ret += ci(kLangCXX, "t1282.cxx", difffile);
 }
 else if (!strcmp("t1283.cxx", filename)) {
   ret += ci(kLangCXX, "t1283.cxx", difffile);
 }
 else if (!strcmp("t1284.cxx", filename)) {
   ret += ci(kLangCXX, "t1284.cxx", difffile);
 }
 else if (!strcmp("t1286.cxx", filename)) {
  #if G__CINTVERSION > 70000000
   ret += ci(kLangCXX, "t1286.cxx", difffile);
  #endif
 }
 else if (!strcmp("postinc.cxx", filename)) {
   ret += ci(kLangCXX, "postinc.cxx", difffile);
 }
 else if (!strcmp("selfreference.cxx", filename)) {
   ret += mkci(kLangCXX, "selfreference.cxx", "selfreference.h", difffile);
 }
 else if (!strcmp("abstract.cxx", filename)) {
   ret += ci(kLangCXX, "abstract.cxx", difffile);
 }
 else if (!strcmp("TExeception.cxx", filename)) {
   ret += ci(kLangCXX, "TException.cxx", difffile);
 }
 else if (!strcmp("enums.cxx", filename)) {
   ret += mkci(kLangCXX, "enums.cxx", "enums.h", difffile);
 }
 else if (!strcmp("classinfo.cxx", filename)) {
   ret += io("classinfo.cxx", "classinfo.ref", difffile);
 }
 else if (!strcmp("iostream_state.cxx", filename)) {
   ret += ci(kLangCXX, "iostream_state.cxx", difffile);
 }
 else {
   fprintf(stderr,"The test %s is not supported.\n",filename);
   ret += 1;
 }

  if (0==ret) {
    fprintf(stderr,"The test %s succeed.\n",filename);
    return ret;
  } else {   
    fprintf(stderr,"The test %s fail.\n",filename);
    return ret;
  }
}

/*
 * Local Variables:
 * c-tab-always-indent:nil
 * c-indent-level:3
 * c-continued-statement-offset:3
 * c-brace-offset:-3
 * c-brace-imaginary-offset:0
 * c-argdecl-indent:0
 * c-label-offset:-3
 * compile-command:"make -k"
 * End:
 */
