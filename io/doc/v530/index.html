<br/> 
<hr/> 
<a name="io"></a> 
<h3>I/O</h3>
<ul>
<li>Add support for the Chirp filesystem.  To configure and build, chirp 3.2.2 must be installed.</li>
<li>When a <tt>TFile</tt> object is deleted, make sure that CINT also 'removes' any global variables that might point to it.</li>
<li>Fix support for the automatic addition to the current directory (for <tt>TTree</tt> and <tt>TH1</tt> for example) in <tt>TKey::Read(TObject*).</tt></li>
<li>In <tt>TKey</tt>, properly handle error in the I/O routines.</li>
<li>Explicitly check the validity of the zipped buffer before calling <tt>R__unzip</tt>, this allow for better error recovery.</li>
<li>When double checking whether a checksum difference is sustantial, ignore the std namespace.   Use <tt>CompareContent</tt> also in the case of where 
the class is versioned but the 'current' streamerInfo has not yet been built.</li>
<li>Prevent the I/O engine from mistakenly applying schema evolution to the <tt>TObject::fBits.</tt></li>
<li>Make sure that when a streamer info of a base class is used to stream memberwise that is always not-optimized. If the StreamerInfo on file 
has the same version as the StreamerInfo in memory but the one on file need to be 'not optimized' while the one in memory is not yet built, make 
sure it will not be optimized.</li>
<li>Fix the reading of empty collection of object when reading without the library.</li>
<li>If the sequence of actions for streaming member-wise is not created correctly (i.e. where <tt>fReadMemberWise</tt> was null previously),
we know explicitly issue a Fatal error:
<pre style="border:gray 1px solid;padding:0.5em 2em;background:#ffe">
Fatal in &lt;ReadSequence&gt;: The sequence of actions to read AliESDVertex:7 member-wise was not initialized.
aborting
</pre></li>
<li>Add new optional parameter maxbuf to <tt>TXMLEngine::ParseFile()</tt> allowing the specification of the XML file size to be parsed. This fixes issue <a href=https://savannah.cern.ch/bugs/?78864>#78864</a>.</li>
<li><h4>MakeProject</h4>
  <ul>
  <li>Add support for the case when the requested project/files in path that in not under the current directory</li>
  <li>Generate the code/dictonary only for pair type that do not already have a dictionary</li>
  </ul>
</li>
</ul>

<h4>Asynchronous Prefetching</h4>
<ul>
<li>The prefetching mechanism uses two new classes (<tt>TFilePrefetch</tt> 
and <tt>TFPBlock</tt>) to prefetch in advance a block of tree entries. There
is a thread which takes care of actually transferring the blocks and
making them available to the main requesting thread. Therefore, the time
spent by the main thread waiting for the data before processing considerably
decreases. Besides the prefetching mechanisms there is also a local
caching option which can be enabled by the user. Both capabilities are
disabled by default and must be explicitly enabled by the user. 
</li>

<li>In order to enable the prefetching the user must set the rootrc environment
variable <tt>TFile.AsyncPrefetching</tt> as follows: 
<tt>gEnv->SetValue("TFile.AsyncPrefetching", 1)</tt>. Only when the
prefetching is enabled can the user set the local cache directory in
which the file transferred will be saved. For subsequent reads of the
same file the system will use the local copy of the file from cache.
To set up a local cache directory, the client can use the following commands:
</li>
<pre style="border:gray 1px solid;padding:0.5em 2em;background:#ffe">
  TString cachedir="file:/tmp/xcache/";
  // or using xrootd on port 2000  
  // TString cachedir="root://localhost:2000//tmp/xrdcache1/";
  gEnv->SetValue("Cache.Directory", cachedir.Data());
</pre>

<li>The <tt>TFilePrefetch</tt> class is responsible for actually reading
and storing the requests received from the main thread. It also creates
the working thread which will transfer all the information. Apart from
managing the block requests, it also deals with caching the blocks on
the local machine and retrieving them when necessary. 
</li>

<li>The <tt>TFPBlock</tt> class represents the encapsulation of a block
request. It contains the chunks to be prefetched and also serves as a
container for the information read.</li>

<li>In order to accommodate the new prefetching mechanism the following
files have been modified: <tt>TFileCacheRead.cxx/.h</tt>,
<tt>TTreeCache.cxx/.h</tt> and to a less extent <tt>TXNetFile.cxx</tt>,
<tt>TFile.h</tt>. Basically in <tt>TFileCacheRead</tt> we've added the
logic for dealing with the second buffer that is prefetched. In
<tt>TTreeCache</tt> during prefetching the method FillBuffer is called
after each read so that once the main thread starts reading from the
beginning of the last available buffer, the second thread starts
prefetching the next block.
</li>
</ul>
