<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
         xmlns:mml="http://www.w3.org/1998/Math/MathML">

<title>Graphics and the Graphical User Interface</title>

<para>Graphical capabilities of ROOT range from 2D objects (lines, polygons,
arrows) to various plots, histograms, and 3D graphical objects. In this chapter,
we are going to focus on principals of graphics and 2D objects. Plots and
histograms are discussed in a chapter of their own.</para>

<sect1>
<title>Drawing Objects</title>
<para>In ROOT, most objects derive from a base class
<emphasis role="bold"><code>TObject</code></emphasis>. This class has a virtual
method <code>Draw()</code> so all objects are supposed to be able to be "drawn".
The basic whiteboard on which an object is drawn is called a canvas (defined by
the class <emphasis role="bold"><code>TCanvas</code></emphasis>). If several
canvases are defined, there is only one active at a time. One draws an object in
the active canvas by using the statement:</para>

<programlisting language="c++">object.Draw()
</programlisting>

<para>This instructs the object "<code>object</code>" to draw itself. If no
canvas is opened, a default one (named "<code>c1</code>") is instantiated and is
drawn.</para>

<programlisting language="c++">root[] <emphasis role="bold">TLine a(0.1,0.1,0.6,0.6)</emphasis>
root[] <emphasis role="bold">a.Draw()</emphasis>
&lt;TCanvas::MakeDefCanvas&gt;: created default TCanvas with name c1
</programlisting>

<para>The first statement defines a line and the second one draws it. A default
canvas is drawn since there was no opened one.</para>
</sect1>

<sect1>
<title>Interacting with Graphical Objects</title>
<para>When an object is drawn, one can interact with it. For example, the line
drawn in the previous paragraph may be moved or transformed. One very important
characteristic of ROOT is that transforming an object on the screen will also
transform it in memory. One actually interacts with the real object, not with a
copy of it on the screen. You can try for instance to look at the starting X
coordinate of the line:</para>

<programlisting language="c++">root[] a.GetX1()
(double)1.000000000e-1
</programlisting>

<para><code>X1</code> is the <code>x</code> value of the starting coordinate
given in the definition above. Now move it interactively by clicking with the
left mouse button in the line's middle and try to do again:</para>

<programlisting language="c++">root[] a.GetX1()
(Double_t)1.31175468483816005e-01
</programlisting>

<para>You do not obtain the same result as before, the coordinates of
'<code>a</code>' have changed. As said, interacting with an object on the screen
changes the object in memory.</para>

<sect2>
<title>Moving, Resizing and Modifying Objects</title>
<para>Changing the graphic objects attributes can be done with the GUI or
programmatically. First, let's see how it is done in the GUI.</para>

<sect3>
<title>The Left Mouse Button</title>
<para>As was just seen moving or resizing an object is done with the left mouse
button. The cursor changes its shape to indicate what may be done:</para>
<para>Point the object or one part of it:
<inlinemediaobject><imageobject><imagedata fileref="pictures/02000095.jpg" width="9.95pt" depth="9.95pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/02000096.jpg" width="10.55pt" depth="9.95pt"/></imageobject></inlinemediaobject>
</para>
<para>Rotate:
<inlinemediaobject><imageobject><imagedata fileref="pictures/02000097.jpg" width="9.95pt" depth="9.95pt"/></imageobject></inlinemediaobject>
</para>
<para>Resize (exists also for the other directions):
<inlinemediaobject><imageobject><imagedata fileref="pictures/02000098.jpg" width="9.95pt" depth="9.95pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/02000099.jpg" width="11.15pt" depth="10.55pt"/></imageobject></inlinemediaobject>
</para>
<para>Enlarge (used for text):
<inlinemediaobject><imageobject><imagedata fileref="pictures/0200009A.jpg" width="9.95pt" depth="11.15pt"/></imageobject></inlinemediaobject>
</para>
<para>Move:
<inlinemediaobject><imageobject><imagedata fileref="pictures/0200009B.jpg" width="9.95pt" depth="9.95pt"/></imageobject></inlinemediaobject>
</para>
<para>Here are some examples of:</para>
<para>
Moving:
<inlinemediaobject><imageobject><imagedata fileref="pictures/0200009C.jpg" width="74.5pt" depth="57.1pt"/></imageobject></inlinemediaobject>
Resizing:
<inlinemediaobject><imageobject><imagedata fileref="pictures/0200009D.jpg" width="105.5pt" depth="57.1pt"/></imageobject></inlinemediaobject>
</para>
<para>
Rotating:
<inlinemediaobject><imageobject><imagedata fileref="pictures/0200009E.jpg" width="91.85pt" depth="56.5pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0300009F.png" width="75.1pt" depth="57.1pt"/></imageobject></inlinemediaobject>
</para>
</sect3>

<sect3>
<title>With C++ Statements (Programmatically)</title>
<para>How would one move an object in a script? Since there is a tight
correspondence between what is seen on the screen and the object in memory,
changing the object changes it on the screen. For example, try to do:</para>

<programlisting language="c++">root[] <emphasis role="bold">a.SetX1(0.9)</emphasis>
</programlisting>

<para>This should change one of the coordinates of our line, but nothing happens
on the screen. Why is that? In short, the canvas is not updated with each change
for performance reasons. See "Updating the Pad".</para>
</sect3>
</sect2>

<sect2>
<title>Selecting Objects</title>

<sect3>
<title>The Middle Mouse Button</title>
<para>Objects in a canvas, as well as in a pad, are stacked on top of each other
in the order they were drawn. Some objects may become “active” objects, which
mean they are reordered to be on top of the others. To interactively make an
object "active", you can use the middle mouse button. In case of canvases or
pads, the border becomes highlighted when it is active.</para>
</sect3>

<sect3>
<title>With C++ Statements (Programmatically)</title>
<para>Frequently we want to draw in different canvases or pads. By default, the
objects are drawn in the active canvas. To activate a canvas you can use the
<emphasis role="bold"><code>TPad</code></emphasis><code>::cd()</code>
method.</para>

<programlisting language="c++">root[] c1-&gt;cd()
</programlisting>

</sect3>
</sect2>

<sect2>
<title>Context Menus: the Right Mouse Button</title>
<para>The context menus are a way to interactively call certain methods of an
object. When designing a class, the programmer can add methods to the context
menu of the object by making minor changes to the header file.</para>

<sect3>
<title>Using Context Menus</title>
<para>On a ROOT canvas, you can right-click on any object and see the context
menu for it. The script <code>hsimple.C</code> draws a histogram. The image
below shows the context menus for some of the objects on the canvas. Next
picture shows that drawing a simple histogram involves as many as seven objects.
When selecting a method from the context menu and that method has options, the
user will be asked for numerical values or strings to fill in the option. For
example,
<emphasis role="bold"><code>TAxis</code></emphasis><code>::SetTitle</code>
will prompt you for a string to use for the axis title.</para>

<figure><title>Context menus of different objects in a canvas</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000A0.png" width="235.25pt" depth="214.75pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Structure of the Context Menus</title>
<para>The curious reader will have noticed that each entry in the context menu
corresponds to a method of the class. Look for example to the menu named
<emphasis role="bold"><code>TAxis</code></emphasis><code>::xaxis</code>.
<code>xaxis</code> is the name of the object and
<emphasis role="bold"><code>TAxis</code></emphasis> the name of its class. If we
look at the list of <emphasis role="bold"><code>TAxis</code></emphasis> methods,
for example in
<uri xmlns:xlink="http://root.cern.ch/root/htmldoc/TAxis.html">http://root.cern.ch/root/htmldoc/TAxis.html</uri>,
we see the methods <code>SetTimeDisplay()</code> and<code> UnZoom()</code>,
which appear also in the context menu.</para>
<para>There are several divisions in the context menu, separated by lines. The
top division is a list of the class methods; the second division is a list of
the parent class methods. The subsequent divisions are the methods other parent
classes in case of multiple inheritance. For example, see the
<emphasis role="bold"><code>TPaveText</code></emphasis><code>::title context
menu.</code> A <emphasis role="bold"><code>TPaveText</code></emphasis> inherits
from <emphasis role="bold"><code>TAttLine</code></emphasis>, which has the
method <code>SetLineAttributes()</code>.</para>
</sect3>

<sect3>
<title>Adding Context Menus for a Class</title>
<para>For a method to appear in the context menu of the object it has to be
marked by <code>// *MENU*</code> in the header file. Below is the line from
<code>TAttLine.h</code> that adds the <code>SetLineAttribute</code> method to
the context menu.</para>

<programlisting language="c++">virtual void  SetLineAttributes(); // *MENU*
</programlisting>

<para>Nothing else is needed, since CINT knows the classes and their methods. It
takes advantage of that to create the context menu on the fly when the object is
clicking on. If you click on an axis, ROOT will ask the interpreter what are the
methods of the <emphasis role="bold"><code>TAxis</code></emphasis> and which
ones are set for being displayed in a context menu.</para>
<para>Now, how does the interpreter know this? Remember, when you build a class
that you want to use in the ROOT environment, you use <code>rootcint</code> that
builds the so-called stub functions and the dictionary. These functions and the
dictionary contain the knowledge of the used classes. To do this,
<code>rootcint</code> parses all the header files. ROOT has defined some special
syntax to inform CINT of certain things, this is done in the comments so that
the code still compiles with a C++ compiler.</para>
<para>For example, you have a class with a <code>Draw()</code> method, which
will display itself.  You would like a context menu to appear when on clicks on
the image of an object of this class. The recipe is the following:</para>

<itemizedlist>
<listitem><para>
The class has to contain the <code>ClassDef/ClassImp</code> macros
</para></listitem>
<listitem><para>
For each method you want to appear in the context menu, put a comment after the
declaration containing <code>*MENU*</code> or <code>*TOGGLE*</code> depending on
the behavior you expect. One usually uses Set methods (setters). The
<code>*TOGGLE*</code> comment is used to toggle a <code>boolean</code> data
field. In that case, it is safe to call the data field <code>fMyBool</code>
where <code>MyBool</code> is the name of the setter <code>SetMyBool</code>.
Replace <code>MyBool</code> with your own <code>boolean</code> variable.
</para></listitem>
<listitem><para>
You can specify arguments and the data members in which to store the arguments.
</para></listitem>
</itemizedlist>

<para>For example:</para>

<programlisting language="c++">class MyClass : public TObject {
private:
   int      fV1;   <emphasis role="italic">// first variable</emphasis>
   double   fV2;   <emphasis role="italic">// second variable</emphasis>
public:
   int    GetV1() {return fV1;}
   double GetV2() {return fV2;}
   void   SetV1(int x1) { fV1 = x1;}     <emphasis role="italic">// *MENU*</emphasis>
   void   SetV2(double d2) { fV2 = d2;}  <emphasis role="italic">// *MENU*</emphasis>
   void   SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}

   ClassDef (MyClass,1)
}
</programlisting>

<para>To specify arguments:</para>

<programlisting language="c++">void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=&gt;fV1}
</programlisting>

<para>This statement is in the comment field, after the *MENU*. If there is more
than one argument, these arguments are separated by commas, where fX1 and fY2
are data fields in the same class.</para>

<programlisting language="c++">void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=&gt;fX1,y2=&gt;fY2}
</programlisting>

<para>If the arguments statement is present, the option dialog displayed when
selecting <code>SetXXX field</code> will show the values of variables. We
indicate to the system which argument corresponds to which data member of the
class.</para>
</sect3>
</sect2>

<sect2>
<title>Executing Events when a Cursor Passes on Top of an Object</title>
<para>This paragraph is for class designers. When a class is designed, it is
often desirable to include drawing methods for it. We will have a more extensive
discussion about this, but drawing an object in a canvas or a pad consists in
"attaching" the object to that pad. When one uses <code>object.Draw()</code>,
the object is NOT painted at this moment. It is only attached to the active pad
or canvas.</para>
<para>Another method should be provided for the object to be painted, the
<code>Paint()</code> method. This is all explained in the next paragraph. As
well as <code>Draw()</code> and <code>Paint()</code>, other methods may be
provided by the designer of the class. When the mouse is moved or a button
pressed/released, the <emphasis role="bold"><code>TCanvas</code></emphasis>
function named <code>HandleInput()</code> scans the list of objects in all it's
pads and for each object calls some standard methods to make the object react to
the event (mouse movement, click or whatever).</para>
<para>The second one is <code>DistanceToPrimitive(px,py)</code>. This function
computes a "distance" to an object from the mouse position at the pixel position
(<code>px</code>, <code>py</code>, see definition at the end of this paragraph)
and returns this distance in pixel units. The selected object will be the one
with the shortest computed distance. To see how this works, select the
"<code>Event Status</code>" item in the canvas "<code>Options</code>" menu. ROOT
will display one status line showing the picked object. If the picked object is,
for example, a histogram, the status line indicates the name of the histogram,
the position <code>x,y</code> in histogram coordinates, the channel number and
the channel content.</para>
<para>It is nice for the canvas to know what the closest object from the mouse
is, but it's even nicer to be able to make this object react. The third standard
method to be provided is <code>ExecuteEvent()</code>. This method actually does
the event reaction. Its prototype is where <code>px</code> and <code>py</code>
are the coordinates at which the event occurred, except if the event is a key
press, in which case <code>px</code> contains the key code.</para>

<programlisting language="c++">void ExecuteEvent(Int_t event, Int_t px, Int_t py);
</programlisting>

<para>Where <code>event</code> is the event that occurs and is one of the
following (defined in <code>Buttons.h</code>):</para>

<programlisting language="c++">kNoEvent,          kButton1Down,      kButton2Down,
kButton3Down,      kKeyDown,          kButton1Up,
kButton2Up,        kButton3Up,        kButton1Motion,
kButton2Motion,    kButton3Motion,    kKeyPress,
kButton1Locate,    kButton2Locate,    kButton3Locate,
kKeyUp,            kButton1Double,    kButton2Double,
kButton3Double,    kMouseMotion,      kMouseEnter,
kMouseLeave
</programlisting>

<para>We hope the names are self-explanatory.</para>
<para>Designing an <code>ExecuteEvent</code> method is not very easy, except if
one wants very basic treatment. We will not go into that and let the reader
refer to the sources of classes like
<emphasis role="bold"><code>TLine</code></emphasis> or
<emphasis role="bold"><code>TBox</code></emphasis>. Go and look at their
<code>ExecuteEvent</code> method! We can nevertheless give some reference to the
various actions that may be performed. For example, one often wants to change
the shape of the cursor when passing on top of an object. This is done with the
<code>SetCursor</code> method:</para>

<programlisting language="c++">gPad-&gt;SetCursor(cursor)
</programlisting>

<para>The argument <code>cursor</code> is the type of cursor. It may be:</para>

<programlisting language="c++">kBottomLeft,  kBottomRight,  kTopLeft,
kTopRight,    kBottomSide,   kLeftSide,
kTopSide,     kRightSide,    kMove,
kCross,       kArrowHor,     kArrowVer,
kHand,        kRotate,       kPointer,
kArrowRight,  kCaret,        kWatch
</programlisting>

<para>They are defined in <code>TVirtualX.h</code> and again we hope the names
are self-explanatory. If not, try them by designing a small class. It may derive
from something already known like
<emphasis role="bold"><code>TLine</code></emphasis>.</para>
<para>Note that the <code>ExecuteEvent()</code> functions may in turn; invoke
such functions for other objects, in case an object is drawn using other
objects. You can also exploit at best the virtues of inheritance. See for
example how the class <emphasis role="bold"><code>TArrow</code></emphasis>
(derived from <emphasis role="bold"><code>TLine</code></emphasis>) use or
redefine the picking functions in its base class.</para>
<para>The last comment is that mouse position is always given in pixel units in
all these standard functions. <code>px=0</code> and <code>py=0</code>
corresponds to the top-left corner of the canvas. Here, we have followed the
standard convention in windowing systems. Note that user coordinates in a canvas
(pad) have the origin at the bottom-left corner of the canvas (pad). This is all
explained in the paragraph "The Coordinate Systems of a Pad".</para>
</sect2>
</sect1>

<sect1>
<title>Graphical Containers: Canvas and Pad</title>
<para>We have talked a lot about canvases, which may be seen as windows. More
generally, a graphical entity that contains graphical objects is called a Pad. A
Canvas is a special kind of Pad. From now on, when we say something about pads,
this also applies to canvases. A pad (class
<emphasis role="bold"><code>TPad</code></emphasis>) is a graphical container in
the sense it contains other graphical objects like histograms and arrows. It may
contain other pads (sub-pads) as well. More technically, each pad has a linked
list of pointers to the objects it holds.</para>
<para>Drawing an object is nothing more than adding its pointer to this list.
Look for example at the code of
<emphasis role="bold"><code>TH1</code></emphasis><code>::Draw()</code>. It is
merely ten lines of code. The last statement is <code>AppendPad()</code>. This
statement calls method of <emphasis role="bold"><code>TObject</code></emphasis>
that just adds the pointer of the object, here a histogram, to the list of
objects attached to the current pad. Since this is a
<emphasis role="bold"><code>TObject</code></emphasis>’s method, every object may
be "drawn", which means attached to a pad. We can illustrate this by the
Figure 9-2. This image corresponds to the following structure:</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060000A1.png" width="117.95pt" depth="78.2pt"/></imageobject></inlinemediaobject>
</para>

<figure><title>A histogram drawn in a pad</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000A2.jpg" width="253.85pt" depth="158.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>When is the painting done then? The answer is: when needed. Every object
that derives from <emphasis role="bold"><code>TObject</code></emphasis> has a
<code>Paint()</code> method. It may be empty, but for graphical objects, this
routine contains all the instructions to paint effectively it in the active pad.
Since a Pad has the list of objects it owns, it will call successively the
<code>Paint()</code> method of each object, thus re-painting the whole pad on
the screen. If the object is a sub-pad, its <code>Paint()</code> method will
call the <code>Paint()</code> method of the objects attached, recursively
calling <code>Paint()</code> for all the objects.</para>

<sect2>
<title>The Global Pad: gPad</title>
<para>When an object is drawn, it is always in the so-called active pad. For
every day use, it is comfortable to be able to access the active pad, whatever
it is. For that purpose, there is a global pointer, called
<emphasis role="italic"><emphasis role="bold"><code>gPad</code></emphasis></emphasis>.
It is always pointing to the active pad. If you want to change the fill color of
the active pad to blue but you do not know its name, do this.</para>

<programlisting language="c++">root[] gPad-&gt;SetFillColor(38)
</programlisting>

<para>To get the list of colors, go to the paragraph "Color and color palettes"
or if you have an opened canvas, click on the <code>View</code> menu, selecting
the <code>Colors</code> item.</para>

<sect3>
<title>Finding an Object in a Pad</title>
<para>Now that we have a pointer to the active pad,
<emphasis role="italic"><emphasis role="bold"><code>gPad</code></emphasis></emphasis>
and that we know this pad contains some objects, it is sometimes interesting to
access one of those objects. The method <code>GetPrimitive()</code> of
<emphasis role="bold"><code>TPad</code></emphasis>, i.e.
<emphasis role="bold"><code>TPad</code></emphasis><code>::GetPrimitive(const char* name)</code>
does exactly this. Since most of the objects that a pad contains derive from
<emphasis role="bold"><code>TObject</code></emphasis>, they have a name. The
following statement will return a pointer to the object
<code>myobjectname</code> and put that pointer into the variable
<code>obj</code>. As you can see, the type of returned pointer is
<emphasis role="bold"><code>TObject</code></emphasis><code>*</code>.</para>

<programlisting language="c++">root[] obj = gPad-&gt;GetPrimitive("myobjectname")
(class TObject*)0x1063cba8
</programlisting>

<para>Even if your object is something more complicated, like a histogram
<emphasis role="bold"><code>TH1F</code></emphasis>, this is normal. A function
cannot return more than one type. So the one chosen was the lowest common
denominator to all possible classes, the class from which everything derives,
<emphasis role="bold"><code>TObject</code></emphasis>. How do we get the right
pointer then? Simply do a cast of the function output that will transform the
output (pointer) into the right type. For example if the object is a
<emphasis role="bold"><code>TPaveLabel</code></emphasis>:</para>

<programlisting language="c++">root[] obj = (TPaveLabel*)(gPad-&gt;GetPrimitive("myobjectname"))
(class TPaveLabel*)0x1063cba8
</programlisting>

<para>This works for all objects deriving from
<emphasis role="bold"><code>TObject</code></emphasis>. However, a question
remains. An object has a name if it derives from
<emphasis role="bold"><code>TNamed</code></emphasis>, not from
<emphasis role="bold"><code>TObject</code></emphasis>. For example, an arrow
(<emphasis role="bold"><code>TArrow</code></emphasis>) doesn't have a name. In
that case, the "name" is the name of the class. To know the name of an object,
just click with the right button on it. The name appears at the top of the
context menu. In case of multiple unnamed objects, a call to
<code>GetPrimitive("className")</code> returns the instance of the class that
was first created. To retrieve a later instance you can use
<code>GetListOfPrimitives()</code>, which returns a list of all the objects on
the pad. From the list you can select the object you need.</para>
</sect3>

<sect3>
<title>Hiding an Object</title>
<para>Hiding an object in a pad can be made by removing it from the list of
objects owned by that pad. This list is accessible by the
<code>GetListOfPrimitives()</code> method of
<emphasis role="bold"><code>TPad</code></emphasis>. This method returns a
pointer to a <emphasis role="bold"><code>TList</code></emphasis>. Suppose we get
the pointer to the object, we want to hide, call it <code>obj</code> (see
paragraph above). We get the pointer to the list:</para>

<programlisting language="c++">root[] <emphasis role="bold">li = gPad-&gt;GetListOfPrimitives()</emphasis>
</programlisting>

<para>Then remove the object from this list:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>li-&gt;Remove(obj)</code></emphasis>
</programlisting>

<para>The object will disappear from the pad as soon as the pad is updated (try
to resize it for example). If one wants to make the object reappear:</para>

<programlisting language="c++">root[] obj-&gt;Draw()
</programlisting>

<para>Caution, this will not work with composed objects, for example many
histograms drawn on the same plot (with the option "<code>same</code>"). There
are other ways! Try to use the method described here for simple objects.</para>
</sect3>
</sect2>

<sect2>
<title>The Coordinate Systems of a Pad</title>
<para>There are coordinate systems in a
<emphasis role="bold"><code>TPad</code></emphasis>: user coordinates, normalized
coordinates (NDC), and pixel coordinates.</para>

<figure><title>Pad coordinate systems</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080000A3.png" width="253.25pt" depth="72.6pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<sect3>
<title>The User Coordinate System</title>
<para>The most common is the user coordinate system. Most methods of
<emphasis role="bold"><code>TPad</code></emphasis> use the user coordinates, and
all graphic primitives have their parameters defined in terms of user
coordinates. By default, when an empty pad is drawn, the user coordinates are
set to a range from 0 to 1 starting at the lower left corner. At this point they
are equivalent of the NDC coordinates (see below). If you draw a high level
graphical object, such as a histogram or a function, the user coordinates are
set to the coordinates of the histogram. Therefore, when you set a point it will
be in the histogram coordinates.</para>
<para>For a newly created blank pad, one may use
<emphasis role="bold"><code>TPad</code></emphasis><code>::Range</code> to set
the user coordinate system. This function is defined as:</para>

<programlisting language="c++">void Range(float x1,float y1,float x2,float y2)
</programlisting>

<para>The arguments <code>x1</code>, <code>x2</code> defines the new range in
the x direction, and the <code>y1</code>, <code>y2</code> define the new range
in the y-direction.</para>

<programlisting language="c++">root[] <emphasis role="bold">TCanvas MyCanvas ("MyCanvas")</emphasis>
root[] <emphasis role="bold">gPad-&gt;Range(-100,-100,100,100)</emphasis>
</programlisting>

<para>This will set the active pad to have both coordinates to go from -100 to
100, with the center of the pad at (0,0). You can visually check the coordinates
by viewing the status bar in the canvas. To display the status bar select Event
Status entry in the View canvas menu.</para>

<figure><title>The status bar</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000A4.jpg" width="180pt" depth="22.95pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>The Normalized Coordinate System (NDC)</title>
<para>Normalized coordinates are independent of the window size and of the user
system. The coordinates range from 0 to 1 and (0, 0) corresponds to the
bottom-left corner of the pad. Several internal ROOT functions use the NDC
system (3D primitives, PostScript, log scale mapping to linear scale). You may
want to use this system if the user coordinates are not known ahead of
time.</para>
</sect3>

<sect3>
<title>The Pixel Coordinate System</title>
<para>The least common is the pixel coordinate system, used by functions such as
<code>DistanceToPrimitive()</code> and <code>ExecuteEvent()</code>. Its primary
use is for cursor position, which is always given in pixel coordinates. If
(<code>px,py</code>) is the cursor position, <code>px=0</code> and
<code>py=0</code> corresponds to the top-left corner of the pad, which is the
standard convention in windowing systems.</para>
</sect3>

<sect3>
<title>Using NDC for a particular Object</title>
<para>Most of the time, you will be using the user coordinate system. But
sometimes, you will want to use NDC. For example, if you want to draw text
always at the same place over a histogram, no matter what the histogram
coordinates are. There are two ways to do this. You can set the NDC for one
object or may convert NDC to user coordinates. Most graphical objects offer an
option to be drawn in NDC. For instance, a line
(<emphasis role="bold"><code>TLine</code></emphasis>) may be drawn in NDC by
using <code>DrawLineNDC()</code>. A latex formula or a text may use
<emphasis role="bold"><code>TText</code></emphasis><code>::SetNDC()</code> to be
drawn in NDC coordinates.</para>
</sect3>
</sect2>

<sect2>
<title>Converting between Coordinate Systems</title>
<para>There are a few utility functions in
<emphasis role="bold"><code>TPad</code></emphasis> to convert from one system of
coordinates to another. In the following table, a point is defined by
<code>(px,py)</code> in pixel coordinates, <code>(ux,uy)</code> in user
coordinates, <code>(ndcx,ndcy)</code> in normalized coordinates,
(<code>apx</code>, <code>apy</code>) are in absolute pixel
coordinates.</para>

<informaltable frame="all">
<tgroup cols="3">
<colspec colwidth="2550*" colname="column-1"/>
<colspec colwidth="3900*" colname="column-2"/>
<colspec colwidth="2200*" colname="column-3"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Conversion</para>
</entry>
<entry rowsep="1" colsep="1">
<para>TPad’s Methods</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Returns</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>NDC to Pixel</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>UtoPixel(ndcx)</code>
</para>
<para>
<code>VtoPixel(ndcy)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Int_t</para>
<para>Int_t</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>Pixel to User</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>PixeltoX(px)</code>
</para>
<para>
<code>PixeltoY(py)</code>
</para>
<para>
<code>PixeltoXY(px,py,&amp;ux,&amp;uy)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Double_t</para>
<para>Double_t</para>
<para>Double_t ux,uy </para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>User to Pixel</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>XtoPixel(ux)</code>
</para>
<para>
<code>YtoPixel(uy)</code>
</para>
<para>
<code>XYtoPixel(ux,uy,&amp;px,&amp;py)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Int_t</para>
<para>Int_t</para>
<para>Int_t px,py</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>User to absolute pixel</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>XtoAbsPixel(ux)</code>
</para>
<para>
<code>YtoAbsPixel(uy)</code>
</para>
<para>
<code>XYtoAbsPixel(ux,uy,&amp;apx,&amp;apy)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Int_t</para>
<para>Int_t</para>
<para>Int_t apx,apy</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>Absolute pixel to user</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>AbsPixeltoX(apx)</code>
</para>
<para>
<code>AbsPixeltoY(apy)</code>
</para>
<para>
<code>AbsPixeltoXY(apx,apy,&amp;ux,&amp;uy)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Double_t</para>
<para>Double_t</para>
<para>Double_t ux,uy</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>Note: all the pixel conversion functions along the Y axis consider that
<code>py=0</code> is at the top of the pad except <code>PixeltoY()</code> which
assume that the position <code>py=0</code> is at the bottom of the pad. To make
<code>PixeltoY()</code> converting the same way as the other conversion
functions, it should be used the following way (<code>p</code> is a pointer to a
<emphasis role="bold"><code>TPad</code></emphasis>):</para>

<programlisting language="c++">p-&gt;PixeltoY(py – p-&gt;GetWh());
</programlisting>

</sect2>

<sect2>
<title>Dividing a Pad into Sub-pads</title>
<para>Dividing a pad into sub pads in order for instance to draw a few
histograms, may be done in two ways. The first is to build pad objects and to
draw them into a parent pad, which may be a canvas. The second is to
automatically divide a pad into horizontal and vertical sub pads.</para>

<sect3>
<title>Creating a Single Sub-pad</title>
<para>The simplest way to divide a pad is to build sub-pads in it. However, this
forces the user to explicitly indicate the size and position of those sub-pads.
Suppose we want to build a sub-pad in the active pad (pointed by
<emphasis role="italic"><emphasis role="bold"><code>gPad</code></emphasis></emphasis>).
First, we build it, using a <emphasis role="bold"><code>TPad</code></emphasis>
constructor:</para>

<programlisting language="c++">root[] <emphasis role="bold">spad1 = new TPad("spad1","The first subpad",.1,.1,.5,.5)</emphasis>
</programlisting>

<para>One gives the coordinates of the lower left point (0.1, 0.1) and of the
upper right one (0.5, 0.5). These coordinates are in NDC. This means that they
are independent of the user coordinates system, in particular if you have
already drawn for example a histogram in the mother pad. The only thing left is
to draw the pad:</para>

<programlisting language="c++">root[] <emphasis role="bold">spad1-&gt;Draw()</emphasis>
</programlisting>

<para>If you want more sub-pads, you have to repeat this procedure as many times
as necessary.</para>
</sect3>

<sect3>
<title>Dividing a Canvas into Sub-Pads</title>
<para>The manual way of dividing a pad into sub-pads is sometimes very tedious.
There is a way to automatically generate horizontal and vertical sub-pads inside
a given pad.</para>

<programlisting language="c++">root[] <emphasis role="bold">pad1-&gt;Divide(3,2)</emphasis>
</programlisting>

<figure><title>Dividing a pad into 6 sub-pads</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000A5.png" width="207.95pt" depth="94.35pt"/></imageobject></inlinemediaobject>
</para>
<para>  
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000A6.jpg" width="164.5pt" depth="98.7pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>If <code>pad1</code> is a pad then, it will divide the pad into 3 columns
of 2 sub-pads. The generated sub-pads get names <code>pad1_i</code> where the
index <code>i=1</code> to <code>nxm</code> (in our case <code>pad1_1</code>,
<code>pad1_2</code>...<code>pad1_6)</code>. The names <code>pad1_1 </code>etc…
correspond to new variables in CINT, so you may use them as soon as the executed
method was <code>pad-&gt;Divide()</code>. However, in a compiled program, one
has to access these objects. Remember that a pad contains other objects and that
these objects may themselves be pads. So we can use the
<code>GetPrimitive()</code> method:</para>

<programlisting language="c++">TPad* pad1_1 = (TPad*)(pad1-&gt;GetPrimitive("pad1_1"))
</programlisting>

<para>One question remains. In case one does an automatic divide, how one can
set the default margins between pads? This is done by adding two parameters to
<code>Divide()</code>, which are the margins in <code>x</code> and
<code>y</code>:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>pad1-&gt;Divide(3,2,0.1,0.1)</code></emphasis>
</programlisting>

<para>The margins are here set to 10% of the parent pad width.</para>
</sect3>
</sect2>

<sect2>
<title>Updating the Pad</title>
<para>For performance reasons, a pad is not updated with every change. For
example, changing the coordinates of the pad does not automatically redraw it.
Instead, the pad has a "bit-modified" that triggers a redraw. This bit is
automatically set by:</para>

<itemizedlist>
<listitem><para>
Touching the pad with the mouse - for example resizing it with the mouse.
</para></listitem>
<listitem><para>
Finishing the execution of a script.
</para></listitem>
<listitem><para>
Adding a new primitive or modifying some primitives for example the name and
title of an object.
</para></listitem>
<listitem><para>
You can also set the "bit-modified" explicitly with the <code>Modified</code>
method:
<programlisting language="c++"><emphasis role="italic">// the pad has changed</emphasis>
root[] <emphasis role="bold">pad1-&gt;Modified()</emphasis>
<emphasis role="italic">// recursively update all modified pads:</emphasis>
root[] <emphasis role="bold">c1-&gt;Update()</emphasis>
</programlisting>
A subsequent call to
<emphasis role="bold"><code>TCanvas</code></emphasis><code>::Update()</code>
scans the list of sub-pads and repaints the pads declared modified.
</para></listitem>
</itemizedlist>

<para>In compiled code or in a long macro, you may want to access an object
created during the paint process. To do so, you can force the painting with a
<emphasis role="bold"><code>TCanvas</code></emphasis><code>::Update()</code>.
For example, a <emphasis role="bold"><code>TGraph</code></emphasis> creates a
histogram (<emphasis role="bold"><code>TH1</code></emphasis>) to paint itself.
In this case the internal histogram obtained with
<emphasis role="bold"><code>TGraph</code></emphasis><code>::GetHistogram()</code>
is created only after the pad is painted. The pad is painted automatically after
the script is finished executing or if you force the painting with
<emphasis role="bold"><code>TPad</code></emphasis><code>::Modified()</code>
followed by a
<emphasis role="bold"><code>TCanvas</code></emphasis><code>::Update()</code>.
Note that it is not necessary to call
<emphasis role="bold"><code>TPad</code></emphasis><code>::Modified()</code>
after a call to <code>Draw()</code>. The "bit-modified" is set automatically by
<code>Draw()</code>. A note about the "bit-modified" in sub pads: when you want
to update a sub pad in your canvas, you need to call
<code>pad-&gt;Modified()</code> rather than <code>canvas-&gt;Modified()</code>,
and follow it with a <code>canvas-&gt;Update()</code>. If you use
<code>canvas-&gt;Modified()</code>, followed by a call to
<code>canvas-&gt;Update()</code>, the sub pad has not been declared modified and
it will not be updated. Also note that a call to <code>pad-&gt;Update()</code>
where pad is a sub pad of canvas, calls <code>canvas-&gt;Update()</code> and
recursively updates all the pads on the canvas.</para>
</sect2>

<sect2>
<title>Making a Pad Transparent</title>
<para>As we will see in the paragraph "Fill Attributes", a fill style (type of
hatching) may be set for a pad.</para>

<programlisting language="c++">root[] <emphasis role="bold">pad1-&gt;SetFillStyle(istyle)</emphasis>
</programlisting>

<para>This is done with the <code>SetFillStyle</code> method where
<code>istyle</code> is a style number, defined in "Fill Attributes". A special
set of styles allows handling of various levels of transparency. These are
styles number 4000 to 4100, 4000 being fully transparent and 4100 fully opaque.
So, suppose you have an existing canvas with several pads. You create a new pad
(transparent) covering for example the entire canvas. Then you draw your
primitives in this pad. The same can be achieved with the graphics editor.
For example:</para>

<programlisting language="c++">root[] <emphasis role="bold">.x tutorials/hist/h1draw.C</emphasis>
root[] <emphasis role="bold">TPad *newpad=new TPad("newpad","Transparent pad",0,0,1,1);</emphasis>
root[] <emphasis role="bold">newpad-&gt;SetFillStyle(4000);</emphasis>
root[] <emphasis role="bold">newpad-&gt;Draw();</emphasis>
root[] <emphasis role="bold">newpad-&gt;cd();</emphasis>
root[] <emphasis role="italic">// create some primitives, etc</emphasis>
</programlisting>

</sect2>

<sect2>
<title>Setting the Log Scale</title>
<para>Setting the scale to logarithmic or linear is an attribute of the pad, not
the axis or the histogram. The scale is an attribute of the pad because you may
want to draw the same histogram in linear scale in one pad and in log scale in
another pad. Frequently, we see several histograms on top of each other in the
same pad. It would be very inconvenient to set the scale attribute for each
histogram in a pad.</para>
<para>Furthermore, if the logic was set in the histogram class (or each object)
the scale setting in each <code>Paint</code> method of all objects should be
tested.</para>
<para>If you have a pad with a histogram, a right-click on the pad, outside of
the histograms frame will convince you. The <code>SetLogx()</code>,
<code>SetLogy()</code> and <code>SetLogz()</code> methods are there. As you see,
<emphasis role="bold"><code>TPad</code></emphasis> defines log scale for the two
directions <code>x</code> and <code>y</code> plus <code>z</code> if you want to
draw a 3D representation of some function or histogram.</para>
<para>The way to set log scale in the x direction for the active pad is:</para>

<programlisting language="c++">root[] <emphasis role="bold">gPad-&gt;SetLogx(1)</emphasis>
</programlisting>

<para>To reset log in the z direction:</para>

<programlisting language="c++">root[] <emphasis role="bold">gPad-&gt;SetLogz(0)</emphasis>
</programlisting>

<para>If you have a divided pad, you need to set the scale on each of the
sub-pads. Setting it on the containing pad does not automatically propagate to
the sub-pads. Here is an example of how to set the log scale for the x-axis on a
canvas with four sub-pads:</para>

<programlisting language="c++">root[] <emphasis role="bold">TCanvas MyCanvas("MyCanvas","My Canvas")</emphasis>
root[] <emphasis role="bold">MyCanvas-&gt;Divide(2,2)</emphasis>
root[] <emphasis role="bold">MyCanvas-&gt;cd(1)</emphasis>
root[] <emphasis role="bold">gPad-&gt;SetLogx()</emphasis>
root[] <emphasis role="bold">MyCanvas-&gt;cd(2)</emphasis>
root[] <emphasis role="bold">gPad-&gt;SetLogx()</emphasis>
root[] <emphasis role="bold">MyCanvas-&gt;cd(3)</emphasis>
root[] <emphasis role="bold">gPad-&gt;SetLogx()</emphasis>
</programlisting>

</sect2>

<sect2>
<title>WaitPrimitive method</title>
<para>When the
<emphasis role="bold"><code>TPad</code></emphasis><code>::WaitPrimitive()</code>
method is called with no arguments, it will wait until a double click or any key
pressed is executed in the canvas. A call to <code>gSystem-&gt;Sleep(10)</code>
has been added in the loop to avoid consuming at all the CPU. This new option is
convenient when executing a macro. By adding statements like:</para>

<programlisting language="c++">canvas-&gt;WaitPrimitive();
</programlisting>

<para>You can monitor the progress of a running macro, stop it at convenient
places with the possibility to interact with the canvas and resume the execution
with a double click or a key press.</para>
</sect2>

<sect2>
<title>Locking the Pad</title>
<para>You can make the <emphasis role="bold"><code>TPad</code></emphasis>
non-editable. Then no new objects can be added, and the existing objects and the
pad can not be changed with the mouse or programmatically. By default the
<emphasis role="bold"><code>TPad</code></emphasis> is editable.</para>

<programlisting language="c++">TPad::SetEditable(kFALSE)
</programlisting>

</sect2>
</sect1>

<sect1>
<title>Graphical Objects</title>
<para>In this paragraph, we describe the various simple 2D graphical objects
defined in ROOT. Usually, one defines these objects with their constructor and
draws them with their <code>Draw()</code> method. Therefore, the examples will
be very brief. Most graphical objects have line and fill attributes (color,
width) that will be described in “Graphical objects attributes”. If the user
wants more information, the class names are given and he may refer to the online
developer documentation. This is especially true for functions and methods that
set and get internal values of the objects described here. By default 2D
graphical objects are created in User Coordinates with (0, 0) in the lower left
corner.</para>

<sect2>
<title>Lines, Arrows and Polylines</title>
<para>The simplest graphical object is a line. It is implemented in the
<emphasis role="bold"><code>TLine</code></emphasis> class. The line constructor
is:</para>

<programlisting language="c++">TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2)
</programlisting>

<para>The arguments <code>x1</code>, <code>y1</code>, <code>x2</code>,
<code>y2</code> are the coordinates of the first and second point. It can be
used:</para>

<programlisting language="c++">root[] <emphasis role="bold">l = new TLine(0.2,0.2,0.8,0.3)</emphasis>
root[] <emphasis role="bold">l-&gt;Draw()</emphasis>
</programlisting>

<para>The arrow constructor is:</para>

<programlisting language="c++">TArrow(Double_t x1, Double_t y1,
       Double_t x2, Double_t y2,
       Float_t arrowsize, Option_t *option)
</programlisting>

<para>It defines an arrow between points <code>x1,y1</code> and
<code>x2,y2</code>. The arrow size is in percentage of the pad height. The
<code>option</code> parameter has the following meanings:</para>

<informaltable frame="none">
<tgroup cols="4">
<colspec colwidth="1321*" colname="column-1" colsep="0"/>
<colspec colwidth="3052*" colname="column-2" colsep="0"/>
<colspec colwidth="1216*" colname="column-3" colsep="0"/>
<colspec colwidth="3434*" colname="column-4" colsep="0"/>
<tbody>
<row rowsep="0">
<entry>
<para>"&gt;"</para>
</entry>
<entry>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000A7.jpg" width="93.1pt" depth="16.75pt"/></imageobject></inlinemediaobject>
</para>
</entry>
<entry>
<para>"&lt;|"</para>
</entry>
<entry>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000A8.jpg" width="76.95pt" depth="16.75pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row rowsep="0">
<entry>
<para>"&lt;"</para>
</entry>
<entry>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000A9.jpg" width="88.15pt" depth="16.75pt"/></imageobject></inlinemediaobject>
</para>
</entry>
<entry>
<para>"|&gt;"</para>
</entry>
<entry>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000AA.jpg" width="75.7pt" depth="16.75pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row rowsep="0">
<entry>
<para>"&lt;&gt;"</para>
</entry>
<entry>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000AB.jpg" width="88.15pt" depth="16.75pt"/></imageobject></inlinemediaobject>
</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
</row>
<row rowsep="0">
<entry>
<para>"&lt;|&gt;"</para>
</entry>
<entry>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000AC.jpg" width="88.15pt" depth="16.75pt"/></imageobject></inlinemediaobject>
</para>
</entry>
<entry>
<para/>
</entry>
<entry>
<para/>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>Once an arrow is drawn on the screen, one can:</para>
<itemizedlist>
<listitem><para>
click on one of the edges and move this edge.
</para></listitem>
<listitem><para>
click on any other arrow part to move the entire arrow.
</para></listitem>
</itemizedlist>

<figure><title>Different arrow formats</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000AD.png" width="2in" depth="119.15pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>If <code>FillColor</code> is 0, an open triangle is drawn; else a full
triangle is filled with the set fill color. If <code>ar</code> is an arrow
object, fill color is set with:</para>

<programlisting language="c++">ar.SetFillColor(icolor);
</programlisting>

<para>Where <code>icolor</code> is the color defined in
“Color and Color Palettes”.</para>
<para>The default-opening angle between the two sides of the arrow is 60
degrees. It can be changed with the method <code>ar–&gt;SetAngle(angle)</code>,
where angle is expressed in degrees.</para>
<para>A poly-line is a set of joint segments. It is defined by a set of N points
in a 2D space. Its constructor is:</para>

<programlisting language="c++">TPolyLine(Int_t n,Double_t* x,Double_t* y,Option_t* option)
</programlisting>

<para>Where <code>n</code> is the number of points, and <code>x</code> and
<code>y</code> are arrays of <code>n</code> elements with the coordinates of the
points. <emphasis role="bold"><code>TPolyLine</code></emphasis> can be used by
it self, but is also a base class for other objects, such as curly arcs.</para>
</sect2>

<sect2>
<title>Circles and Ellipses</title>
<para>An ellipse can be truncated and rotated. It is defined by its center
<code>(x1,y1)</code> and two radii <code>r1</code> and <code>r2</code>. A
minimum and maximum angle may be specified <code>(phimin,phimax)</code>. The
ellipse may be rotated with an angle <code>theta</code>. All these angles are in
degrees. The attributes of the outline line are set via
<emphasis role="bold"><code>TAttLine</code></emphasis>, of the fill area – via
<emphasis role="bold"><code>TAttFill</code></emphasis> class. They are described
in “Graphical Objects Attributes”.</para>

<figure><title>Different types of ellipses</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000AE.png" width="151.45pt" depth="90pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>When an ellipse sector is drawn only, the lines between the center and the
end points of the sector are drawn by default. By specifying the drawn option
“<code>only</code>”, these lines can be avoided. Alternatively, the method
<code>SetNoEdges()</code> can be called. To remove completely the ellipse
outline, specify zero (0) as a line style.</para>
<para>The <emphasis role="bold"><code>TEllipse</code></emphasis> constructor is:</para>

<programlisting language="c++">TEllipse(Double_t x1, Double_t y1, Double_t r1, Double_t r2,
         Double_t phimin, Double_t phimax, Double_t theta)
</programlisting>

<para>An ellipse may be created with:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>e = new TEllipse(0.2,0.2,0.8,0.3)</code></emphasis>
root[] <emphasis role="bold"><code>e-&gt;Draw()</code></emphasis>
</programlisting>

</sect2>

<sect2>
<title>Rectangles</title>
<para>The class <emphasis role="bold"><code>TBox</code></emphasis> defines a
rectangle. It is a base class for many different higher-level graphical
primitives. Its bottom left coordinates <code>x1</code>, <code>y1</code> and its
top right coordinates <code>x2</code>, <code>y2</code>, defines a box. The
constructor is:</para>

<programlisting language="c++">TBox(Double_t x1,Double_t y1,Double_t x2,Double_t y2)
</programlisting>

<para>It may be used as in:</para>

<programlisting language="c++">root[] <emphasis role="bold">b = new TBox(0.2,0.2,0.8,0.3)</emphasis>
root[] <emphasis role="bold">b-&gt;SetFillColor(5)</emphasis>
root[] <emphasis role="bold">b-&gt;Draw()</emphasis>
</programlisting>

<figure><title>A rectangle with a border</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000AF.jpg" width="90.6pt" depth="66.4pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>A <emphasis role="bold"><code>TWbox</code></emphasis> is a rectangle
(<emphasis role="bold"><code>TBox</code></emphasis>) with a border size and a
border mode. The attributes of the outline line and of the fill area are
described in “Graphical Objects Attributes”</para>
</sect2>

<sect2>
<title>Markers</title>
<para>A marker is a point with a fancy shape! The possible markers are shown in
the next figure.</para>

<figure><title>Markers</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000B0.png" width="307.85pt" depth="88.15pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para/>
<para>The marker constructor is:</para>

<programlisting language="c++">TMarker(Double_t x,Double_t y,Int_t marker)
</programlisting>

<para>The parameters <code>x</code> and <code>y</code> are the marker
coordinates and <code>marker</code> is the marker type, shown in the previous
figure. Suppose the pointer <code>ma</code> is a valid marker. The marker size
is set via <code>ma-&gt;SetMarkerSize(size)</code>, where <code>size</code> is
the desired size. Note, that the marker types 1, 6 and 7 (the dots) cannot be
scaled. They are always drawn with the same number of pixels.
<code>SetMarkerSize</code> does not apply on them. To have a "scalable dot" a
circle shape should be used instead, for example, the marker type 20. The
default marker type is 1, if <code>SetMarkerStyle</code> is not specified. It is
the most common one to draw scatter plots.</para>

<figure><title>Different marker sizes</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000B1.png" width="199.25pt" depth="60.2pt"/></imageobject></inlinemediaobject>
</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000B2.png" width="100.05pt" depth="30.8pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The user interface for changing the marker color, style and size looks
like shown in this picture. It takes place in the editor frame anytime the
selected object inherits the class
<emphasis role="bold"><code>TAttMarker</code></emphasis>.</para>
<para>Non-symmetric symbols should be used carefully in plotting. The next two
graphs show how the misleading a careless use of symbols can be. The two plots
represent the same data sets but because of a bad symbol choice, the two on the
top appear further apart from the next example.</para>

<figure><title>The use of non-symmetric markers</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000B3.png" width="262.55pt" depth="194.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>A <emphasis role="bold"><code>TPolyMaker</code></emphasis> is defined by
an array on N points in a 2D space. At each point <code>x[i]</code>,
<code>y[i]</code> a marker is drawn. The list of marker types is shown in the
previous paragraph. The marker attributes are managed by the class
<emphasis role="bold"><code>TAttMarker</code></emphasis> and are described in
“Graphical Objects Attributes”. The
<emphasis role="bold"><code>TPolyMarker</code></emphasis> constructor is:</para>

<programlisting language="c++">TPolyMarker(Int_t n,Double_t *x,Double_t *y,Option_t *option)
</programlisting>

<para>Where <code>x</code> and <code>y</code> are arrays of coordinates for the
<code>n</code> points that form the poly-marker.</para>
</sect2>

<sect2>
<title>Curly and Wavy Lines for Feynman Diagrams</title>
<para>This is a peculiarity of particle physics, but we do need sometimes to
draw Feynman diagrams. Our friends working in banking can skip this part. A set
of classes implements curly or wavy poly-lines typically used to draw Feynman
diagrams. Amplitudes and wavelengths may be specified in the constructors, via
commands or interactively from context menus. These classes are
<emphasis role="bold"><code>TCurlyLine</code></emphasis> and
<emphasis role="bold"><code>TCurlyArc</code></emphasis>. These classes make use
of <emphasis role="bold"><code>TPolyLine</code></emphasis> by inheritance;
<code>ExecuteEvent</code> methods are highly inspired from the methods used in
<emphasis role="bold"><code>TPolyLine</code></emphasis> and
<emphasis role="bold"><code>TArc</code></emphasis>.</para>

<figure><title>The picture generated by the tutorial macro feynman.C</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000B4.png" width="243.95pt" depth="96.2pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The <emphasis role="bold"><code>TCurlyLine</code></emphasis> constructor is:</para>

<programlisting language="c++">TCurlyLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2,
           Double_t wavelength, Double_t amplitude)
</programlisting>

<para>The coordinates <code>(x1</code>, <code>y1)</code> define the starting
point, <code>(x2</code>, <code>y2)</code> – the end-point. The
<code>wavelength</code> and the <code>amplitude</code> are given in percent of
the pad height.</para>
<para>The <emphasis role="bold"><code>TCurlyArc</code></emphasis> constructor
is:</para>

<programlisting language="c++">TCurlyArc(Double_t x1, Double_t y1, Double_t rad,
          Double_t phimin, Double_t phimax,
          Double_t wavelength, Double_t amplitude)
</programlisting>

<para>The curly arc center is <code>(x1</code>, <code>y1)</code> and the radius
is <code>rad</code>. The wavelength and the amplitude are given in percent of
the line length. The parameters <code>phimin</code> and <code>phimax</code> are
the starting and ending angle of the arc (given in degrees). Refer to
<code>$ROOTSYS/tutorials/graphics/feynman.C</code> for the script that built the
figure above.</para>
</sect2>

<sect2>
<title>Text and Latex Mathematical Expressions</title>
<para>Text displayed in a pad may be embedded into boxes, called paves
(<emphasis role="bold"><code>TPaveLabel</code></emphasis>), or titles of graphs
or many other objects but it can live a life of its own. All text displayed in
ROOT graphics is an object of class
<emphasis role="bold"><code>TText</code></emphasis>. For a physicist, it will be
most of the time a <emphasis role="bold"><code>TLatex</code></emphasis>
expression (which derives from
<emphasis role="bold"><code>TText</code></emphasis>).
<emphasis role="bold"><code>TLatex</code></emphasis> has been conceived to draw
mathematical formulas or equations. Its syntax is very similar to the Latex in
mathematical mode.</para>

<sect3>
<title>Subscripts and Superscripts</title>
<para>Subscripts and superscripts are made with the <code>_</code> and
<code>^</code> commands. These commands can be combined to make complex
subscript and superscript expressions. You may choose how to display subscripts
and superscripts using the 2 functions <code>SetIndiceSize(Double_t)</code> and
<code>SetLimitIndiceSize(Int_t)</code>. Examples of what can be obtained using
subscripts and superscripts:</para>

<informaltable frame="all">
<tgroup cols="6">
<colspec colwidth="1537*" colname="column-1"/>
<colspec colwidth="753*" colname="column-2"/>
<colspec colwidth="1627*" colname="column-3"/>
<colspec colwidth="713*" colname="column-4"/>
<colspec colwidth="1683*" colname="column-5"/>
<colspec colwidth="837*" colname="column-6"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>The expression</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Gives</para>
</entry>
<entry rowsep="1" colsep="1">
<para>The expression</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Gives</para>
</entry>
<entry rowsep="1" colsep="1">
<para>The expression</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Gives</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<emphasis role="bold"><code>x^{2y}</code></emphasis>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlineequation>
  <mml:math>
    <mml:msup>
      <mml:mi>x</mml:mi>
      <mml:mn>2y</mml:mn>
    </mml:msup>
  </mml:math>
</inlineequation>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<emphasis role="bold"><code>x^{y^{2}}</code></emphasis>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
  <inlineequation>
    <mml:math>
      <mml:msup>
      <mml:msup>
        <mml:mi>x</mml:mi>
        <mml:mi>y</mml:mi>
      </mml:msup>
       <mml:mn>2</mml:mn>
      </mml:msup>
    </mml:math>
  </inlineequation>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<emphasis role="bold"><code>x_{1}^{y_{1}}</code></emphasis>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
  <inlineequation>
    <mml:math>
      <mml:msup>
          <mml:msub>
            <mml:mi>x</mml:mi>
            <mml:mn>1</mml:mn>
          </mml:msub>
        <mml:msub>
        <mml:mi>y</mml:mi>
        <mml:mn>1</mml:mn>
        </mml:msub>
      </mml:msup>
    </mml:math>
  </inlineequation>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<emphasis role="bold"><code>x_{2y}</code></emphasis>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
  <inlineequation>
    <mml:math>
      <mml:msub>
        <mml:mi>x</mml:mi>
        <mml:mn>2y</mml:mn>
      </mml:msub>
    </mml:math>
  </inlineequation>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<emphasis role="bold"><code>x^{y_{1}}</code></emphasis>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
  <inlineequation>
    <mml:math>
      <mml:msup>
          <mml:mi>x</mml:mi>
        <mml:msub>
          <mml:mi>y</mml:mi>
        <mml:mn>1</mml:mn>
        </mml:msub>
      </mml:msup>
    </mml:math>
  </inlineequation>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<emphasis role="bold"><code>x_{1}^{y}</code></emphasis>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
  <inlineequation>
    <mml:math>
      <mml:msup>
        <mml:msub>
        <mml:mi>x</mml:mi>
          <mml:mn>1</mml:mn>
        </mml:msub>
          <mml:mi>y</mml:mi>
      </mml:msup>
    </mml:math>
  </inlineequation>
</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect3>

<sect3>
<title>Fractions</title>
<para>Fractions denoted by the / symbol are made in the obvious way. The
<code>#frac</code> command is used for large fractions in displayed formula; it
has two arguments: the numerator and the denominator. For example, the equation
<inlineequation>
            <mml:math>
              <mml:mrow>
                <mml:mi>x</mml:mi>
                <mml:mo>=</mml:mo>
              </mml:mrow>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mi>y</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>z</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>2</mml:mn>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mrow>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>y</mml:mi>
                    <mml:mn>2</mml:mn>
                  </mml:msup>
                  <mml:mo>+</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
              </mml:mfrac>
            </mml:math>
</inlineequation>
is obtained by following expression <code>x=#frac{y+z/2}{y^{2}+1}</code>.</para>
</sect3>

<sect3>
<title>Roots</title>
<para>The <code>#sqrt</code> command produces the square ROOT of its argument;
it has an optional first argument for other roots.</para>
<para>Example: <code>#sqrt{10}  #sqrt[3]{10}</code>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000BC.png" width="48.3pt" depth="22.65pt"/></imageobject></inlinemediaobject>
</para>
</sect3>

<sect3>
<title>Delimiters</title>
<para>You can produce three kinds of proportional delimiters.</para>
<para><code>#[]{....}</code> or "à la" Latex</para>
<para><code>#left[.....#right] </code>big square brackets</para>
<para><code>#{}{....} or #left{.....#right}</code>big curly brackets</para>
<para><code>#||{....} or #left|.....#right|</code>big absolute value symbol</para>
<para><code>#(){....} or#left(.....#right)</code>big parenthesis</para>
</sect3>

<sect3>
<title>Changing Style in Math Mode</title>
<para>You can change the font and the text color at any moment using:</para>
<para><code>#font[font-number]{...}</code> and
<code>#color[color-number]{...}</code></para>
</sect3>

<sect3>
<title>Line Splitting</title>
<para>A <emphasis role="bold"><code>TLatex</code></emphasis> string may be split
in two with the following command: <code>#splitline{top}{bottom}</code>.
<emphasis role="bold"><code>TAxis</code></emphasis> and
<emphasis role="bold"><code>TGaxis</code></emphasis> objects can take advantage
of this feature. For example, the date and time could be shown in the time axis
over two lines with: <code>#splitline{21 April 2003}{14:23:56}</code></para>
</sect3>
</sect2>

<sect2>
<title>Greek Letters</title>
<para>The command to produce a lowercase Greek letter is obtained by adding
<code>#</code> to the name of the letter. For an uppercase Greek letter, just
capitalize the first letter of the command name.</para>

<programlisting language="c++">#alpha     #beta    #chi      #delta     #varepsilon  #phi
#gamma     #eta     #iota     #varphi    #kappa       #lambda
#mu        #nu      #omicron  #pi        #theta       #rho 
#sigma     #tau     #upsilon  #varomega  #omega       #xi
#psi       #zeta    #Alpha    #Beta      #Chi         #Delta
#Epsilon   #Phi     #Gamma    #Eta       #Iota        #Kappa
#vartheta  #Lambda  #Mu       #Nu        #Omicron     #Pi
#Theta     #Rho     #Sigma    #Tau       #Upsilon     #Omega
#varsigma  #Xi      #Psi      #epsilon   #varUpsilon  #Zeta
</programlisting>

<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030000BD.png" width="3in" depth="244.55pt"/></imageobject></inlinemediaobject></para>
</sect2>

<sect2>
<title>Mathematical Symbols</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000BE.png" width="217.25pt" depth="208.55pt"/></imageobject></inlinemediaobject>
</para>
<para><emphasis role="bold"><code>TLatex</code></emphasis> can make mathematical
and other symbols. A few of them, such as <code>+</code> and <code>&gt;</code>,
are produced by typing the corresponding keyboard character. Others are obtained
with the commands as shown in the table above.</para>

<sect3>
<title>Accents, Arrows and Bars</title>
<para>Symbols in a formula are sometimes placed one above another.
<emphasis role="bold"><code>TLatex</code></emphasis> provides special commands for that.</para>
<para><code>#hat{a} = </code>hat</para>
<para><code>#check  = </code>inverted hat</para>
<para><code>#acute  = </code>acute</para>
<para><code>#grave  = </code>accent grave</para>
<para><code>#dot    = </code>derivative</para>
<para><code>#ddot   = </code>double derivative</para>
<para><code>#tilde  = </code>tilde</para>
<para><code>#slash  = </code>special sign. Draw a slash on top of the text between brackets for example</para>
<para><code>#slash{E}_{T} </code>generates "Missing ET"</para>
<para>
  <inlineequation>
    <mml:math>
      <mml:mover>
        <mml:mi>a</mml:mi>
        <mml:mn>‾</mml:mn>
      </mml:mover>
    </mml:math>
  </inlineequation>
is obtained with <code>#bar{a}</code></para>
<para> 
  <inlineequation>
    <mml:math>
      <mml:mover>
        <mml:mi>a</mml:mi>
        <mml:mn>→</mml:mn>
      </mml:mover>
    </mml:math>
  </inlineequation>
  is obtained with <code>#vec{a}</code>
</para>
 
</sect3>

<sect3>
<title>Example 1</title>
<para>The script <code>$ROOTSYS/tutorials/graphics/latex.C:</code></para>

<programlisting language="c++">{
  TCanvas c1("c1","Latex",600,700);
  TLatex l;
  l.SetTextAlign(12);
  l.SetTextSize(0.04);

  l.DrawLatex(0.1,0.8,"1) C(x) = d #sqrt{#frac{2}{#lambdaD}}
  #int^{x}_{0}cos(#frac{#pi}{2}t^{2})dt");
  l.DrawLatex(0.1,0.6,"2) C(x) = d #sqrt{#frac{2}{#lambdaD}}
  #int^{x}cos(#frac{#pi}{2}t^{2})dt");
  l.DrawLatex(0.1,0.4,"3) R = |A|^{2} =
  #frac{1}{2}(#[]{#frac{1}{2}+C(V)}^{2}+
  #[]{#frac{1}{2}+S(V)}^{2})");
  l.DrawLatex(0.1,0.2,"4) F(t) = #sum_{i=
  -#infty}^{#infty}A(i)cos#[]{#frac{i}{t+i}}");
}
</programlisting>

<figure><title>The picture generated by the tutorial macro latex.C</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000C1.jpg" width="278.05pt" depth="234pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Example 2</title>
<para>The script <code>$ROOTSYS/tutorials/graphics/latex2.C:</code></para>

<programlisting language="c++">{
  TCanvas c1("c1","Latex",600,700);
  TLatex l;
  l.SetTextAlign(23);
  l.SetTextSize(0.1);
  l.DrawLatex(0.5,0.95,"e^{+}e^{-}#rightarrowZ^{0}
  #rightarrowI#bar{I}, q#bar{q}");
  l.DrawLatex(0.5,0.75,"|#vec{a}#bullet#vec{b}|=
  #Sigmaa^{i}_{jk}+b^{bj}_{i}");
  l.DrawLatex(0.5,0.5,"i(#partial_{#mu}#bar{#psi}#gamma^{#mu}
  +m#bar{#psi}=0
  #Leftrightarrow(#Box+m^{2})#psi=0");
  l.DrawLatex(0.5,0.3,"L_{em}=eJ^{#mu}_{em}A_{#mu} ,
  J^{#mu}_{em}=#bar{I}#gamma_{#mu}I
  M^{j}_{i}=#SigmaA_{#alpha}#tau^{#alphaj}_{i}");
}
</programlisting>

<figure><title>The picture generated by the tutorial macro latex2.C</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000C2.jpg" width="217.25pt" depth="116.05pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Example 3</title>
<para>The script <code>$ROOTSYS/tutorials/graphics/latex3.C</code>:</para>

<programlisting language="c++">{
  TCanvas c1("c1");
  TPaveText pt(.1,.5,.9,.9);
  pt.AddText("#frac{2s}{#pi#alpha^{2}}
  #frac{d#sigma}{dcos#theta} (e^{+}e^{-}
  #rightarrow f#bar{f} ) = ");
  pt.AddText("#left| #frac{1}{1 - #Delta#alpha} #right|^{2}
  (1+cos^{2}#theta");
  pt.AddText("+ 4 Re #left{ #frac{2}{1 - #Delta#alpha} #chi(s)
  #[]{#hat{g}_{#nu}^{e}#hat{g}_{#nu}^{f}
  (1 + cos^{2}#theta) + 2 #hat{g}_{a}^{e}
  #hat{g}_{a}^{f} cos#theta) } #right}");
  pt.SetLabel("Born equation");
  pt.Draw();
}
</programlisting>

<figure><title>The picture generated by the tutorial macro latex3.C</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000C3.jpg" width="253.25pt" depth="126pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>
</sect2>

<sect2>
<title>Text in a Pad</title>
<para>Text displayed in a pad may be embedded into boxes, called paves, or may
be drawn alone. In any case, it is recommended to use a Latex expression, which
is covered in the previous paragraph. Using
<emphasis role="bold"><code>TLatex</code></emphasis> is valid whether the text
is embedded or not. In fact, you will use Latex expressions without knowing it
since it is the standard for all the embedded text. A pave is just a box with a
border size and a shadow option. The options common to all types of paves and
used when building those objects are the following:</para>
<para><code>option = "T"</code> top frame</para>
<para><code>option = "B"</code> bottom frame</para>
<para><code>option = "R"</code> right frame</para>
<para><code>option = "L"</code> left frame</para>
<para><code>option = "NDC" x1,y1,x2,y2</code> are given in NDC</para>
<para><code>option = "ARC"</code> corners are rounded</para>
<para>We will see the practical use of these options in the description of the
more functional objects like
<emphasis role="bold"><code>TPaveLabel</code></emphasis><code>s</code>. There
are several categories of paves containing text:
<emphasis role="bold"><code>TPaveLabel</code></emphasis>,
<emphasis role="bold"><code>TPaveText</code></emphasis> and
<emphasis role="bold"><code>TPavesText</code></emphasis>.
<emphasis role="bold"><code>TPaveLabel</code></emphasis><code>s</code> are
panels containing one line of text. They are used for labeling.</para>

<programlisting language="c++">TPaveLabel(Double_t x1, Double_t y1, Double_t x2, Double_t y2,
           const char *label, Option_t *option)
</programlisting>

<para>Where (<code>x1</code>, <code>y1</code>) are the coordinates of the bottom
left corner, <code>(x2,y2)</code> - coordinates of the upper right corner.
“<code>label</code>” is the text to be displayed and “<code>option</code>” is
the drawing option, described above. By default, the border size is 5 and the
option is “<code>br</code>”. If one wants to set the border size to some other
value, one may use the method <code>SetBorderSize()</code>. For example, suppose
we have a histogram, which limits are (-100,100) in the x direction and
(0, 1000) in the y direction. The following lines will draw a label in the
center of the histogram, with no border. If one wants the label position to be
independent of the histogram coordinates, or user coordinates, one can use the
option “<code>NDC</code>”. See “The Coordinate Systems of a Pad”.</para>

<programlisting language="c++">root[] <emphasis role="bold">pl = new TPaveLabel(-50,0,50,200,”Some text”)</emphasis>
root[] <emphasis role="bold">pl-&gt;SetBorderSize(0)</emphasis>
root[] <emphasis role="bold">pl-&gt;Draw()</emphasis>
</programlisting>

<figure><title><code>PaveLabels</code> drawn with different options</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060000C4.png" width="229.05pt" depth="54pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>A <emphasis role="bold"><code>TPaveLabel</code></emphasis> can contain
only one line of text. A <emphasis role="bold"><code>TPaveText</code></emphasis>
may contain several lines. This is the only difference. This picture illustrates
and explains some of the points of
<emphasis role="bold"><code>TPaveText</code></emphasis>. Once a
<emphasis role="bold"><code>TPaveText</code></emphasis> is drawn, a line can be
added or removed by brining up the context menu with the mouse.</para>

<figure><title>PaveText examples</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000C5.png" width="275.6pt" depth="256.35pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>A <emphasis role="bold"><code>TPavesText</code></emphasis> is a stack of
text panels (see <emphasis role="bold"><code>TPaveText</code></emphasis>). One
can set the number of stacked panels at building time. It has the following
constructor: By default, the number of stacked panels is 5,
<code>option=</code>”<code>br</code>”.</para>

<programlisting language="c++">TPavesText(Double_t x1,Double_t y1,Double_t x2,Double_t y2,Int_t npaves,
Option_t* option)
</programlisting>

<figure><title>A PaveText example</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000C6.png" width="126.6pt" depth="57.7pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect2>
</sect1>

<sect1>
<title>Axis</title>
<para>The axis objects are automatically built by various high level objects
such as histograms or graphs. Once build, one may access them and change their
characteristics. It is also possible, for some particular purposes to build axis
on their own. This may be useful for example in the case one wants to draw two
axis for the same plot, one on the left and one on the right.</para>
<para>For historical reasons, there are two classes representing axis.
<emphasis role="bold"><code>TAxis</code></emphasis> * <code>axis</code> is the
axis object, which will be returned when calling the
<emphasis role="bold"><code>TH1</code></emphasis><code>::GetAxis()</code>
method.</para>

<programlisting language="c++">TAxis *axis = histo-&gt;GetXaxis()
</programlisting>

<para>Of course, you may do the same for <code>Y</code> and <code>Z</code>-axis.
The graphical representation of an axis is done with the
<emphasis role="bold"><code>TGaxis</code></emphasis> class. The histogram
classes and <emphasis role="bold"><code>TGraph</code></emphasis> generate
instances of this class. This is internal and the user should not have to see
it.</para>

<sect2>
<title>Axis Title</title>
<para>The axis title is set, as with all named objects, by</para>

<programlisting language="c++">axis-&gt;SetTitle("Whatever title you want");
</programlisting>

<para>When the axis is embedded into a histogram or a graph, one has to first
extract the axis object:</para>

<programlisting language="c++">h-&gt;GetXaxis()-&gt;SetTitle("Whatever title you want")
</programlisting>

</sect2>

<sect2>
<title>Axis Options and Characteristics</title>
<para>The axis options are most simply set with the styles. The available style
options controlling specific axis options are the following:</para>

<programlisting language="c++">TAxis *axis = histo-&gt;GetXaxis();
axis-&gt;SetAxisColor(Color_t color = 1);
axis-&gt;SetLabelColor(Color_t color = 1);
axis-&gt;SetLabelFont(Style_t font = 62);
axis-&gt;SetLabelOffset(Float_t offset = 0.005);
axis-&gt;SetLabelSize(Float_t size = 0.04);
axis-&gt;SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);
axis-&gt;SetNoExponent(Bool_t noExponent = kTRUE);
axis-&gt;SetTickLength(Float_t length = 0.03);
axis-&gt;SetTitleOffset(Float_t offset = 1);
axis-&gt;SetTitleSize(Float_t size = 0.02);
</programlisting>

<para>The getters corresponding to the described setters are also available. The
general options, not specific to axis, as for instance
<code>SetTitleTextColor()</code> are valid and do have an effect on axis
characteristics.</para>
</sect2>

<sect2>
<title>Setting the Number of Divisions</title>
<para>Use
<emphasis role="bold"><code>TAxis</code></emphasis><code>::SetNdivisions(ndiv,optim)</code>
to set the number of divisions for an axis. The <code>ndiv</code> and
<code>optim</code> are as follows:</para>

<itemizedlist>
<listitem><para><code>ndiv = N1 + 100*N2 + 10000*N3</code></para></listitem>
<listitem><para><code>N1 =</code> number of first divisions.</para></listitem>
<listitem><para><code>N2 =</code> number of secondary divisions.</para></listitem>
<listitem><para><code>N3 =</code> number of tertiary divisions.</para></listitem>
<listitem><para><code>optim = kTRUE </code> (default), the divisions’ number
will be optimized around the specified value.</para></listitem>
<listitem><para><code>optim = kFALSE, </code> or n &lt; 0, the axis will be
forced to use exactly n divisions.</para></listitem>
</itemizedlist>

<para>For example:</para>
<para><code>ndiv = 0</code>: no tick marks.</para>
<para><code>ndiv = 2</code>: 2 divisions, one tick mark in the middle of the
axis.</para>
<para><code>ndiv = 510</code>: 10 primary divisions, 5 secondary divisions</para>
<para><code>ndiv = -10</code>: exactly 10 primary divisions</para>
</sect2>

<sect2>
<title>Zooming the Axis</title>
<para>You can use
<emphasis role="bold"><code>TAxis</code></emphasis><code>::SetRange</code> or
<emphasis role="bold"><code>TAxis</code></emphasis><code>::SetRangeUser</code>
to zoom the axis.</para>

<programlisting language="c++">TAxis::SetRange(Int_t binfirst,Int_t binlast)
</programlisting>

<para>The <code>SetRange</code> method parameters are bin numbers. They are not
axis. For example if a histogram plots the values from 0 to 500 and has 100
bins, <code>SetRange(0,10)</code> will cover the values 0 to 50. The parameters
for <code>SetRangeUser</code> are user coordinates. If the start or end is in
the middle of a bin the resulting range is approximation. It finds the low edge
bin for the start and the high edge bin for the high.</para>

<programlisting language="c++">TAxis::SetRangeUser(Axis_t ufirst,Axis_t ulast)
</programlisting>

<para>Both methods, <code>SetRange</code> and <code>SetRangeUser</code>, are in
the context menu of any axis and can be used interactively. In addition, you can
zoom an axis interactively: click on the axis on the start, drag the cursor to
the end, and release the mouse button.</para>
</sect2>

<sect2>
<title>Drawing Axis Independently of Graphs or Histograms</title>
<para>An axis may be drawn independently of a histogram or a graph. This may be
useful to draw for example a supplementary axis for a graph. In this case, one
has to use the <emphasis role="bold"><code>TGaxis</code></emphasis> class, the
graphical representation of an axis. One may use the standard constructor for
this kind of objects:</para>

<programlisting language="c++">TGaxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax,
       Double_t wmin, Double_t wmax, Int_t ndiv = 510,
       Option_t* chopt,Double_t gridlength = 0)
</programlisting>

<para>The arguments <code>xmin, ymin</code> are the coordinates of the axis'
start in the user coordinates system, <code>and xmax, ymax</code> are the end
coordinates. The arguments <code>wmin</code> and <code>wmax</code> are the
minimum (at the start) and maximum (at the end) values to be represented on
the axis; <code>ndiv</code> is the number of divisions. The options, given by
the “<code>chopt</code>” string are the following:</para>
<itemizedlist>
<listitem><para><code>chopt = 'G'</code>: logarithmic scale, default is linear.
</para></listitem>
<listitem><para><code>chopt = 'B'</code>: Blank axis (it is useful to superpose
the axis).</para></listitem>
</itemizedlist>
<para>Instead of the <code>wmin,wmax</code> arguments of the normal constructor,
i.e. the limits of the axis, the name of a
<emphasis role="bold"><code>TF1</code></emphasis> function can be specified.
This function will be used to map the user coordinates to the axis values and
ticks.</para>
<para>The constructor is the following:</para>

<programlisting language="c++">TGaxis(Double_t xmin,Double_t ymin,Double_t xmax,Double_t ymax,
const char* funcname,Int_t ndiv=510,Option_t* chopt,Double_t gridlength=0)
</programlisting>

<para>In such a way, it is possible to obtain exponential evolution of the tick
marks position, or even decreasing. In fact, anything you like.</para>
</sect2>

<sect2>
<title>Orientation of Tick Marks on Axis</title>
<para>Tick marks are normally drawn on the positive side of the axis, however,
if <code>xmin = xmax</code>, then negative.</para>
<itemizedlist>
<listitem><para><code>chopt = '+’: </code> tick marks are drawn on Positive
side. (Default)</para></listitem>
<listitem><para><code>chopt = '-’: </code> tick marks are drawn on the negative
side.</para></listitem>
<listitem><para><code>chopt = '+-’:</code> tick marks are drawn on both sides of
the axis.</para></listitem>
<listitem><para><code>chopt = ‘U’: </code> unlabeled axis, default is
labeled.</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>Labels</title>

<sect3>
<title>Position</title>
<para>Labels are normally drawn on side opposite to tick marks. However,
<code>chopt = '='</code>: on Equal side. The function
<emphasis role="bold"><code>TAxis</code></emphasis><code>::CenterLabels()</code>
sets the bit <code>kCenterLabels</code> and it is visible from
<emphasis role="bold"><code>TAxis</code></emphasis> context menu. It centers the
bin labels and it makes sense only when the number of bins is equal to the
number of tick marks. The class responsible for drawing the axis
<emphasis role="bold"><code>TGaxis</code></emphasis> inherits this
property.</para>
</sect3>

<sect3>
<title>Orientation</title>
<para>Labels are normally drawn parallel to the axis. However, if
<code>xmin = xmax</code>, then they are drawn orthogonal, and if
<code>ymin=ymax</code> they are drawn parallel.</para>
</sect3>

<sect3>
<title>Labels for Exponents</title>
<para>By default, an exponent of the form 10^N is used when the label values are
either all very small or very large. One can disable the exponent by
calling:</para>

<programlisting language="c++">TAxis::SetNoExponent(kTRUE)
</programlisting>

<para>Note that this option is implicitly selected if the number of digits to
draw a label is less than the <code>fgMaxDigits</code> global member. If the
property <code>SetNoExponent</code> was set in
<emphasis role="bold"><code>TAxis</code></emphasis> (via
<emphasis role="bold"><code>TAxis</code></emphasis><code>::SetNoExponent)</code>,
the <emphasis role="bold"><code>TGaxis</code></emphasis> will inherit this
property. <emphasis role="bold"><code>TGaxis</code></emphasis> is the class
responsible for drawing the axis. The method <code>SetNoExponent</code> is also
available from the axis context menu.</para>

<figure><title>Y-axis with and without exponent labels</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000C7.png" width="380.5pt" depth="225.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Number of Digits in Labels</title>
<para><emphasis role="bold"><code>TGaxis</code></emphasis><code>::fgMaxDigits</code>
is the maximum number of digits permitted for the axis labels above which the
notation with 10^N is used. It must be greater than 0. By default
<code>fgMaxDigits</code> is 5 and to change it use the
<emphasis role="bold"><code>TGaxis</code></emphasis><code>::SetMaxDigits</code>
method. For example to set <code>fgMaxDigits</code> to accept 6 digits and
accept numbers like 900000 on an axis call:</para>

<programlisting language="c++">TGaxis::SetMaxDigits(6)
</programlisting>

</sect3>

<sect3>
<title>Tick Mark Positions</title>
<para>Labels are centered on tick marks. However, if <code>xmin = xmax</code>,
then they are right adjusted.</para>
<itemizedlist>
<listitem><para><code>chopt = 'R'</code>: labels are right adjusted on tick mark
(default is centered)</para></listitem>
<listitem><para><code>chopt = 'L'</code>: labels are left adjusted on tick
mark.</para></listitem>
<listitem><para><code>chopt = 'C'</code>: labels are centered on tick
mark.</para></listitem>
<listitem><para><code>chopt = 'M'</code>: In the Middle of the
divisions.</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Label Formatting</title>
<para>Blank characters are stripped, and then the label is correctly aligned.
The dot, if last character of the string, is also stripped. In the following,
we have some parameters, like tick marks length and characters height (in
percentage of the length of the axis, in user coordinates). The default values
are as follows:</para>
<itemizedlist>
<listitem><para>Primary tick marks: 3.0 %</para></listitem>
<listitem><para>Secondary tick marks: 1.5 %</para></listitem>
<listitem><para>Third order tick marks: .75 %</para></listitem>
<listitem><para>Characters height for labels: 4%</para></listitem>
<listitem><para>Labels offset: 1.0 %</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Stripping Decimals</title>
<para>Use the
<emphasis role="bold"><code>TStyle</code></emphasis><code>::SetStripDecimals</code>
to strip decimals when drawing axis labels. By default, the option is set to
true, and
<emphasis role="bold"><code>TGaxis</code></emphasis><code>::PaintAxis</code>
removes trailing zeros after the dot in the axis labels, e.g.
{0, 0.5, 1, 1.5, 2, 2.5, etc.}</para>

<programlisting language="c++">TStyle::SetStripDecimals (Bool_t strip=kTRUE)
</programlisting>

<para>If this function is called with <code>strip=kFALSE</code>,
<emphasis role="bold"><code>TGaxis</code></emphasis><code>::PaintAxis()</code>
will draw labels with the same number of digits after the dot, e.g.
{0.0, 0.5, 1.0, 1.5, 2.0, 2.5, etc.}</para>
</sect3>

<sect3>
<title>Optional Grid</title>
<para><code>chopt = 'W'</code>: cross-Wire</para>
</sect3>

<sect3>
<title>Axis Binning Optimization</title>
<para>By default, the axis binning is optimized.</para>
<itemizedlist>
<listitem><para><code>chopt = 'N'</code>: No binning optimization</para></listitem>
<listitem><para><code>chopt = 'I'</code>: Integer labeling</para></listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2>
<title>Axis with Time Units</title>
<para>Histograms' axis can be defined as "time axis". To do that it is enough to
activate the <code>SetTimeDisplay</code> attribute on a given axis. If
<code>h</code> is a histogram, it is done the following way:</para>

<programlisting language="c++">h-&gt;GetXaxis()-&gt;SetTimeDisplay(1);    <emphasis role="italic"><code>// X axis is a time axis</code></emphasis>
</programlisting>

<para>Two parameters can be adjusted in order to define time axis: the time
format and the time offset.</para>

<sect3>
<title>Time Format</title>
<para>It defines the format of the labels along the time axis. It can be changed
using the <emphasis role="bold"><code>TAxis</code></emphasis> method
<code>SetTimeFormat</code>. The time format is the one used by the C function
<code>strftime()</code>. It is a string containing the following formatting
characters:</para>
<informaltable>
<tgroup cols="2">
<colspec colwidth="1440*" colname="column-1"/>
<colspec colwidth="5445*" colname="column-2"/>
<tbody>
<row>
<entry>
<para>For the date:</para>
<para/>
</entry>
<entry>
<para>%a abbreviated weekday name</para>
<para>%b abbreviated month name</para>
<para>%d day of the month (01-31)</para>
<para>%m month (01-12)</para>
<para>%y year without century</para>
<para>%Y year with century</para>
</entry>
</row>
<row>
<entry>
<para>For the time:</para>
<para/>
</entry>
<entry>
<para>%H hour (24-hour clock)</para>
<para>%I hour (12-hour clock)</para>
<para>%p local equivalent of AM or PM</para>
<para>%M minute (00-59)</para>
<para>%S seconds (00-61)</para>
<para>%% %</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>The other characters are output as is. For example to have a format like
<code>dd/mm/yyyy</code> one should do:</para>

<programlisting language="c++">h-&gt;GetXaxis()-&gt;SetTimeFormat("%d/%m/%Y");
</programlisting>

<para>If the time format is not defined, a default one will be computed
automatically.</para>
</sect3>

<sect3>
<title>Time Offset</title>
<para>This is a time in seconds in the UNIX standard UTC format (the universal
time, not the local one), defining the starting date of a histogram axis. This
date should be greater than 01/01/95 and is given in seconds. There are three
ways to define the time offset:</para>
<para>1. By setting the global default time offset:</para>

<programlisting language="c++">TDatime da(2003,02,28,12,00,00);
gStyle-&gt;SetTimeOffset(da.Convert());
</programlisting>

<para>If no time offset is defined for a particular axis, the default time
offset will be used. In the example above, notice the usage of
<emphasis role="bold"><code>TDatime</code></emphasis> to translate an explicit
date into the time in seconds required by <code>SetTimeFormat</code>.</para>
<para>2. By setting a time offset to a particular axis:</para>
<para/>

<programlisting language="c++">TDatime dh(2001,09,23,15,00,00);
h-&gt;GetXaxis()-&gt;SetTimeOffset(dh.Convert());
</programlisting>

<para>3. Together with the time format using <code>SetTimeFormat</code>. The
time offset can be specified using the control character %F after the normal
time format. <code>%F</code> is followed by the date in the format:
<code>yyyy-mm-dd hh:mm:ss</code>.</para>

<programlisting language="c++">h-&gt;GetXaxis()-&gt;SetTimeFormat("%d/%m/%y%F2000-02-28 13:00:01");
</programlisting>

<para>Notice that this date format is the same used by the
<emphasis role="bold"><code>TDatime</code></emphasis> function
<code>AsSQLString</code>. If needed, this function can be used to translate a
time in seconds into a character string which can be appended after
<code>%F</code>. If the time format is not specified (before <code>%F</code>)
the automatic one will be used. The following example illustrates the various
possibilities.</para>

<programlisting language="c++">{
  gStyle-&gt;SetTitleH(0.08);
  TDatime da(2003,02,28,12,00,00);
  gStyle-&gt;SetTimeOffset(da.Convert());
  ct = new TCanvas("ct","Time on axis",0,0,600,600);
  ct-&gt;Divide(1,3);
  ht1 = new TH1F("ht1","ht1",30000,0.,200000.);
  ht2 = new TH1F("ht2","ht2",30000,0.,200000.);
  ht3 = new TH1F("ht3","ht3",30000,0.,200000.);
  for (Int_t i=1;i&lt;30000;i++) {
    Float_t noise = gRandom-&gt;Gaus(0,120);
    ht1-&gt;SetBinContent(i,noise);
    ht2-&gt;SetBinContent(i,noise*noise);
    ht3-&gt;SetBinContent(i,noise*noise*noise);
  }
  ct-&gt;cd(1);
  ht1-&gt;GetXaxis()-&gt;SetLabelSize(0.06);
  ht1-&gt;GetXaxis()-&gt;SetTimeDisplay(1);
  ht1-&gt;GetXaxis()-&gt;SetTimeFormat("%d/%m/%y%F2000-02-2813:00:01");
  ht1-&gt;Draw();
  ct-&gt;cd(2);
  ht2-&gt;GetXaxis()-&gt;SetLabelSize(0.06);
  ht2-&gt;GetXaxis()-&gt;SetTimeDisplay(1);
  ht2-&gt;GetXaxis()-&gt;SetTimeFormat("%d/%m/%y");
  ht2-&gt;Draw();
  ct-&gt;cd(3);
  ht3-&gt;GetXaxis()-&gt;SetLabelSize(0.06);
  TDatime dh(2001,09,23,15,00,00);
  ht3-&gt;GetXaxis()-&gt;SetTimeDisplay(1);
  ht3-&gt;GetXaxis()-&gt;SetTimeOffset(dh.Convert());
  ht3-&gt;Draw();
}
</programlisting>

<para>The output is shown in the figure below. If a time axis has no specified
time offset, the global time offset will be stored in the axis data structure.
The histogram limits are in seconds. If <code>wmin</code> and <code>wmax</code>
are the histogram limits, the time axis will spread around the time offset value
from <code>TimeOffset+wmin</code> to <code>TimeOffset+wmax</code>. Until now all
examples had a lowest value equal to 0. The following example demonstrates how
to define the histogram limits relatively to the time offset value.</para>

<figure>
<title>Time axis examples</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000C8.png" width="211.05pt" depth="201.7pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<programlisting language="c++">{
<emphasis role="italic">  // Define the time offset as 2003, January 1st</emphasis>
  TDatime T0(2003,01,01,00,00,00);
  int X0 = T0.Convert();
  gStyle-&gt;SetTimeOffset(X0);

<emphasis role="italic">  // Define the lowest histogram limit as 2002,September 23rd</emphasis>
   TDatime T1(2002,09,23,00,00,00);
   int X1 = T1.Convert()-X0;

<emphasis role="italic">  // Define the highest histogram limit as 2003, March 7th</emphasis>
  TDatime T2(2003,03,07,00,00,00);
  int X2 = T2.Convert(1)-X0;

  TH1F * h1 = new TH1F("h1","test",100,X1,X2);

  TRandom r;
  for (Int_t i=0;i&lt;30000;i++) {
    Double_t noise = r.Gaus(0.5*(X1+X2),0.1*(X2-X1));
    h1-&gt;Fill(noise);
  }

  h1-&gt;GetXaxis()-&gt;SetTimeDisplay(1);
  h1-&gt;GetXaxis()-&gt;SetLabelSize(0.03);
  h1-&gt;GetXaxis()-&gt;SetTimeFormat("%Y/%m/%d");
  h1-&gt;Draw();
}
</programlisting>

<para>The output is shown in the next figure. Usually time axes are created
automatically via histograms, but one may also want to draw a time axis outside
a "histogram context". Therefore, it is useful to understand how
<emphasis role="bold"><code>TGaxis</code></emphasis> works for such axis. The
time offset can be defined using one of the three methods described before. The
time axis will spread around the time offset value. Actually, it will go from
<code>TimeOffset+wmin</code> to <code>TimeOffset+wmax</code> where
<code>wmin</code> and <code>wmax</code> are the minimum and maximum values
(in seconds) of the axis. Let us take again an example. Having defined
"2003, February 28 at 12h”, we would like to see the axis a day before and a
day after.</para>

<figure><title>A histogram with time axis X</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000C9.png" width="208.55pt" depth="173.8pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>A <emphasis role="bold"><code>TGaxis</code></emphasis> can be created the
following way (a day has 86400 seconds):</para>

<programlisting language="c++">TGaxis *axis = new TGaxis(x1,y1,x2,y2,-100000,150000,2405,"t");
</programlisting>

<para>the "<code>t</code>" option (in lower case) means it is a "time axis".
The axis goes form 100000 seconds before <code>TimeOffset</code> and 150000
seconds after. So the complete macro is:</para>

<programlisting language="c++">{
  c1 = new TCanvas("c1","Examples of TGaxis",10,10,700,500);
  c1-&gt;Range(-10,-1,10,1);
  TGaxis *axis = new TGaxis(-8,-0.6,8,-0.6,-100000,150000,2405,"t");
  axis-&gt;SetLabelSize(0.03);

  TDatime da(2003,02,28,12,00,00);
  axis-&gt;SetTimeOffset(da.Convert());
  axis-&gt;SetTimeFormat("%d/%m/%Y");
  axis-&gt;Draw();
}
</programlisting>

<para/>
<para>The time format is specified with:</para>

<programlisting language="c++">axis-&gt;SetTimeFormat("%d/%m/%Y");
</programlisting>

<para>The macro gives the following output:</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000CA.png" width="289.25pt" depth="32.3pt"/></imageobject></inlinemediaobject>
</para>
<para>Thanks to the <emphasis role="bold"><code>TLatex</code></emphasis>
directive <code>#splitline</code> it is possible to write the time labels on two
lines. In the previous example changing the <code>SetTimeFormat</code> line
by:</para>

<programlisting language="c++">axis-&gt;SetLabelOffset(0.02);
axis-&gt;SetTimeFormat("#splitline{%Y}{%d/%m}");
</programlisting>

<para>will produce the following axis:</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000CB.png" width="286.75pt" depth="27.95pt"/></imageobject></inlinemediaobject>
</para>
</sect3>
</sect2>

<sect2>
<title>Axis Examples</title>
<para>To illustrate what was said, we provide two scripts. The first one creates
the picture shown in the next figure.</para>

<figure><title>The first axis example</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000CC.png" width="235.25pt" depth="159.5pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The first script is:</para>

<programlisting language="c++">{
  c1 = new TCanvas("c1","Examples of Gaxis",10,10,700,500);
  c1-&gt;Range(-10,-1,10,1);

  TGaxis *axis1 = new TGaxis(-4.5,-0.2,5.5,-0.2,-6,8,510,"");
  axis1-&gt;SetName("axis1");
  axis1-&gt;Draw();
  TGaxis *axis2 = new TGaxis(4.5,0.2,5.5,0.2,0.001,10000,510,"G");
  axis2-&gt;SetName("axis2");
  axis2-&gt;Draw();

  TGaxis *axis3 = new TGaxis(-9,-0.8,-9,0.8,-8,8,50510,"");
  axis3-&gt;SetName("axis3");
  axis3-&gt;Draw();
  TGaxis *axis4 = new TGaxis(-7,-0.8,7,0.8,1,10000,50510,"G");
  axis4-&gt;SetName("axis4");
  axis4-&gt;Draw();

  TGaxis *axis5 = new TGaxis(-4.5,-6,5.5,-6,1.2,1.32,80506,"-+");
  axis5-&gt;SetName("axis5");
  axis5-&gt;SetLabelSize(0.03);
  axis5-&gt;SetTextFont(72);
  axis5-&gt;SetLabelOffset(0.025);
  axis5-&gt;Draw();

  TGaxis *axis6 = new TGaxis(-4.5,0.6,5.5,0.6,100,900,50510,"-");
  axis6-&gt;SetName("axis6");
  axis6-&gt;Draw();
  TGaxis *axis7 = new TGaxis(8,-0.8,8,0.8,0,9000,50510,"+L");
  axis7-&gt;SetName("axis7");
  axis7-&gt;SetLabelOffset(0.01);
  axis7-&gt;Draw();

<emphasis role="italic">  // one can make axis top-&gt;bottom. However because of a problem,</emphasis>
<emphasis role="italic">  // the two x values should not be equal</emphasis>
  TGaxis *axis8 = new TGaxis(6.5,0.8,6.499,-0.8,0,90,50510,"-");
  axis8-&gt;SetName("axis8");
  axis8-&gt;Draw();
}
</programlisting>

<figure><title>The second axis example</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000CD.png" width="253.85pt" depth="182.5pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The second example shows the use of the second form of the constructor,
with axis ticks position determined by a function
<emphasis role="bold"><code>TF1</code></emphasis>:</para>

<programlisting language="c++">void gaxis3a()
{
  gStyle-&gt;SetOptStat(0);

  TH2F *h2 = new TH2F("h","Axes",2,0,10,2,-2,2);
  h2-&gt;Draw();
  TF1 *f1=new TF1("f1","-x",-10,10);
  TGaxis *A1 = new TGaxis(0,2,10,2,"f1",510,"-");
  A1-&gt;SetTitle("axis with decreasing values");
  A1-&gt;Draw();

  TF1 *f2=new TF1("f2","exp(x)",0,2);
  TGaxis *A2 = new TGaxis(1,1,9,1,"f2");
  A2-&gt;SetTitle("exponential axis");
  A2-&gt;SetLabelSize(0.03);
  A2-&gt;SetTitleSize(0.03);
  A2-&gt;SetTitleOffset(1.2);
  A2-&gt;Draw();

  TF1 *f3=new TF1("f3","log10(x)",0,800);
  TGaxis *A3 = new TGaxis(2,-2,2,0,"f3",505);
  A3-&gt;SetTitle("logarithmic axis");
  A3-&gt;SetLabelSize(0.03);
  A3-&gt;SetTitleSize(0.03);
  A3-&gt;SetTitleOffset(1.2);
  A3-&gt;Draw();
}
</programlisting>

<figure><title>An axis example with time display</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000CE.png" width="280.55pt" depth="173.8pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para/>

<programlisting language="c++"><emphasis role="italic">// strip chart example</emphasis>
void seism() {

  TStopwatch sw; sw.Start();
<emphasis role="italic">  //set time offset</emphasis>
  TDatime dtime;
  gStyle-&gt;SetTimeOffset(dtime.Convert());
  TCanvas *c1 = new TCanvas("c1","Time on axis",10,10,1000,500);
  c1-&gt;SetFillColor(42);
  c1-&gt;SetFrameFillColor(33);
  c1-&gt;SetGrid();

  Float_t bintime = 1; 
  // one bin = 1 second. change it to set the time scale
  TH1F *ht = new TH1F("ht","The ROOT seism",10,0,10*bintime);
  Float_t signal = 1000;
  ht-&gt;SetMaximum(signal);
  ht-&gt;SetMinimum(-signal);
  ht-&gt;SetStats(0);
  ht-&gt;SetLineColor(2);
  ht-&gt;GetXaxis()-&gt;SetTimeDisplay(1);
  ht-&gt;GetYaxis()-&gt;SetNdivisions(520);
  ht-&gt;Draw();

  for (Int_t i=1;i&lt;2300;i++) {
<emphasis role="italic">    // Build a signal : noisy damped sine</emphasis>
    Float_t noise  = gRandom-&gt;Gaus(0,120);
    if (i &gt; 700) 
      noise += signal*sin((i-700.)*6.28/30)*exp((700.-i)/300.);
    ht-&gt;SetBinContent(i,noise);
    c1-&gt;Modified();
    c1-&gt;Update();
    gSystem-&gt;ProcessEvents(); 
    //canvas can be edited during the loop
   }
   printf("Real Time = %8.3fs,Cpu Time = %8.3fsn",sw.RealTime(),sw.CpuTime());
}
</programlisting>

<para/>
</sect2>
</sect1>

<sect1>
<title>Graphical Objects Attributes</title>

<sect2>
<title>Text Attributes</title>
<para>When a class contains text or derives from a text class, it needs to be
able to set text attributes like font type, size, and color. To do so, the class
inherits from the <emphasis role="bold"><code>TAttText</code></emphasis> class
(a secondary inheritance), which defines text attributes.
<emphasis role="bold"><code>TLatex</code></emphasis> and
<emphasis role="bold"><code>TText</code></emphasis> inherit from
<emphasis role="bold"><code>TAttText</code></emphasis>.</para>

<sect3>
<title>Setting Text Alignment</title>
<para>Text alignment may be set by a method call. What is said here applies to
all objects deriving from <emphasis role="bold"><code>TAttText</code></emphasis>,
and there are many. We will take an example that may be transposed to other types.
Suppose "<code>la</code>" is a <emphasis role="bold"><code>TLatex</code></emphasis>
object. The alignment is set with:</para>

<programlisting language="c++">root[] <emphasis role="bold">la-&gt;SetTextAlign(align)</emphasis>
</programlisting>

<para>The parameter <code>align</code> is a <code>short</code> describing the
alignment:</para>
<para>
<code>align  = 10*HorizontalAlign + VerticalAlign</code></para>
<para>For horizontal alignment, the following convention applies:</para>
<itemizedlist>
<listitem><para>1 = left</para></listitem>
<listitem><para>2 = centered</para></listitem>
<listitem><para>3 = right</para></listitem>
</itemizedlist>
<para>For vertical alignment, the following convention applies:</para>
<itemizedlist>
<listitem><para>1 = bottom</para></listitem>
<listitem><para>2 = centered</para></listitem>
<listitem><para>3 = top</para></listitem>
</itemizedlist>
<para>For example, align: 11 = left adjusted and bottom adjusted; 32 = right
adjusted and vertically centered.</para>
</sect3>

<sect3>
<title>Setting Text Angle</title>
<para>Use <emphasis role="bold"><code>TAttText</code></emphasis><code>::SetTextAngle</code>
to set the text angle. The <code>angle</code> is the degrees of the
horizontal.</para>

<programlisting language="c++">root[] <emphasis role="bold">la-&gt;SetTextAngle(angle)</emphasis>
</programlisting>

</sect3>

<sect3>
<title>Setting Text Color</title>
<para>Use <emphasis role="bold"><code>TAttText</code></emphasis><code>::SetTextColor</code>
to set the text color. The <code>color</code> is the color index. The colors are
described in "Color and Color Palettes".</para>

<programlisting language="c++">root[] la-&gt;SetTextColor(color)
</programlisting>

</sect3>

<sect3>
<title>Setting Text Font</title>
<para>Use <emphasis role="bold"><code>TAttText</code></emphasis><code>::SetTextFont</code>
to set the font. The parameter font is the font code, combining the font and
precision: <code>font = 10 * fontID + precision</code></para>

<programlisting language="c++">root[] la-&gt;SetTextFont(font)
</programlisting>

<para>The table below lists the available fonts. The font IDs must be between 1
and 14. The precision can be:</para>
<itemizedlist>
<listitem><para>Precision = 0 fast hardware fonts (steps in the size)</para></listitem>
<listitem><para>Precision = 1 scalable and rotate-able hardware fonts (see below)</para></listitem>
<listitem><para>Precision = 2 scalable and rotate-able hardware fonts</para></listitem>
</itemizedlist>
<para>When precision 0 is used, only the original non-scaled system fonts are used.
The fonts have a minimum (4) and maximum (37) size in pixels. These fonts are
fast and are of good quality. Their size varies with large steps and they cannot
be rotated. Precision 1 and 2 fonts have a different behavior depending if True
Type Fonts (TTF) are used or not. If TTF are used, you always get very good
quality scalable and rotate-able fonts. However, TTF are slow. Precision 1 and 2
fonts have a different behavior for PostScript in case of
<emphasis role="bold"><code>TLatex</code></emphasis> objects:</para>
<itemizedlist>
<listitem><para>With precision 1, the PostScript text uses the old convention
(see <emphasis role="bold"><code>TPostScript</code></emphasis>) for some special
characters to draw sub and superscripts or Greek text.</para></listitem>
<listitem><para>With precision 2, the "PostScript" special characters are drawn
as such. To draw sub and superscripts it is highly recommended to use
<emphasis role="bold"><code>TLatex</code></emphasis> objects
instead.</para></listitem>
</itemizedlist>
<para>For example: <code>font = 62</code> is the font with ID <code>6</code> and
precision <code>2</code>.</para>

<figure><title>Font’s examples</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000CF.png" width="317.15pt" depth="209.15pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The available fonts are:</para>
<informaltable frame="all">
<tgroup cols="5">
<colspec colwidth="970*" colname="column-1"/>
<colspec colwidth="2520*" colname="column-2"/>
<colspec colwidth="2210*" colname="column-3"/>
<colspec colwidth="750*" colname="column-4"/>
<colspec colwidth="1094*" colname="column-5"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Font ID</para>
</entry>
<entry rowsep="1" colsep="1">
<para>X11</para>
</entry>
<entry rowsep="1" colsep="1">
<para>True Type name</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Is italic</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"boldness"</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>1</para>
</entry>
<entry rowsep="1" colsep="1">
<para>times-medium-i-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Times New Roman"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Yes</para>
</entry>
<entry rowsep="1" colsep="1">
<para>4</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>2</para>
</entry>
<entry rowsep="1" colsep="1">
<para>times-bold-r-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Times New Roman"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>No</para>
</entry>
<entry rowsep="1" colsep="1">
<para>7</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>3</para>
</entry>
<entry rowsep="1" colsep="1">
<para>times-bold-i-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Times New Roman"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Yes</para>
</entry>
<entry rowsep="1" colsep="1">
<para>7</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>4</para>
</entry>
<entry rowsep="1" colsep="1">
<para>helvetica-medium-r-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Arial"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>No</para>
</entry>
<entry rowsep="1" colsep="1">
<para>4</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>5</para>
</entry>
<entry rowsep="1" colsep="1">
<para>helvetica-medium-o-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Arial"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Yes</para>
</entry>
<entry rowsep="1" colsep="1">
<para>4</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>6</para>
</entry>
<entry rowsep="1" colsep="1">
<para>helvetica-bold-r-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Arial"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>No</para>
</entry>
<entry rowsep="1" colsep="1">
<para>7</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>7</para>
</entry>
<entry rowsep="1" colsep="1">
<para>helvetica-bold-o-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Arial"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Yes</para>
</entry>
<entry rowsep="1" colsep="1">
<para>7</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>8</para>
</entry>
<entry rowsep="1" colsep="1">
<para>courier-medium-r-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Courier New"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>No</para>
</entry>
<entry rowsep="1" colsep="1">
<para>4</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>9</para>
</entry>
<entry rowsep="1" colsep="1">
<para>courier-medium-o-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Courier New"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Yes</para>
</entry>
<entry rowsep="1" colsep="1">
<para>4</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>10</para>
</entry>
<entry rowsep="1" colsep="1">
<para>courier-bold-r-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Courier New"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>No</para>
</entry>
<entry rowsep="1" colsep="1">
<para>7</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>11</para>
</entry>
<entry rowsep="1" colsep="1">
<para>courier-bold-o-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Courier New"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Yes</para>
</entry>
<entry rowsep="1" colsep="1">
<para>7</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>12</para>
</entry>
<entry rowsep="1" colsep="1">
<para>symbol-medium-r-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Symbol"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>No</para>
</entry>
<entry rowsep="1" colsep="1">
<para>6</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>13</para>
</entry>
<entry rowsep="1" colsep="1">
<para>times-medium-r-normal</para>
</entry>
<entry rowsep="1" colsep="1">
<para>"Times New Roman"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>No</para>
</entry>
<entry rowsep="1" colsep="1">
<para>4</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>14</para>
</entry>
<entry rowsep="1" colsep="1">
<para/>
</entry>
<entry rowsep="1" colsep="1">
<para>"Wingdings"</para>
</entry>
<entry rowsep="1" colsep="1">
<para>No</para>
</entry>
<entry rowsep="1" colsep="1">
<para>4</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>This script makes the image of the different fonts:</para>

<programlisting language="c++">{
  textc = new TCanvas("textc","Example of text",1);
  for (int i=1;i&lt;15;i++) {
    cid = new char[8];
    sprintf(cid,"ID %d :",i);
    cid[7] = 0;
    lid = new TLatex(0.1,1-(double)i/15,cid);
    lid-&gt;SetTextFont(62);
    lid-&gt;Draw();
    l = new TLatex(.2,1-(double)i/15,"The quick brown fox is not here anymore")
    l-&gt;SetTextFont(i*10+2);
    l-&gt;Draw();
  }
}
</programlisting>

</sect3>

<sect3>
<title>How to use True Type Fonts</title>
<para>You can activate the True Type Fonts by adding the following line in your
<code>.rootrc</code> file.</para>

<programlisting language="c++">Unix.*.Root.UseTTFonts:     true
</programlisting>

<para>You can check that you indeed use the <code>TTF</code> in your Root
session. When the <code>TTF</code> is active, you get the following message at
the start of a session:  "Free Type Engine v1.x used to render TrueType fonts."
You can also check with the command:</para>

<programlisting language="c++">gEnv-&gt;Print()
</programlisting>

</sect3>

<sect3>
<title>Setting Text Size</title>
<para>Use
<emphasis role="bold"><code>TAttText</code></emphasis><code>::SetTextSize</code>
to set the text size.</para>

<programlisting language="c++">root[]<emphasis role="bold"><code> la-&gt;SetTextSize(size)</code></emphasis>
</programlisting>

<para>The <code>size</code> is the text size expressed in percentage of the
current pad size.</para>
<para>The text size in pixels will be:</para>
<itemizedlist>
<listitem><para>If current pad is horizontal, the size in pixels  =
<code>textsize * canvas_height</code></para></listitem>
<listitem><para>If current pad is vertical, the size in pixels =
<code>textsize * canvas_width</code></para></listitem>
</itemizedlist>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030000D0.png" width="63.35pt" depth="36.6pt"/></imageobject></inlinemediaobject>
The user interface for changing the text color, size, font and allignment looks
like shown in this picture. It takes place in the editor frame anytime the
selected object inherits the class
<emphasis role="bold"><code>TAttText</code></emphasis>.</para>
<para/>
</sect3>
</sect2>

<sect2>
<title>Line Attributes</title>
<para>All classes manipulating lines have to deal with line attributes: color,
style and width. This is done by using secondary inheritance of the class
<emphasis role="bold"><code>TAttLine</code></emphasis>. The line color may be
set by a method call. What is said here applies to all objects deriving from
<emphasis role="bold"><code>TAttLine</code></emphasis>, and there are many
(histograms, plots). We will take an example that may be transposed to other
types. Suppose "<code>li</code>" is a
<emphasis role="bold"><code>TLine</code></emphasis> object. The line color is
set with:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>li-&gt;SetLineColor(color)</code></emphasis>
</programlisting>

<para>The argument <code>color</code> is a color number. The colors are
described in "Color and Color Palettes"</para>
<para>The line style may be set by a method call. What is said here applies to
all objects deriving from <emphasis role="bold"><code>TAttLine</code></emphasis>,
and there are many (histograms, plots). We will take an example that may be
transposed to other types. Suppose "<code>li</code>" is a
<emphasis role="bold"><code>TLine</code></emphasis> object. The line style is
set with:</para>

<programlisting language="c++">root[]<emphasis role="bold"><code> li-&gt;SetLineStyle(style)</code></emphasis>
</programlisting>

<para>The argument style is one of: 1=solid, 2=dash, 3=dot, 4=dash-dot.</para>
<para>The line width may be set by a method call. What is said here applies to
all objects deriving from <emphasis role="bold"><code>TAttLine</code></emphasis>,
and there are many (histograms, plots). We will take an example that may be
transposed to other types. Suppose "<code>li</code>" is a
<emphasis role="bold"><code>TLine</code></emphasis> object. The line width is
set with:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>li-&gt;SetLineWidth(width)</code></emphasis>
</programlisting>

<para>The <code>width</code> is the width expressed in pixel units.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030000D1.png" width="77.15pt" depth="35.35pt"/></imageobject></inlinemediaobject>
The user interface for changing the line color, line width and style looks like
shown in this picture. It takes place in the editor frame anytime the selected
object inherits the class
<emphasis role="bold"><code>TAttLine</code></emphasis>.</para>
</sect2>

<sect2>
<title>Fill Attributes</title>
<para>Almost all graphics classes have a fill area somewhere. These classes have
to deal with fill attributes. This is done by using secondary inheritance of the
class <emphasis role="bold"><code>TAttFill</code></emphasis>. Fill color may be
set by a method call. What is said here applies to all objects deriving from
<emphasis role="bold"><code>TAttFill</code></emphasis>, and there are many
(histograms, plots). We will take an example that may be transposed to other
types. Suppose "<code>h</code>" is a
<emphasis role="bold"><code>TH1F</code></emphasis> (1 dim histogram) object. The
histogram fill color is set with:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>h-&gt;SetFillColor(color)</code></emphasis>
</programlisting>

<para>The color is a color number. The colors are described in "Color and color
palettes"</para>
<para>Fill style may be set by a method call. What is said here applies to all
objects deriving from <code>TAttFill</code>, and there are many (histograms,
plots). We will take an example that may be transposed to other types. Suppose
"<code>h</code>" is a <emphasis role="bold">TH1F</emphasis> (1 dim histogram)
object. The histogram fill style is set with:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>h-&gt;SetFillStyle(style)</code></emphasis>
</programlisting>

<para>The convention for style is: 0:hollow, 1001:solid, 2001:hatch style, 
3000+pattern number:patterns, 4000 to 4100:transparency, 4000:fully transparent,
4100: fully opaque.</para>
<para>Fill styles &gt;3100 and &lt;3999 are hatches. They are defined according
to the <code>FillStyle=3ijk</code> value as follows:</para>
<itemizedlist>
<listitem><para><code>i(1-9)</code> specifies the space between each hatch
<code>(1=minimum space</code>, <code>9=maximum)</code>. The final spacing is set
by <code>SetHatchesSpacing()</code> method and it
is<code>*GetHatchesSpacing()</code>.</para></listitem>
<listitem><para><code>j(0-9)</code> specifies the angle between 0 and 90 degres
as follows: <code>0=0</code>, <code>1=10</code>, <code>2=20</code>,
<code>3=30</code>, <code>4=45</code>, <code>5=not drawn</code>,
<code>6=60</code>, <code>7=70</code>, <code>8=80</code> and
<code>9=90</code>.</para></listitem>
<listitem><para><code>k(0-9)</code> specifies the angle between 0 and 90 degres
as follows: <code>0=180</code>, <code>1=170</code>, <code>2=160</code>,
<code>3=150</code>, <code>4=135</code>, <code>5=not drawn</code>,
<code>6=120</code>, <code>7=110</code>, <code>8=100</code> and
<code>9=90</code>.</para></listitem>
</itemizedlist>

<figure><title>The various patterns</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000D2.png" width="244.55pt" depth="146.5pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect2>

<sect2>
<title>Color and Color Palettes</title>
<para>At initialization time, a table of basic colors is generated when the
first Canvas constructor is called. This table is a linked list, which can be
accessed from the
<emphasis role="italic"><emphasis role="bold"><code>gROOT</code></emphasis></emphasis>
object (see <emphasis role="bold"><code>TROOT</code></emphasis><code>::GetListOfColors()</code>).
Each color has an index and when a basic color is defined, two "companion"
colors are defined:</para>
<itemizedlist>
<listitem><para>the dark version (color index + 100)</para></listitem>
<listitem><para>the bright version (color index + 150)</para></listitem>
</itemizedlist>
<para>The dark and bright colors are used to give 3-D effects when drawing
various boxes (see <emphasis role="bold"><code>TWbox</code></emphasis>,
<emphasis role="bold"><code>TPave</code></emphasis>,
<emphasis role="bold"><code>TPaveText</code></emphasis>,
<emphasis role="bold"><code>TPaveLabel</code></emphasis>, etc). If you have a
black and white copy of the manual, here are the basic colors and their
indices.</para>

<figure><title>The basic ROOT colors</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000D3.png" width="301.05pt" depth="168.85pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/image212.jpg" width="108.6pt" depth="162.9pt"/></imageobject></inlinemediaobject>
</para>
<para>The list of currently supported basic colors (here dark and bright colors
are not shown) are shown. The color numbers specified in the basic palette, and
the picture above, can be viewed by selecting the menu entry Colors in the View
canvas menu. The user may define other colors. To do this, one has to build a
new <emphasis role="bold"><code>TColor</code></emphasis>:</para>

<programlisting language="c++">TColor(Int_t color,Float_t r,Float_t g,Float_t b,const char* name)
</programlisting>

<para>One has to give the color number and the three Red, Green, Blue values,
each being defined from 0 (min) to 1(max). An optional name may be given. When
built, this color is automatically added to the existing list of colors. If the
color number already exists, one has to extract it from the list and redefine
the RGB values. This may be done for example with:</para>

<programlisting language="c++">root[] <emphasis role="bold">color=(TColor*)(gROOT-&gt;GetListOfColors()-&gt;At(index_color))</emphasis>
root[] <emphasis role="bold">color-&gt;SetRGB(r,g,b)</emphasis>
</programlisting>

<para>Where <code>r</code>, <code>g</code> and <code>b</code> go from 0 to 1 and
<code>index_color</code> is the color number you wish to change.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030000D4.png" width="69.45pt" depth="23.15pt"/></imageobject></inlinemediaobject>
The user interface for changing the fill color and style looks like shown in
this picture. It takes place in the editor frame anytime the selected object
inherits the class <emphasis role="bold"><code>TAttFill</code></emphasis>.</para>

<sect3>
<title>Color Palette (for Histograms)</title>
<para>Defining one color at a time may be tedious. The histogram classes (see
Draw Options) use the color palette. For example,
<emphasis role="bold"><code>TH1</code></emphasis><code>::Draw("col")</code> draws
a 2-D histogram with cells represented by a box filled with a color
<code>CI</code> function of the cell content. If the cell content is
<code>N</code>, the color <code>CI</code> used will be the color number in
<code>colors[N]</code>. If the maximum cell content is <code>&gt;ncolors</code>,
all cell contents are scaled to <code>ncolors</code>. The current color palette
does not have a class or global object of its own. It is defined in the current
style as an array of color numbers. The current palette can be changed with:</para>

<programlisting language="c++"><code>TStyle::SetPalette(Int_t ncolors,Int_t*color_indexes). </code>
</programlisting>

<para>By default, or if <code>ncolors &lt;= 0</code>, a default palette (see above) of 50 colors is defined. The colors defined in this palette are good for coloring pads, labels, and other graphic objects. If <code>ncolors &gt; 0</code> and <code>colors = 0</code>, the default palette is used with a maximum of <code>ncolors</code>. If <code>ncolors == 1 &amp;&amp; colors == 0</code>, then a pretty palette with a spectrum <code>Violet-&gt;Red</code> is created. It is recommended to use this pretty palette when drawing lego(s), surfaces or contours. For example, to set the current palette to the “<code>pretty</code>” one, do:</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>gStyle-&gt;SetPalette(1)</code></emphasis>
</programlisting>

<para>A more complete example is shown below. It illustrates the definition of a
custom palette. You can adapt it to suit your needs. In case you use it for
contour coloring, with the current color/contour algorithm, always define two
more colors than the number of contours.</para>

<programlisting language="c++">void palette() {
  <emphasis role="italic">// Example of creating new colors (purples)</emphasis>
  const Int_t colNum = 10;    <emphasis role="italic">// and defining of a new palette</emphasis>
  Int_t palette[colNum];
  for (Int_t i=0; i&lt;colNum; i++) {
    <emphasis role="italic">// get the color and if it does not exist create it</emphasis>
    if (! gROOT-&gt;GetColor(230+i) ){
      TColor *color = new TColor(230+i,1-(i/((colNum)*1.0)),0.3,0.5,"");
    } else {
      TColor *color = gROOT-&gt;GetColor(230+i);
      color-&gt;SetRGB(1-(i/((colNum)*1.0)),0.3,0.5);
    }
    palette[i] = 230+i;
  }
  gStyle-&gt;SetPalette(colNum,palette);
  TF2 *f2 = new TF2("f2","exp(-(x^2)-(y^2))",-3,3,-3,3);
  <emphasis role="italic">// two contours less than the number of colors in palette</emphasis>
  f2-&gt;SetContour(colNum-2);
  f2-&gt;Draw("cont");
}
</programlisting>

</sect3>
</sect2>
</sect1>

<sect1>
<title>The Graphics Editor</title>
<para>A new graphics editor took place in ROOT v4.0. The editor can be activated
by selecting the Editor menu entry in the canvas View menu or one of the context
menu entries for setting line, fill, marker or text attributes. The following
object editors are available for the current ROOT version.</para>

<sect2>
<title>TAxisEditor</title>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030000D5.png" width="75.8pt" depth="162.65pt"/></imageobject></inlinemediaobject></para>
<para> This user interface gives the possibility for changing the following axis
attributes:</para>
<itemizedlist>
<listitem><para>color of the selected axis, the axis’ title and labels;</para></listitem>
<listitem><para>the length of thick parameters and the possibility to set them
on both axis sides
(if <code>+-</code>  is selected);</para></listitem>
<listitem><para>to set logarithmic or linear scale along the selected axis with
a choice for optimized
or more logarithmic labels;</para></listitem>
<listitem><para>primary, secondary and tertiary axis divisions can be set via
the three number fields;</para></listitem>
<listitem><para>the axis title can be added or edited and the title’s color,
position, offset, size and
font can be set interactively;</para></listitem>
<listitem><para>the color, size, and offset of axis labels can be set similarly.
In addition, there is a
check box for no exponent choice, and another one for setting the same decimal
part for all labels.</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>TPadEditor</title>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030000D6.png" width="76.05pt" depth="126.75pt"/></imageobject></inlinemediaobject></para>
<itemizedlist>
<listitem><para>It provides the following user interface:</para></listitem>
<listitem><para>Fixed aspect ratio – can be set for pad resizing.</para></listitem>
<listitem><para>Edit – sets pad or canvas as editable.</para></listitem>
<listitem><para>Cross-hair – sets a cross hair on the pad.</para></listitem>
<listitem><para>TickX – set ticks along the X axis.</para></listitem>
<listitem><para>TickY – set ticks along the Y axis.</para></listitem>
<listitem><para>GridX  – set a grid along the X axis.</para></listitem>
<listitem><para>GridY – set a grid along the  Y axis.</para></listitem>
<listitem><para>The pad or canvas border size can be set if a sunken or a raised
border mode is</para></listitem>
<listitem><para>selected; no border mode can be set too.</para></listitem>
</itemizedlist>
</sect2>
</sect1>

<sect1>
<title>Copy and Paste</title>
<para>You can make a copy of a canvas using
<emphasis role="bold"><code>TCanvas</code></emphasis><code>::DrawClonePad</code>.
This method is unique to <emphasis role="bold"><code>TCanvas</code></emphasis>.
It clones the entire canvas to the active pad. There is a more general method
<emphasis role="bold"><code>TObject</code></emphasis><code>::DrawClone</code>,
which all objects descendent of <emphasis role="bold"><code>TObject</code></emphasis>,
specifically all graphic objects inherit. Below are two examples, one to show
the use of <code>DrawClonePad</code> and the other to show the use of
<code>DrawClone</code>.</para>

<sect2>
<title>Using the GUI</title>
<para>In this example we will copy an entire canvas to a new one with
<code>DrawClonePad</code>. Run the script <code>draw2dopt.C</code>.</para>

<programlisting language="c++">root[] .x tutorials/hist/draw2dopt.C
</programlisting>

<para>This creates a canvas with 2D histograms. To make a copy of the canvas
follow the steps:</para>
<itemizedlist>
<listitem><para>Right-click on it to bring up the context menu</para></listitem>
<listitem><para>Select <code>DrawClonePad</code></para></listitem>
</itemizedlist>
<para>This copies the entire canvas and all its sub-pads to a new canvas. The
copied canvas is a deep clone, and all the objects on it are copies and
independent of the original objects. For instance, change the fill on one of the
original histograms, and the cloned histogram retains its attributes.
<code>DrawClonePad</code> will copy the canvas to the active pad; the target
does not have to be a canvas. It can also be a pad on a canvas.</para>

<figure><title>Different draw options</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000D7.png" width="253.25pt" depth="191.15pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>If you want to copy and paste a graphic object from one canvas or pad to
another canvas or pad, you can do so with <code>DrawClone</code> method inherited
from <emphasis role="bold"><code>TObject</code></emphasis>. All graphics objects
inherit the <emphasis role="bold"><code>TObject</code></emphasis><code>::DrawClone</code>
method. In this example, we create a new canvas with one histogram from each of
the canvases from the script <code>draw2dopt.C</code>.</para>
<itemizedlist>
<listitem><para>Start a new ROOT session and execute the script
<code>draw2dopt.C</code></para></listitem>
<listitem><para>Select a canvas displayed by the script, and create a new canvas
<code>c1</code> from the File menu.</para></listitem>
<listitem><para>Make sure that the target canvas (<code>c1</code>) is the active
one by middle clicking on it. If you do this step right after step 2, c1 will be
active.</para></listitem>
<listitem><para>Select the pad with the first histogram you want to copy and
paste.</para></listitem>
<listitem><para>Right click on it to show the context menu, and select
<code>DrawClone</code>.</para></listitem>
<listitem><para>Leave the option blank and hit OK.</para></listitem>
</itemizedlist>
<para>Repeat these steps for one histogram on each of the canvases created by
the script, until you have one pad from each type. If you wanted to put the same
annotation on each of the sub pads in the new canvas, you could use
<code>DrawClone</code> to do so. Here we added the date to each pad. The steps
to this are:</para>
<itemizedlist>
<listitem><para>Create the label in on of the pads with the graphics
editor.</para></listitem>
<listitem><para>Middle-click on the target pad to make it the active
pad</para></listitem>
<listitem><para>Use <code>DrawClone</code> method of the label to draw it in
each of the other panels.</para></listitem>
</itemizedlist>
<para>The option in the <code>DrawClone</code> method argument is the Draw
option for a histogram or graph. A call to
<emphasis role="bold"><code>TH1</code></emphasis><code>::DrawClone</code> can
clone the histogram with a different draw option.</para>
</sect2>

<sect2>
<title>Programmatically</title>
<para>To copy and paste the four pads from the command line or in a script you
would execute the following statements:</para>

<programlisting language="c++">root[] <emphasis role="bold">.x tutorials/hist/draw2dopt.C</emphasis>
root[] <emphasis role="bold">TCanvas c1("c1","Copy Paste",200,200,800,600);</emphasis>
root[] <emphasis role="bold">surfaces-&gt;cd(1);</emphasis> <emphasis role="italic">// get the first pad</emphasis>
root[] <emphasis role="bold">TPad *p1 = gPad;</emphasis>
root[] <emphasis role="bold">lego-&gt;cd(2);</emphasis><emphasis role="italic">// get the next pad</emphasis>
root[] <emphasis role="bold">TPad *p2 = gPad;</emphasis>
root[] <emphasis role="bold">cont-&gt;cd(3);</emphasis><emphasis role="italic">// get the next pad</emphasis>
root[] <emphasis role="bold">TPad *p3 = gPad;</emphasis>
root[] <emphasis role="bold">c2h-&gt;cd(4);</emphasis><emphasis role="italic">// get the next pad</emphasis>
root[] <emphasis role="bold">TPad *p4 = gPad;</emphasis>
root[] <emphasis role="italic">// to draw the four clones</emphasis>
root[] <emphasis role="bold">c1-&gt;cd();</emphasis>
root[] <emphasis role="bold">p1-&gt;DrawClone();</emphasis>
root[] <emphasis role="bold">p2-&gt;DrawClone();</emphasis>
root[] <emphasis role="bold">p3-&gt;DrawClone();</emphasis>
root[] <emphasis role="bold">p4-&gt;DrawClone();</emphasis>
</programlisting>

<para>Note that the pad is copied to the new canvas in the same location as in
the old canvas. For example if you were to copy the third pad of <code>surf</code>
to the top left corner of the target canvas you would have to reset the
coordinates of the cloned pad.</para>
</sect2>
</sect1>

<sect1>
<title>Legends</title>
<para>Legends for a graph are obtained with a
<emphasis role="bold"><code>TLegend</code></emphasis> object. This object points
to markers, lines, boxes, histograms, graphs and represent their marker, line,
fill attributes. Any object that has a marker or line or fill attribute may have
an associated legend. A <emphasis role="bold"><code>TLegend</code></emphasis> is
a panel with several entries (class
<emphasis role="bold"><code>TLegendEntry</code></emphasis>) and is created by
the constructor</para>

<programlisting language="c++">TLegend(Double_t x1,Double_t y1,Double_t x2,Double_t y2,const char *header,
Option_t *option)
</programlisting>

<para>The legend is defined with default coordinates, border size and option.
The legend coordinates (NDC) in the current pad are <code>x1</code>,
<code>y1</code>, <code>x2</code>, <code>y2</code>. The default text attributes
for the legend are:</para>
<itemizedlist>
<listitem><para>Alignment = 12 left adjusted and vertically centered</para></listitem>
<listitem><para>Angle = 0 (degrees)</para></listitem>
<listitem><para>Color = 1 (black)</para></listitem>
<listitem><para>Size = calculate when number of entries is known</para></listitem>
<listitem><para>Font = helvetica-medium-r-normal scalable font = 42, and bold = 62
for title</para></listitem>
</itemizedlist>
<para>The title is a regular entry and supports
<emphasis role="bold"><code>TLatex</code></emphasis>. The default is no title
(<code>header = 0</code>). The options are the same as for
<emphasis role="bold"><code>TPave</code></emphasis>; by default, they are
"<code>brand</code>". Once the legend box is created, one has to add the text
with the <code>AddEntry()</code> method:</para>

<programlisting language="c++">TLegendEntry* TLegend::AddEntry(TObject *obj, const char *label,Option_t *option)
</programlisting>

<para>The parameters are:</para>
<itemizedlist>
<listitem><para><code>*obj </code>is a pointer to an object having marker, line,
or fill attributes (a histogram, or a graph)</para></listitem>
<listitem><para><code>label</code> is the label to be associated to the
object</para></listitem>
<listitem><para><code>option</code>:</para></listitem>
<listitem><para>”L” draw line associated with line attributes of
<code>obj</code>, if <code>obj</code> inherits from
<emphasis role="bold"><code>TAttLine</code></emphasis>.</para></listitem>
<listitem><para>”P” draw poly-marker associated with marker attributes of
<code>obj</code>, if <code>obj</code> inherits
<emphasis role="bold"><code>TAttMarker</code></emphasis>.</para></listitem>
<listitem><para>”F” draw a box with fill associated with fill attributes of
<code>obj</code>, if <code>obj</code> inherits
 <emphasis role="bold"><code>TAttFill</code></emphasis>.</para></listitem>
</itemizedlist>
<para>One may also use the other form of the method <code>AddEntry</code>:</para>

<programlisting language="c++">TLegendEntry* TLegend::AddEntry(const char *name,const char *label, Option_t *option)
</programlisting>

<para>Here <code>name</code> is the name of the object in the pad. Other
parameters are as in the previous case. Next example shows how to create a
legend:</para>

<programlisting language="c++">leg = new TLegend(0.4,0.6,0.89,0.89);
leg-&gt;AddEntry(fun1,"One Theory","l");
leg-&gt;AddEntry(fun3,"Another Theory","f");
leg-&gt;AddEntry(gr,"The Data","p");
leg-&gt;Draw();
<emphasis role="italic">// oops we forgot the blue line... add it after</emphasis>
leg-&gt;AddEntry(fun2,"#sqrt{2#pi} P_{T} (#gamma) latex  formula","f");
<emphasis role="italic">// and add a header (or "title") for the legend</emphasis>
leg-&gt;SetHeader("The Legend Title");
leg-&gt;Draw();
</programlisting>

<para>Here <code>fun1</code>, <code>fun2</code>, <code>fun3</code> and
<code>gr</code> are pre-existing functions and graphs. You can edit the
<emphasis role="bold"><code>TLegend</code></emphasis> by right clicking on it.</para>

<figure><title>A legend example</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000D8.png" width="226.55pt" depth="214.75pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect1>

<sect1>
<title>The PostScript Interface</title>
<para>To generate a PostScript (or encapsulated PostScript) file for a single
image in a canvas, you can:</para>
<itemizedlist>
<listitem><para>Select to print the canvas in the PostScript file format from
the File menu / Save or Save As menu entries. By default, a PostScript file is
generated, if you do not specify the file format.</para></listitem>
<listitem><para>Click in the canvas area, near the edges, with the right mouse
button and select the Print context menu entry. This will generate a file of
canvas pointed to by c1. You can select the name of the PostScript file. If the
file name is <code>xxx.ps</code>, you will generate a PostScript file named
<code>xxx.ps</code>. If the file name is <code>xxx.eps</code>, you generate an
encapsulated Postscript file instead. In your program (or script), you can
type:</para></listitem>
</itemizedlist>
<programlisting language="c++">c1-&gt;Print("xxx.ps")<emphasis role="italic"> // or</emphasis>
c1-&gt;Print("xxx.eps")
</programlisting>

<para>Next example prints the picture in the pad pointed by <code>pad1</code>.</para>

<programlisting language="c++"><emphasis role="bold">pad1-&gt;Print("xxx.ps")</emphasis>
</programlisting>

<para>The <emphasis role="bold"><code>TPad</code></emphasis><code>::Print</code>
method has a second parameter called option. Its value can be:</para>
<itemizedlist>
<listitem><para><code> 0</code>   which is the default and is the same as "<code>ps</code>"</para></listitem>
<listitem><para>"<code>ps</code>" a Postscript file is produced</para></listitem>
<listitem><para>"<code>Portrait</code>" a Postscript file is produced with Portrait orientation</para></listitem>
<listitem><para>"<code>Landscape</code>" a Postscript file is produced with Landscape orientation</para></listitem>
<listitem><para>"<code>eps</code>"an Encapsulated Postscript file</para></listitem>
<listitem><para>"<code>Preview</code>"an Encapsulated Postscript file with preview is produced</para></listitem>
<listitem><para>"<code>gif</code>" a Graphics Interchange Format file</para></listitem>
<listitem><para>"<code>cxx</code>" a C++ macro file is generated</para></listitem>
<listitem><para>"<code>pdf</code>"a Portable Document Format file</para></listitem>
<listitem><para>"<code>xml</code>" a eXtensible Mark-up Language file</para></listitem>
<listitem><para>"<code>jpg</code>"a Joint Photographic Experts Group file</para></listitem>
<listitem><para>"<code>png</code>" a Portable Network Graphics Format (PNG file)</para></listitem>
<listitem><para>"<code>xpm</code>" a X11 Pixel Map Format</para></listitem>
<listitem><para>"<code>svg</code>" a Scalable Vector Graphics file</para></listitem>
<listitem><para>"<code>tiff</code>" a Tagged-Image File Format</para></listitem>
<listitem><para>“<code>root</code>”a ROOT binary file is produced</para></listitem>
</itemizedlist>
<para>You do not need to specify this second parameter; you can indicate by the
filename extension what format you want to save a canvas in (i.e.
<code>canvas.ps</code>, <code>canvas.gif</code>, <code>canvas.C</code>, etc).</para>
<para>The size of the PostScript picture, by default, is computed to keep the
aspect ratio of the picture on the screen, where the size along <code>x</code>
is always 20 cm. You can set the size of the PostScript picture before
generating the picture with a command such as:</para>

<programlisting language="c++">TPostScript myps("myfile.ps",111)
myps.Range(xsize,ysize);
object-&gt;Draw();
myps.Close();
</programlisting>

<para>
The first parameter in the
<emphasis role="bold"><code>TPostScript</code></emphasis>
constructor is the name of the file; the second one is the format option:</para>
<itemizedlist>
<listitem><para>111 - <code>ps portrait</code></para></listitem>
<listitem><para>112 - <code>ps landscape</code></para></listitem>
<listitem><para>113 - <code>eps</code></para></listitem>
</itemizedlist>
<para>You can set the default paper size with:</para>

<programlisting language="c++">gStyle-&gt;SetPaperSize(xsize,ysize);
</programlisting>

<para>You can resume writing again in this file with <code>myps.Open()</code>.
Note that you may have several Post Script files opened simultaneously. Use
<emphasis role="bold"><code>TPostScript</code></emphasis><code>::Text(x,y,"string")</code>
to add text to a postscript file. This method writes the string in quotes into
a PostScript file at position <code>x, y</code> in world coordinates.</para>

<sect2>
<title>Special Characters</title>
<para>The following characters have a special action on the PostScript file:</para>
<itemizedlist>
<listitem><para><code>`</code> - go to Greek</para></listitem>
<listitem><para><code>'</code> - go to special</para></listitem>
<listitem><para><code>~</code> - go to Zapf Dingbats</para></listitem>
<listitem><para><code>?</code> - go to subscript</para></listitem>
<listitem><para><code>^</code> - go to superscript</para></listitem>
<listitem><para><code>!</code> - go to normal level of script</para></listitem>
<listitem><para><code>&amp;</code> - backspace one character</para></listitem>
<listitem><para><code>#</code> - end of Greek or of <code>ZapfDingbats</code></para></listitem>
</itemizedlist>
<para>These special characters are printed as such on the screen. To generate
one of these characters on the PostScript file, you must escape it with the
escape character "@". The use of these special characters is illustrated in
several scripts referenced by the
<emphasis role="bold"><code>TPostScript</code></emphasis> constructor.</para>
</sect2>

<sect2>
<title>Writing Several Canvases to the Same PostScript File</title>
<para>The following sequence writes the canvas to "<code>c1.ps</code>" and
closes the postscript file:</para>

<programlisting language="c++">TCanvas c1("c1");
h1.Draw();
c1.Print("c1.ps");
</programlisting>

<para>If the Postscript file name finishes with "<code>(</code>", the file
remains opened (it is not closed). If the Postscript file name finishes with "<code>)</code>" and the file has been opened with "<code>(</code>", the file is closed.</para>

<programlisting language="c++"><code>{  </code>
<code>   TCanvas c1("c1");</code>
<code>   h1.Draw();</code>
<code>   c1.Print("c1.ps(");  </code><emphasis role="italic"><code>// write canvas and keep the ps file open</code></emphasis>
<code>   h2.Draw();</code>
<code>   c1.Print("c1.ps");   </code><emphasis role="italic"><code>// canvas is added to "c1.ps"</code></emphasis>
<code>   h3.Draw();</code>
<code>   c1.Print("c1.ps)");  </code><emphasis role="italic"><code>//canvas is added to "c1.ps"; ps file is closed</code></emphasis>
<code>}</code>
</programlisting>

<para>The <emphasis role="bold"><code>TCanvas</code></emphasis><code>::Print("file.ps(")</code>         mechanism is very useful, but it can be a little inconvenient to have the action of opening/closing a file being atomic with printing a page. Particularly if pages are being generated in some loop, one needs to detect the special cases of first and last page. The "<code>[</code>" and "<code>]</code>" can be used instead of "<code>(</code>" and "<code>)</code>" as shown in the next example.</para>

<programlisting language="c++"><code>c1.Print("file.ps[");      </code><emphasis role="italic"><code>// no actual print; just open file.ps</code></emphasis>
<code>for (i=0; i&lt;10; ++i) {</code>
<code>   // fill canvas for context i</code>
<code>   ...</code>
<code>   c1.Print("file.ps");   </code><emphasis role="italic"><code>// actually print canvas to file.ps</code></emphasis>
<code>}  // end loop</code>
<code>c1.Print("file.ps]");     </code><emphasis role="italic"><code>// no actual print; just close file.ps</code></emphasis>
</programlisting>

<para>The following script illustrates how to open a postscript file and draw several pictures. The generation of a new postscript page is automatic when <emphasis role="bold"><code>TCanvas</code></emphasis><code>::Clear</code> is called by <code>object-&gt;Draw()</code>.</para>
<para/>
<para/>

<programlisting language="c++"><code>{  </code>
<code>   TFile f("hsimple.root");</code>
<code>   TCanvas c1("c1","canvas",800,600);</code>
<emphasis role="italic"><code>   //select PostScript  output type</code></emphasis>
<code>   Int_t type = 111;         </code><emphasis role="italic"><code>//portrait  ps</code></emphasis>
<code>   // Int_t type = 112;      </code><emphasis role="italic"><code>//landscape ps</code></emphasis>
<code>   // Int_t type = 113;      </code><emphasis role="italic"><code>//eps</code></emphasis>
<emphasis role="italic"><code>//create a PostScript  file and set the paper size</code></emphasis>
<code>   TPostScript ps("test.ps",type);</code>
<code>   ps.Range(16,24);          </code><emphasis role="italic"><code>//set x,y of printed page</code></emphasis>
<emphasis role="italic"><code>   //draw 3 histograms from file hsimple.root on separate pages</code></emphasis>
<code>   hpx-&gt;Draw();</code>
<code>   c1.Update();             </code><emphasis role="italic"><code> //force drawing in a script</code></emphasis>
<code>   hprof-&gt;Draw();</code>
<code>   c1.Update();</code>
<code>   hpx-&gt;Draw("lego1");</code>
<code>   c1.Update();</code>
<code>   ps.Close();</code>
}
</programlisting>

<para>The next example does the same:</para>

<programlisting language="c++">{
TFile f("hsimple.root");
TCanvas c1("c1","canvas",800,600);
<emphasis role="italic"><code>   //set x,y of printed page</code></emphasis>
<code>   gStyle-&gt;SetPaperSize(16,24);</code>

<emphasis role="italic"><code>   //draw 3 histograms from file hsimple.root on separate pages</code></emphasis>
<code>   hpx-&gt;Draw();</code>
<code>   c1-&gt;Print(“test1.ps(“, “Portrait”);</code>
<code>   hprof-&gt;Draw();</code>
<code>   c1-&gt;Print(“test1.ps”);</code>
<code>   hpx-&gt;Draw(“lego1”);</code>
<code>   c1-&gt;Print(“test1.ps)“);</code>
<code>}</code>
</programlisting>

<para>This following example shows two pages. The canvas is divided. <emphasis role="bold"><code>TPostScript</code></emphasis><code>::NewPage</code> must be called before starting a new picture. <code>object-&gt;Draw</code> does not clear the canvas in this case because we clear only the pads and not the main canvas. Note that <code>c1-&gt;Update</code> must be called at the end of the first picture.</para>

<programlisting language="c++">{
TFile *f1 = new TFile("hsimple.root");
TCanvas *c1 = new TCanvas("c1");
TPostScript *ps = new TPostScript("file.ps",112);
<emphasis role="italic"><code>   // picture 1</code></emphasis>
c1-&gt;Divide(2,1);
ps-&gt;NewPage();
c1-&gt;cd(1);
hpx-&gt;Draw();
c1-&gt;cd(2);
hprof-&gt;Draw();
<emphasis role="italic"><code>   // picture 2</code></emphasis>
c1-&gt;Update();
ps-&gt;NewPage();
c1-&gt;cd(1);
hpxpy-&gt;Draw();
c1-&gt;cd(2);
ntuple-&gt;Draw("px");
c1-&gt;Update();
ps-&gt;Close();
<emphasis role="italic"><code>   // invoke PostScript  viewer </code></emphasis>
gSystem-&gt;Exec("gs file.ps");
}
</programlisting>

<para>The next one does the same:</para>

<programlisting language="c++">{
TFile *f1 = new TFile("hsimple.root");
TCanvas *c1 = new TCanvas("c1");
c1-&gt;Divide(2,1);
<emphasis role="italic"><code>   // picture 1</code></emphasis>
c1-&gt;cd(1);
hpx-&gt;Draw();
c1-&gt;cd(2);
hprof-&gt;Draw();
c1-&gt;Print(“test2.ps(”, “Landscape”);
<emphasis role="italic"><code>   // picture 2</code></emphasis>
c1-&gt;cd(1);
hpxpy-&gt;Draw();
c1-&gt;cd(2);
ntuple-&gt;Draw(“px”);
c1-&gt;Print(“test2.ps)”);
gSystem-&gt;Exec("gs file.ps");  <emphasis role="italic"><code>// invoke PostScript  viewer</code></emphasis>
}
</programlisting>

</sect2>
</sect1>

<sect1>
<title>Create or Modify a Style</title>
<para>All objects that can be drawn in a pad inherit from one or more attribute classes like <emphasis role="bold"><code>TAttLine</code></emphasis>, <emphasis role="bold"><code>TAttFill</code></emphasis>, <emphasis role="bold"><code>TAttText</code></emphasis>, <emphasis role="bold"><code>TAttMarker</code></emphasis>. When objects are created, their default attributes are taken from the current style. The current style is an object of the class <emphasis role="bold"><code>TStyle</code></emphasis> and can be referenced via the global variable <emphasis role="italic"><emphasis role="bold"><code>gStyle</code></emphasis></emphasis> (in <code>TStyle.h</code>). See the class <emphasis role="bold"><code>TStyle</code></emphasis> for a complete list of the attributes that can be set in one style.</para>
<para>ROOT provides several styles called:</para>
<itemizedlist>
<listitem><para>"<code>Default</code>"    - the default style</para></listitem>
<listitem><para>"<code>Plain</code>" - the simple style (black and white)</para></listitem>
<listitem><para>"<code>Bold</code>" - bolder lines</para></listitem>
<listitem><para>"<code>Video</code>" - suitable for html output or screen viewing</para></listitem>
</itemizedlist>
<para>The "<code>Default</code>" style is created by:</para>

<programlisting language="c++">TStyle *default = new TStyle("Default","Default Style");
</programlisting>

<para>The "<code>Plain</code>" style can be used if you want to get a "conventional" PostScript output or if you are working on a monochrome display. The following example shows how to create it.</para>

<programlisting language="c++">TStyle *plain  = new TStyle("Plain","Plain Style(no colors/fill areas)");
plain-&gt;SetCanvasBorderMode(0);
plain-&gt;SetPadBorderMode(0);
plain-&gt;SetPadColor(0);
plain-&gt;SetCanvasColor(0);
plain-&gt;SetTitleColor(0);
plain-&gt;SetStatColor(0);
</programlisting>

<para>You can set the current style by:</para>

<programlisting language="c++">gROOT-&gt;SetStyle(style_name);
</programlisting>

<para>You can get a pointer to an existing style by:</para>

<programlisting language="c++">
TStyle *style = gROOT-&gt;GetStyle(style_name);
</programlisting>

<para>You can create additional styles by:</para>

<programlisting language="c++">TStyle *st1 = new TStyle("st1","my style");
st1-&gt;Set...
st1-&gt;cd();<emphasis role="italic"><code>  // this becomes now the current style gStyle</code></emphasis>
</programlisting>

<para>In your <code>rootlogon.C</code> file, you can redefine the default parameters via statements like:</para>

<programlisting language="c++">gStyle-&gt;SetStatX(0.7);
gStyle-&gt;SetStatW(0.2);
gStyle-&gt;SetLabelOffset(1.2);
gStyle-&gt;SetLabelFont(72);
</programlisting>

<para>Note that when an object is created, its attributes are taken from the current style. For example, you may have created a histogram in a previous session and saved it in a file. Meanwhile, if you have changed the style, the histogram will be drawn with the old attributes. You can force the current style attributes to be set when you read an object from a file by calling <code>ForceStyle</code> before reading the objects from the file.</para>

<programlisting language="c++">gROOT-&gt;ForceStyle();
</programlisting>

<para>When you call <code>gROOT-&gt;ForceStyle()</code> and read an object from a ROOT file, the object's method <code>UseCurrentStyle</code> is called. The attributes saved with the object are replaced by the current style attributes. You call also call <code>myObject-&gt;UseCurrentStyle()</code>         directly. For example if you have a canvas or pad with your histogram or any other object, you can force these objects to get the attributes of the current style by:</para>

<programlisting language="c++">canvas-&gt;UseCurrentStyle();
</programlisting>

<para>The description of the style functions should be clear from the name of the <emphasis role="bold"><code>TStyle</code></emphasis> setters or getters. Some functions have an extended description, in particular:</para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>TStyle</code></emphasis><code>::SetLabelFont</code></para></listitem>
<listitem><para><emphasis role="bold"><code>TStyle</code></emphasis><code>::SetLineStyleString</code>: set the format of dashed lines.</para></listitem>
<listitem><para><emphasis role="bold"><code>TStyle</code></emphasis><code>::SetOptStat</code></para></listitem>
<listitem><para><emphasis role="bold"><code>TStyle</code></emphasis><code>::SetPalette</code>  to change the colors palette</para></listitem>
<listitem><para><emphasis role="bold"><code>TStyle</code></emphasis><code>::SetTitleOffset</code></para></listitem>
<listitem><para><emphasis role="bold"><code>TStyle</code></emphasis><code>::SetOptDate(Int_t optdate)</code> to support several date formats. If <code>optdate</code> is non-null, the current date/time will be printed in the canvas. The position of the date string can be controlled by: <code>optdate = 10*format </code>+<code> mode</code></para></listitem>
<listitem><para><code>mode = 1</code>   the date is printed in the bottom/left corner</para></listitem>
<listitem><para><code>mode = 2</code>   date is printed in the bottom/right corner</para></listitem>
<listitem><para><code>mode = 3</code>   date is printed in the top/right corner</para></listitem>
<listitem><para><code>format = 0</code> (default) date format is like: "Wed Sep 25 17:10:35 2002"</para></listitem>
<listitem><para><code>format = 1</code> date format is: "2002-09-25"</para></listitem>
<listitem><para><code>format = 2</code> date format is: "2002-09-25 17:10:35"</para></listitem>
</itemizedlist>
</sect1>

<sect1>
<title>3D Viewers</title>
<para>ROOT provides several viewers capable of displaying 3D content:</para>
<itemizedlist>
<listitem><para>the Pad – simple line drawing using <emphasis role="bold"><code>TPad</code></emphasis> and associated projection class <emphasis role="bold"><code>TView</code></emphasis>;</para></listitem>
<listitem><para>GL Viewer – high quality and performance viewer(See “The GL Viewer”);</para></listitem>
<listitem><para>X3D viewer – simple legacy viewer (See “The X3D Viewer”);</para></listitem>
<listitem><para>GL-in-pad – combination of basic GL viewer in <emphasis role="bold"><code>TPad</code></emphasis>, with no hardware acceleration.</para></listitem>
</itemizedlist>
<para>The X3D and GL viewers are created as external windows, associated with a pad, and displaying the same content as it. Only these external viewers are detailed here – for Pad (<emphasis role="bold"><code>TPad</code></emphasis>, <emphasis role="bold"><code>TView</code></emphasis> classes) you should refer to “Graphical Containers: Canvas and Pad” and the class definitions.</para>
<para>All viewers use a common architecture to publish 3D objects to the viewer - described in “Common 3D Viewer Architecture” below. In most cases, you will <emphasis role="bold">not</emphasis> need to use this, working instead with a package, such as the “The Geometry Package”, which provides comprehensive, high level functionality to create and place objects into complex 3D scenes, and uses the viewer architecture internally to show the result in your chosen viewer.</para>

<sect2>
<title>Invoking a 3D viewer</title>
<para>A 3D viewer can be created in a script by passing the appropriate option to <code>Draw() </code>when attaching the drawn object(s) to a pad. For a fuller explanation of pads, attaching objects with <code>Draw()</code> etc. refer to “Graphical Containers: Canvas and Pad”.</para>

<programlisting language="c++">root[] <emphasis role="bold"><code>myShapes-&gt;Draw(“ogl”);</code></emphasis>
</programlisting>

<para>Valid option strings are:</para>
<itemizedlist>
<listitem><para>“<code>ogl</code>” : external GL viewer</para></listitem>
<listitem><para>“<code>x3d</code>”: external X3D viewer</para></listitem>
<listitem><para>“<code>pad</code>”: pad viewer</para></listitem>
</itemizedlist>
<para>If no option is passed to <code>Draw()</code> then the “<code>pad</code>” is used by default. If you already have content in a pad, which you would like to display in one of the external viewers you can select from the canvas View menu / View With, and pick the viewer type.</para>

<figure><title>Invoking external 3D viewers from canvas menus</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000D9.png" width="343.85pt" depth="171.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>Note: A current limitation means that when an external viewer is created the pad is no longer redrawn. When the external viewer is closed, clicking in the pad will refresh.</para>
</sect2>

<sect2>
<title>The GL Viewer</title>
<para>The GL Viewer uses  <uri xmlns:xlink="http://www.opengl.org/">OpenGL®</uri> (or compliant libraries such as  <uri xmlns:xlink="http://www.mesa3d.org/">Mesa3D</uri>) to generate high quality, high-performance 3D renderings, with sophisticated lighting, materials and rendering styles for 3D scenes. Many users will be able to take advantage of hardware acceleration of the underlying OpenGL commands by their computer's video card, resulting is considerable performance gains – up to interactive manipulation of 1000’s of complex shapes in real-time.</para>
<para>The GL Viewer is supported on all official ROOT platforms (assuming you have suitable  <uri xmlns:xlink="http://www.opengl.org/">OpenGL®</uri> libraries), and is the main 3D viewer, which development effort is concentrated upon. As OpenGL® is a trademark we refer to our viewer built on this technology as the ‘GL Viewer’. The code for it can be found under <code>$ROOTSYS/gl</code>.</para>

<figure><title>The GL 3D Viewer</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000DA.jpg" width="362.5pt" depth="233.4pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>You can manipulate the viewer via the GUI or via the base <emphasis role="bold"><code>TGLViewer</code></emphasis> object behind the interface. These are detailed below - see also <code>$ROOTSYS/tutorials/gl/glViewerExercise.C</code>.</para>

<sect3>
<title>Projections Modes (Cameras)</title>
<para>The GL Viewer supports two basic types of camera, which affect how the 3D world is projected onto the 2D render area:</para>
<itemizedlist>
<listitem><para>Perspective: Objects are drawn with characteristic ‘foreshortening’ effect, where distant objects appear smaller than near ones. This is useful for obtaining a ‘real world’ views. The degree of foreshortening is affected by the current camera field of view (focal length of its ‘lens’) – see “Adjusting Cameras”.</para></listitem>
<listitem><para>Orthographic: Distance from camera does not affect object size. These projections are useful for measurement or checking alignments, as the sizes and angles between objects are preserved.</para></listitem>
</itemizedlist>
<para>You can select the active camera from the viewer's Camera menu on the top menu bar. There are three perspective camera choices:</para>
<itemizedlist>
<listitem><para>Perspective (Floor XOZ) Default</para></listitem>
<listitem><para>Perspective (Floor YOZ)</para></listitem>
<listitem><para>Perspective (Floor XOY)</para></listitem>
</itemizedlist>
<para>In each case the perspective camera is constrained to keep the chosen floor plane, defined by a pair of world axes, appearing level at all times – i.e. there is no banking of the ‘horizon’ that you experience when a plane rolls. There are also three orthographic camera choices:</para>
<itemizedlist>
<listitem><para>Orthographic (XOY)</para></listitem>
<listitem><para>Orthographic (XOZ)</para></listitem>
<listitem><para>Orthographic (ZOY)</para></listitem>
</itemizedlist>
<para>Orthographic projections are generally constrained to look down one of the global axes of the world, with the other two axes lying horizontal/vertical on the viewer window. Therefore, XOY has the X-axis horizontal, the Y-axis vertical. You can always confirm the orientation and constraints of the camera in the world by enabling axis drawing in the “Guides” tab – see sections “Guides” and “Clipping” below. For orthographic camera a ruler-depicting current scene units is also available.</para>
<para>You can also pick the current camera by obtaining a handle to the GL Viewer object behind the interface:</para>

<programlisting language="c++">TGLViewer * v = (TGLViewer *)gPad-&gt;GetViewer3D();
</programlisting>

<para>calling the method <emphasis role="bold"><code>TGLViewer</code></emphasis><code>::SetCurrentCamera</code> with one of the <emphasis role="bold"><code>TGLViewer</code></emphasis><code>::ECameraType</code> types:</para>

<programlisting language="c++">v-&gt;SetCurrentCamera(TGLViewer::kCameraPerspXOZ);
</programlisting>

<para>See also <code>$ROOTSYS/tutorials/gl/glViewerExercise.C</code>.</para>
</sect3>

<sect3>
<title>Adjusting Cameras</title>
<para>The interactions with the camera are summarized above. In each case the interaction is listed, along with description and user actions required to achieve it. For all cameras you can reset the original default view, framing the entire scene, by double clicking any mouse button.</para>

<figure><title>GL Viewer camera interactions</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000DB.jpg" width="333.3pt" depth="235.25pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para/>
<para>For the Zoom interaction you can use the following modifiers combinations to adjust the sensitivity:</para>
<itemizedlist>
<listitem><para>Shiftx 10</para></listitem>
<listitem><para>Ctrlx 0.1</para></listitem>
<listitem><para>Shift + Ctrlx 0.01</para></listitem>
</itemizedlist>
<para>The modifiers must be applied after the zoom action has started (right mouse button is down).</para>
<para>Note for orthographic cameras:</para>
<itemizedlist>
<listitem><para>There is no field of view of view/focal length – dollying and zooming producing an identical scaling action.</para></listitem>
<listitem><para>There is a fixed eye direction – so the ‘Orbit’ action is disabled.</para></listitem>
</itemizedlist>
<para>Note for perspective cameras:</para>
<itemizedlist>
<listitem><para>Dollying (moving the camera backwards/forwards) and zooming are often confused, and may appear very similar.</para></listitem>
<listitem><para>When you dolly the camera the lens focal length does not change, hence the distortions associated with the projections are unaffected. However the movement can result in objects coming ‘through the front’ of the camera and disappearing.</para></listitem>
<listitem><para>When you zoom, the camera does not move – hence clipping of near objects is unaffected. However with extremely small zooms (FOV large/focal length short) noticeable distortions, causing straight lines to become curved, can be seen with objects near the camera – the ‘fisheye’ lens effect.</para></listitem>
<listitem><para>Generally dollying is more ‘natural’, but you may need to use both to achieve the desired perspective and eye position – particularly when you are working inside or very close to 3D objects.</para></listitem>
</itemizedlist>
<para>Configure the camera by calling the methods <code>SetPerspectiveCamera(</code>) or <code>SetOrthographicCamera()</code> of <emphasis role="bold"><code>TGLViewer</code></emphasis>:</para>

<programlisting language="c++">TGLViewer * v = (TGLViewer *)gPad-&gt;GetViewer3D();
v-&gt;SetOrthoCamera(TGLViewer::kCameraOrthoXOY,left,right,top,bottom);
...
v-&gt;SetPerspectiveCamera (camera,fov,dolly,center,hRotate,vRotate);
</programlisting>

<para>Note – you can configure any of the six cameras in the viewer at any time, but you will not see the result until the camera is made current.</para>
</sect3>

<sect3>
<title>Draw Styles</title>
<para>The GL Viewer supports three different rendering modes, which are applied to all the objects in your scene, but not Clip Shapes and Guides (See “Clipping” and “Manipulators”). These are shown below, along with the key used to activate the style.</para>

<figure><title>GL Viewer draw styles</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000DC.jpg" width="434.5pt" depth="119.8pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para><emphasis role="bold">Filled Polygons</emphasis>        <emphasis role="bold">Wireframe</emphasis>   <emphasis role="bold">Outline</emphasis>
Enable with ‘r’ key                                     Enable with ‘w’ key                      Enable with ‘t’ key
Solid polygons, with hidden surface        Object edges in color, with   Combination of Filled Polygons
removal, color surface materials,         no surface filling/hiding.   and Outline styles. Solid
opacity, specular reflection etc.       shapes with edges.
Black background.         Black background.   White background.
</para>
<para>Call method <emphasis role="bold"><code>TGLViewer</code></emphasis><code>::SetStyle</code> with one of <emphasis role="bold"><code>TGL</code></emphasis><emphasis role="bold"><code>RnrCtx</code></emphasis><code>::EDrawStyle </code>flags <code>kFill</code>, <code>kOutline</code>, <code>kWireFrame</code>:</para>

<programlisting language="c++">v-&gt;SetStyle(TGLRnrCtx::kFill);
</programlisting>

</sect3>

<sect3>
<title>Lighting / Style</title>
<para>The GL viewer creates five diffuse lights (left, right, top, bottom, and front) arranged around the 3D scene. These lights are carried with the camera – that is they are always in same position relative to your eye – the left light always shines from the left.</para>
<para>Light controls are located: Viewer Controls Pane  ‘Style’.</para>
<para>Each light has a checkbox to enable/disable it. Set lights on/off with <emphasis role="bold"><code>TGL</code></emphasis><emphasis role="bold"><code>LightSet</code></emphasis><code>::SetLight</code> e.g.</para>

<programlisting language="c++">v-&gt;GetLightSet()-&gt;SetLight(<emphasis role="bold"><code>TGL</code></emphasis><emphasis role="bold"><code>LightSet</code></emphasis>::kLightBottom, kFALSE);
</programlisting>

</sect3>

<sect3>
<title>Clipping</title>
<para>The GL viewer supports interactive clipping, enabling you to remove sections of your 3D scene and the shapes, revealing internal details.</para>

<figure><title>GL Viewer interactive box clipping</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020000DD.jpg" width="289.25pt" depth="237.7pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The controls for clipping can be found under: Viewer Controls Pane  ‘Clipping’ tab.</para>
<para>Two clipping ‘shapes’ are currently supported:</para>
<itemizedlist>
<listitem><para>Single plane</para></listitem>
<listitem><para>Box</para></listitem>
</itemizedlist>
<para>Pick the type from the radio buttons – only one (or none) may be active at one time.</para>
<para>The clip object can be adjusted by:</para>
<itemizedlist>
<listitem><para>Adjusting the values in the properties panel GUI</para></listitem>
<listitem><para>Directly manipulating the clip object in the viewer</para></listitem>
</itemizedlist>
<para>To show and/or directly manipulate the object check the ‘Show / Edit in Viewer’ checkbox. The clip object is drawn in semi-transparent light brown. The current manipulator is attached to it, allowing you direct control over its position, scale and rotation. See “Manipulators” section below for details on using viewer manipulators.</para>
<para>The clip plane is described by the standard plane equation: <emphasis role="bold"><code>ax+by+cz+d=</code></emphasis><emphasis role="bold"><code>0</code></emphasis>, where the factors <emphasis role="bold"><code>a</code></emphasis>, <emphasis role="bold"><code>b</code></emphasis>, <emphasis role="bold"><code>c</code></emphasis>, <emphasis role="bold"><code>d</code></emphasis> are entered into the edit boxes, and applied using the ‘Apply’ button.</para>
<para>The clip box is described by its center position, entered in the ‘Center X’, ‘Center Y’ and ‘Center Z’ edit boxes, and its lengths (extents) entered in the ‘Length X’, ‘Length Y’ and ‘Length Z’ edit boxes.</para>
<para>This clipping is achieved using OpenGL clip plane support; as such, there are certain limitations:</para>
<itemizedlist>
<listitem><para>Solid shapes are not capped – they appear hollow.</para></listitem>
<listitem><para>Only shapes, which can be described with combination of planes, can be rendered in this fashion – e.g. a clipping tube is not possible.</para></listitem>
<listitem><para>Each additional clipping plane requires an additional render pass – so the more active planes the more time the render will take.</para></listitem>
</itemizedlist>
<para>Set the current clip object with <emphasis role="bold"><code>TGL</code></emphasis><emphasis role="bold"><code>ClipSet</code></emphasis><code>::SetClipType</code></para>

<programlisting language="c++">v-&gt;GetClipSet()-&gt;SetClipType(<emphasis role="bold"><code>TGL</code></emphasis><emphasis role="bold"><code>ClipSet</code></emphasis>::kClipPlane);
</programlisting>

<para>Configure the clip object with <emphasis role="bold"><code>TGL</code></emphasis><emphasis role="bold"><code>ClipSet</code></emphasis><code>::SetClipState</code></para>

<programlisting language="c++">Double_t planeEq[4] = {0.5,1.0,-1.0, 2.0};
v-&gt;GetClipSet()-&gt;SetClipState(<emphasis role="bold"><code>TGL</code></emphasis><emphasis role="bold"><code>ClipSet</code></emphasis>::kClipPlane, planeEq);
</programlisting>

<para>As with cameras, any clip can be configured at any time, but you must set the clip current to see the effect.</para>
</sect3>

<sect3>
<title>Manipulators</title>
<para><emphasis role="italic">Manipulators</emphasis> are GUI ‘widgets’ or controls attached to a 3D object in the viewer, allowing a direct manipulation of the object's geometry. There are three manipulators for the three basic geometries transformations. In each case, the <emphasis role="italic">manipulator</emphasis> consists of three components, one for each local axis of the object, shown in standard colors: red (X), green (Y) and blue (Z).</para>

<figure><title>GL Viewer object manipulators</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000DE.png" width="398.5pt" depth="301.05pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>Activate the <emphasis role="italic">manipulator</emphasis> by moving the mouse over one of these components (which turns yellow to indicate active state). Click with left mouse and drag this active component to perform the manipulation. Toggle between the <emphasis role="italic">manipulator</emphasis> types using the ‘x’, ‘c’, ‘v’ keys while the mouse cursoris above the manipulator. Note: Manipulators cannot be controlled via the API at present.</para>
</sect3>

<sect3>
<title>Guides</title>
<para>Guides are visual aids drawn into the viewer world. Controls for these are under the “Guides”  tab:</para>
<para>Viewer Controls Pane Guides Tab</para>
<para>Axes show the world (global) frame <emphasis role="italic">coordinate </emphasis>directions: X (red), Y (green) and Z (blue). The negative portion of the <emphasis role="italic">axis</emphasis> line is shown in dark color, the positive in bright. The <emphasis role="italic">axis</emphasis> name and minimum / maximum values are labeled in the same color. There are three options for <emphasis role="italic">axes</emphasis> drawing – selected by radio buttons:</para>
<itemizedlist>
<listitem><para>None – not drawn (default).</para></listitem>
<listitem><para>Edge – draw axes on the (minimum) edge of the scene extents box.</para></listitem>
<listitem><para>Origin – drawn axes through the origin.</para></listitem>
</itemizedlist>
<para>For <emphasis role="italic">edge axes</emphasis>, the zero value for each axis is marked on the axis line with a colored sphere. For <emphasis role="italic">origin axes,</emphasis> a single white sphere is shown at the origin.</para>
<para><emphasis role="italic">Edge axes</emphasis> are depth clipped – i.e. are obscured by 3D objects in front of them. <emphasis role="italic">Origin axes</emphasis> (which generally pass through the middle of the 3D scene) are not depth clipped – so always visible.</para>
<para>A single orange sphere of fixed view port (window) size can be shown at any arbitrary position. Enable / disable the drawing with ‘<emphasis role="italic">Show’</emphasis> checkbox. Enter X/Y/Z position in the edit boxes to set position. Initial position is at the center of the scene.</para>
<para>Set the guides using <emphasis role="bold"><code>TGLViewer</code></emphasis><code>::SetGuideState</code> e.g. to enable edge axes, and enable a reference marker at world position 50, 60, 100:</para>

<programlisting language="c++">Double_t refPos[3] = {50.0,60.0,100.0};
v-&gt;SetGuideState(TGLUtil::kAxesEdge, kTRUE, refPos);
</programlisting>

</sect3>

<sect3>
<title>Selecting Scene Shapes</title>
<para>You can select a single shape from your scene by pressing ‘Shift’ key, pointing and left clicking anywhere on the shape in the viewer. Selection is currently shown by drawing the shape-bounding box (not depth clipped) in white (polygon or wire frame render styles) or red (outline render style). Manipulators supported by the shape are drawn in red, green and blue while the non-supported ones are drawn in grey. To deselect a shape, either select another, or shift/click anywhere on the background (empty space) in the viewer. You cannot select Manipulators or Guides (Axes / Reference Marker).</para>
</sect3>

<sect3>
<title>Editing Shapes</title>
<para>When a shape is selected, the viewer's control pane shows the user interface that allows you to review and adjust the color and geometry properties of the shape.</para>
<para>Note: At present modifications to the shapes are local to the viewer – they are not propagated back to external objects/client that published to the viewer. The changes are preserved only until the viewer is closed. In some cases, this will never be feasible as there is not a one-to-one correspondence between a shape in the viewer and a single external object in which the modification could be stored.</para>
</sect3>

<sect3>
<title>Colors / Style</title>
<para>Viewer Controls Pane  ‘Style’ tab.</para>
<para>A full description of OpenGL materials, colors and lighting is beyond the scope of this document. You should refer to the OpenGL programming manual (Red Book) for a full discussion. In most cases adjustment of the Diffuse color material + Opacity/Shine properties is sufficient to achieve desired results.</para>
<para>A shape has four-color materials (components):</para>
<itemizedlist>
<listitem><para>Diffuse</para></listitem>
<listitem><para>Ambient</para></listitem>
<listitem><para>Specular</para></listitem>
<listitem><para>Emissive</para></listitem>
</itemizedlist>
<para>For each of these you can select the component via the radio buttons. Each component can have the red, green and blue values for the component adjusted via the sliders. You can apply this adjustment to the shape itself, or to all shapes sharing a common ‘family’. Shapes of the same family have external objects with the same <emphasis role="bold"><code>TObject</code></emphasis> name string. You can also adjust the ‘Opacity’ and ‘Shine’ for the shapes materials via the sliders.</para>
</sect3>

<sect3>
<title>Geometry</title>
<para>Viewer Controls Pane  ‘Geometry’ tab.</para>
<para>Review and modify the shapes X/Y/Z center and scaling factors via the edit boxes. Selection and editing of shapes is not available via the API at present.</para>
</sect3>

<sect3>
<title>Outputting Viewer Contents</title>
<para>The current viewer rendering can be output to an external <code>EPS</code> or <code>PDF</code>, using the options under the ‘File’ menu on the top menu bar. The file is named ‘<code>viewer.eps</code>’ or ‘<code>viewer.pdf</code>’ and written to the current ROOT directory.</para>
</sect3>
</sect2>

<sect2>
<title>The X3D Viewer</title>
<para>The X3D viewer is a fairly simple and limited viewer, capable of showing basic lines and polygons. It lacks the quality, performance and more advanced features of the GL Viewer, and additionally is not supported on Windows. It is not actively developed and you are encouraged to use the GL Viewer out of preference. The below table presents the main interactions – these are repeated in the Help dialog of the viewer.</para>
<para>Action  KeyActionKey</para>
<para>Wireframe Mode  wRotate about xx a</para>
<para>Hidden Line Mode  eRotate about yy b</para>
<para>Hidden Surface Mode  rRotate about zz c</para>
<para>Move object down  uAuto-rotate about x1 2 3</para>
<para>Move object up  iAuto-rotate about y4 5 6</para>
<para>Move object left  lAuto-rotate about z7 8 9</para>
<para>Move object right  hToggle controls styleo</para>
<para>Move object forward  jToggle stereo displays</para>
<para>Move object backward  kToggle blue stereo viewd</para>
<para>Adjust focus (stereo mode)  [ ] { }Toggle double bufferf</para>
<para>Rotate object  Left mouse button down + move.</para>
</sect2>

<sect2>
<title>Common 3D Viewer Architecture</title>
<para>The 3D Viewer Architecture provides a common mechanism for viewer clients to publish 3D objects to it. It enables:</para>
<itemizedlist>
<listitem><para>Decoupling of producers (geometry packages etc) who model collection of 3D objects from consumers (viewers) which display them.</para></listitem>
<listitem><para>Producer code free of explicit drawing commands &amp; viewer specific branching.</para></listitem>
<listitem><para>Support differing viewers and clients capabilities, e.g.</para></listitem>
<listitem><para>Mix of native (in viewer) shapes and generic client side tessellation.</para></listitem>
<listitem><para>Local/global frame object description</para></listitem>
<listitem><para>Bounding boxes</para></listitem>
<listitem><para>Placing copies sharing common geometry (logical/physical shapes).</para></listitem>
</itemizedlist>
<para>The architecture consists of:</para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>TVirtualViewer3D</code></emphasis> interface: An abstract handle to the viewer, allowing client to add objects, test preferences etc.</para></listitem>
<listitem><para><emphasis role="bold"><code>TBuffer3D</code></emphasis> class hierarchy: Used to describe 3D objects ("shapes") - filled /added by negotiation with viewer via <emphasis role="bold"><code>TVirtualViewer3D</code></emphasis>.</para></listitem>
</itemizedlist>
<para>A typical interaction between viewer and client using these, taken from <emphasis role="bold"><code>TGeoPainter</code></emphasis> is:</para>

<programlisting language="c++">
TVirtualViewer3D * viewer = gPad-&gt;GetViewer3D();
<emphasis role="italic"><code>// Does viewer prefer local frame positions?</code></emphasis>
Bool_t localFrame = viewer-&gt;PreferLocalFrame();
<emphasis role="italic"><code>// Perform first fetch of buffer from the shape and try adding it to the viewer</code></emphasis>
const TBuffer3D &amp;buffer = shape.GetBuffer3D(TBuffer3D::kCore |
TBuffer3D::kBoundingBox |
TBuffer3D::kShapeSpecific,
localFrame);
Int_t reqSections = viewer-&gt;AddObject(buffer, &amp;addDaughters);

<emphasis role="italic"><code>// If the viewer requires additional sections fetch from the shape </code></emphasis>
<emphasis role="italic"><code>// (if possible) and add again</code></emphasis>
if (reqSections != TBuffer3D::kNone)
shape.GetBuffer3D(reqSections, localFrame);
</programlisting>

<para>Together these allow clients to publish objects to any one of the 3D viewers free of viewer specific drawing code. They allow our simple x3d viewer, and considerably more sophisticated OpenGL one to both work with both geometry libraries (<code>g3d</code> and <code>geom</code>) efficiently.</para>
<para>In addition to external viewers, created in separate windows, this architecture is also used by internal <emphasis role="bold"><code>TPad</code></emphasis> drawing when it requires 3D projections. Publishing to a viewer consists of the following steps:</para>
<para>   1. Create / obtain viewer handle.</para>
<para>   2. Begin scene on viewer.</para>
<para>   3. Fill mandatory parts of TBuffer3D describing object.</para>
<para>   4. Add to viewer.</para>
<para>   5. Fill optional parts of TBuffer3D as requested by viewer.</para>
<para>        [ .... repeat 3/4/5 as required for other/child objects]</para>
<para>   6. End scene on viewer.</para>
<para>You should attach the top-level node of your external geometry (or the manager) to a <emphasis role="bold"><code>TPad</code></emphasis> object using <emphasis role="bold"><code>TObject</code></emphasis><code>::Draw()</code>, and perform the publishing to the viewer in your object's <emphasis role="bold"><code>TObject</code></emphasis><code>::Paint()</code> overloaded method. See “Scene Rebuilds”, and example scripts, for more details.</para>

<sect3>
<title>Creating / Obtaining Viewer Handle</title>
<para>External viewers are bound to a <emphasis role="bold"><code>TPad</code></emphasis> object (this may be removed as a requirement in the future). You can create or obtain the current viewer handle via the method:</para>

<programlisting language="c++">TVirtualViewer3D * v = gPad-&gt;GetViewer3D("type");
</programlisting>

<para>Here the “type” string defines the viewer type – currently one of:</para>
<itemizedlist>
<listitem><para>“<code>ogl</code>” : External GL viewer</para></listitem>
<listitem><para>“<code>x3d</code>”: External X3D viewer</para></listitem>
<listitem><para>“<code>pad</code>”: Pad viewer</para></listitem>
</itemizedlist>
<para>If no type is passed (null string), and there is no current viewer, then the type is defaulted to “<code>pad</code>”. If no type is passed and there is a current viewer, then this is returned – hence once a viewer is created it can be obtained elsewhere by:</para>

<programlisting language="c++">TVirtualViewer3D * v = gPad-&gt;GetViewer3D();
</programlisting>

</sect3>

<sect3>
<title>Opening / Closing Scenes</title>
<para>Objects must be added to viewer between <code>BeginScene()</code> and
<code>EndScene()</code> calls e.g.</para>

<programlisting language="c++">viewer-&gt;BeginScene();
<emphasis role="italic">// Add objects</emphasis>
viewer -&gt;EndScene();
</programlisting>

<para>These calls enable the viewer to suspend redraws, and perform internal
caching/setup. If the object you attach to the pad derives from
<emphasis role="bold"><code>TAtt3D</code></emphasis>, then the pad will take
responsibility for calling <code>BeginScene()</code> and <code>EndScene()</code>
for you. You can always test if the scene is already open for object addition
with:</para>

<programlisting language="c++">viewer-&gt;BuildingScene();
</programlisting>

<figure><title>Overview of 3D viewer architecture</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000DF.png" width="307.85pt" depth="247.65pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>Note: the x3d viewer does not support rebuilding of scenes - objects added after the first Open/Close Scene pair will be ignored.</para>
</sect3>

<sect3>
<title>Describing Objects - Filling TBuffer3D</title>
<para>The viewers behind the <emphasis role="bold"><code>TVirtualViewer3D</code></emphasis> interface differ greatly in their capabilities e.g.</para>
<itemizedlist>
<listitem><para>Some support native shape (e.g. spheres/tubes in OpenGL) and can draw these based on an abstract description. Others always require a tessellation description based on <emphasis role="bold"><code>TBuffer3D</code></emphasis>’s <code>kRaw</code>         / <code>kRawSizes</code> points/lines/segments sections.</para></listitem>
<listitem><para>Some need the 3D object positions in the master (world) frame, others can cope with local frames and a translation matrix to place the object.</para></listitem>
<listitem><para>Some require bounding boxes for objects – others do not.</para></listitem>
</itemizedlist>
<para>Similarly some viewer clients are only capable of providing positions in master frame, cannot provide bounding boxes etc. Additionally we do not want to incur the cost of expensive tessellation operations if the viewer does not require them. To cope with these variations the <emphasis role="bold"><code>TBuffer3D</code></emphasis> objects are filled by negotiation with the viewer.</para>

<figure><title>TBuffer3D class hierarchy</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030000E0.png" width="302.9pt" depth="333.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para/>
<para><emphasis role="bold"><code>TBuffer3D</code></emphasis> classes are conceptually divided into enumerated sections: <code>kCore</code>, <code>kBoundingBox</code>, <code>kRaw</code> – see the class diagram and the file <code>TBuffer3D.h</code> for more details. The <emphasis role="bold"><code>TBuffer3D</code></emphasis> methods <code>SectionsValid()</code>, <code>SetSectionsValid()</code>, <code>ClearSectionsValid()</code> are used to test, set, clear these section validity flags e.g.</para>

<programlisting language="c++">buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);
…
if (buffer.SectionsValid(TBuffer3D:: kShapeSpecific)) {
   …
}
</programlisting>

<para>The sections found in the base <emphasis role="bold"><code>TBuffer3D</code></emphasis> (<code>kCore/kBoundingBox/kRawSizes/kRaw</code>) are sufficient to describe any tessellated shape in a generic fashion. An additional <code>kShapeSpecific</code> section is added in <emphasis role="bold"><code>TBuffer3D</code></emphasis> derived classes, allowing a more abstract shape description ("a sphere of inner radius x, outer radius y"). This enables a viewer, which knows how to draw (tessellate) the shape itself to do so, while providing a generic fallback suitable for all viewers. The rules for client negotiation with the viewer are:</para>
<itemizedlist>
<listitem><para>If suitable specialized <emphasis role="bold"><code>TBuffer3D</code></emphasis> class exists, use it, otherwise use <emphasis role="bold"><code>TBuffer3D</code></emphasis>.</para></listitem>
<listitem><para>Complete the mandatory <code>kCore</code> section.</para></listitem>
<listitem><para>Complete the <code>kShapeSpecific</code> section if applicable.</para></listitem>
<listitem><para>Complete the <code>kBoundingBox</code> if you can.</para></listitem>
<listitem><para>Pass this buffer to the viewer using one of the <emphasis role="bold"><code>TBuffer3D</code></emphasis><code>::AddObject()</code> methods.</para></listitem>
</itemizedlist>
<para>If the viewer requires more sections to be completed (<code>kRaw/kRawSizes</code>) <emphasis role="bold"><code>TBuffer3D</code></emphasis><code>::AddObject()</code> will return flags indicating which ones, otherwise it returns <code>kNone</code>. If requested, you must fill the buffer, mark these sections valid, and call <emphasis role="bold"><code>TBuffer3D</code></emphasis><code>::AddObject</code> again, to complete adding the object. For example, in out <emphasis role="bold"><code>TGeo</code></emphasis> geometry package, in <emphasis role="bold"><code>TGeoPainter</code></emphasis><code>::PaintShape</code>, we perform the negotiation with viewer:</para>

<programlisting language="c++">TVirtualViewer3D * viewer = gPad-&gt;GetViewer3D();
if (shape.IsA() != TGeoCompositeShape::Class()) {
<emphasis role="italic"><code>   // Does viewer prefer local frame positions?</code></emphasis>
Bool_t localFrame = viewer-&gt;PreferLocalFrame();
<emphasis role="italic"><code>   // Perform first fetch of buffer from the shape and adding it to the viewer</code></emphasis>
const TBuffer3D &amp;buffer = shape.GetBuffer3D(TBuffer3D::kCore |
TBuffer3D::kBoundingBox |
TBuffer3D::kShapeSpecific
,localFrame);
Int_t reqSections = viewer-&gt;AddObject(buffer, &amp;addDaughters);
<emphasis role="italic"><code>   // If the viewer requires additional sections fetch from the shape </code></emphasis>
<emphasis role="italic"><code>// (if possible) and add again</code></emphasis>
if (reqSections != TBuffer3D::kNone) {
shape.GetBuffer3D(reqSections, localFrame);
viewer-&gt;AddObject(buffer, &amp;addDaughters);
}
}
</programlisting>

<para>The buffer is supplied/filled by the appropriate <emphasis role="bold"><code>TShape</code></emphasis><code>::GetBuffer3D()</code> and <emphasis role="bold"><code>TShape</code></emphasis><code>::FillBuffer3D</code> overloads e.g. for a sphere in <emphasis role="bold"><code>TGeoSphere</code></emphasis>.</para>

<programlisting language="c++">const TBuffer3D &amp;TGeoSphere::GetBuffer3D(Int_t reqSections,
Bool_t localFrame) const {
<emphasis role="italic"><code>   // Fills a static 3D buffer and returns a reference.</code></emphasis>
static TBuffer3DSphere buffer;
<emphasis role="italic"><code>   // Filling of kBoundingBox is defered to TGeoBBox, and</code></emphasis>
<emphasis role="italic"><code>   // kCore on up to TGeoShape</code></emphasis>
TGeoBBox::FillBuffer3D(buffer, reqSections, localFrame);
<emphasis role="italic"><code>   // Complete kShapeSpecific section for sphere</code></emphasis>
if (reqSections &amp; TBuffer3D::kShapeSpecific) {
buffer.fRadiusInner  = fRmin;
buffer.fRadiusOuter  = fRmax;
…
buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);
}
<emphasis role="italic"><code>   // Complete kRawSizes section</code></emphasis>
if (reqSections &amp; TBuffer3D::kRawSizes) {
…
buffer.SetSectionsValid(TBuffer3D::kRawSizes);
}
}
<emphasis role="italic"><code>   // Complete kRaw tesselation section</code></emphasis>
if ((reqSections &amp; TBuffer3D::kRaw) &amp;&amp;
buffer.SectionsValid(TBuffer3D::kRawSizes)) {
SetPoints(buffer.fPnts);
<emphasis role="italic"><code>      // Transform points to master frame if viewer requires it</code></emphasis>
<emphasis role="italic"><code>      // The fLocalFrame flag and translation matrix will have already</code></emphasis>
<emphasis role="italic"><code>      // been set in TGeoShape::FillBuffer3D() as requried</code></emphasis>
if (!buffer.fLocalFrame)
TransformPoints(buffer.fPnts, buffer.NbPnts());
SetSegsAndPols(buffer);
buffer.SetSectionsValid(TBuffer3D::kRaw);
}
return buffer;
}
</programlisting>

<para>Note:</para>
<itemizedlist>
<listitem><para>we use a static <emphasis role="bold"><code>TBuffer3D</code></emphasis> derived object for efficiency – once the object is added the buffer can be reused.</para></listitem>
<listitem><para><code>kRawSize</code> (the calculation of tessellation sizing required in buffer) and <code>kRaw</code> (the actual filling of tessellation) is split, as the X3D viewer requires two publication passes – one to establish the full tessellation capacity for all shapes, and another to actually add them. Splitting avoids having to do the expensive tessellation on the first pass.</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Shape Specific TBuffer3D Derived Classes</title>
<para>Currently we provide the following shape specific classes, which the GL Viewer can take advantage of (see <code>TBuffer3D.h</code> and <code>TBuffer3DTypes.h</code>)</para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>TBuffer3DSphere</code></emphasis> - solid, hollow and cut spheres (GL Viewer only supports solid spheres at present – cut / hollow ones will be requested as tessellated objects by client.)</para></listitem>
<listitem><para><emphasis role="bold"><code>TBuffer3DTube</code></emphasis> – basic tube with inner/outer radius and length.</para></listitem>
<listitem><para><emphasis role="bold"><code>TBuffer3DTubeSeg</code></emphasis> - angle tube segment.</para></listitem>
<listitem><para><emphasis role="bold"><code>TBuffer3DCutTube</code></emphasis> - angle tube segment with plane cut ends.</para></listitem>
</itemizedlist>
<para>See the above example from <emphasis role="bold"><code>TGeoSphere</code></emphasis><code>::GetBuffer3D</code> and also equivalent functions in <emphasis role="bold"><code>TGeoTube</code></emphasis>, <emphasis role="bold"><code>TGeoTubeSeg</code></emphasis> and <emphasis role="bold"><code>TGeoCtub</code></emphasis>. Anyone is free to add new <emphasis role="bold"><code>TBuffer3D</code></emphasis> classes, but it should be clear that one or more viewers will require updating to be able to take advantage of them. Hence we only provide classes which existing viewers can benefit from. The number of native shapes in GL Viewer will be expanded in the future.</para>
</sect3>

<sect3>
<title>Master / Local Reference Frames</title>
<para>The Core section of <emphasis role="bold"><code>TBuffer3D</code></emphasis> contains two members relating to reference frames:</para>
<itemizedlist>
<listitem><para><code>fLocalFrame</code>: indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local or master (world frame).</para></listitem>
<listitem><para><code>fLocalMaster</code>: is a standard 4x4 translation matrix (OpenGL column major ordering) for placing the object into the 3D master frame.</para></listitem>
</itemizedlist>
<para>If <code>fLocalFrame</code> is false, <code>fLocalMaster</code> should contain an identity matrix. This is set by default, and can be reset using the <emphasis role="bold"><code>TBuffer3D</code></emphasis><code>::SetLocalMasterIdentity()</code> method.</para>
</sect3>

<sect3>
<title>Bounding Boxes</title>
<para>You are not obliged to complete the <code>kBoundingBox</code> section, as any viewer requiring one internally (GL Viewer) will build it if you do not provide. However to do this the viewer will force you to provide the (expensive) raw tessellation, and the resulting box will be axis aligned with the overall scene, which is non-ideal for rotated shapes. As we need to support orientated (rotated) bounding boxes, <emphasis role="bold"><code>TBuffer3D</code></emphasis> requires the 6 vertices of the box. We also provide a convenience function, <emphasis role="bold"><code>TBuffer</code></emphasis><code>::SetAABoundingBox()</code>, for simpler case of setting an axis aligned bounding box. The bounding box should be filled in same frame (local / master) as the rest of the <emphasis role="bold"><code>TBuffer3D</code></emphasis>, and inaccordance with <code>fLocalFrame</code> flag.</para>
<para>A typical example from TGeoBBox::FillBuffer3D:</para>

<programlisting language="c++">if (reqSections &amp; TBuffer3D::kBoundingBox) {
Double_t halfLengths[3] = { fDX, fDY, fDZ };
buffer.SetAABoundingBox(fOrigin, halfLengths);
if (!buffer.fLocalFrame) {
TransformPoints(buffer.fBBVertex[0], 8);
}
buffer.SetSectionsValid(TBuffer3D::kBoundingBox);
}
</programlisting>

</sect3>

<sect3>
<title>Logical and Physical Objects</title>
<para>Some viewers can support two types of object placement:</para>
<itemizedlist>
<listitem><para>Add object as a single independent entity in the world reference frame – e.g. a sphere, radius <code>r</code>, at <code>x</code>, <code>y</code>, <code>z</code>.</para></listitem>
<listitem><para>Repeated placement (copying) in world frame of this locally unique piece of geometry (described in local reference frame) e.g. define a sphere <code>S</code> (radius <code>r</code>), place copy at <code>x1</code>, <code>y1</code>, <code>z1</code>, another copy at <code>x2</code>, <code>y2</code>, <code>z2</code> etc.</para></listitem>
</itemizedlist>
<para>The second case is very typical in geometry packages, e.g. ROOT’s <emphasis role="bold"><code>TGeo</code></emphasis> package, GEANT4 etc, where we have very large number repeated placements of relatively few unique “shapes”.</para>
<para>Some viewers (GL Viewer only at present) are able to take advantage of this by identifying unique logical shapes from the <code>fID</code> logical ID member of <emphasis role="bold"><code>TBuffer3D</code></emphasis>. If repeated addition of the same <code>fID</code> is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching (display lists) with considerable performance gains in these cases. For this to work correctly the logical object in must be described in <emphasis role="bold"><code>TBuffer3D</code></emphasis> in the local reference frame, complete with the local<code>/</code>master translation. In some cases you will not have a real object you can reasonably set <emphasis role="bold"><code>TBuffer3D</code></emphasis><code>::fID</code> to, or the object is recycled or temporary. To suppress internal caching in the GL Viewer in these cases, set <emphasis role="bold"><code>TBuffer3D</code></emphasis><code>::fID</code> to 0 (null).</para>
<para>The viewer indicates it can support local frame objects through the <emphasis role="bold"><code>TVirtualViewer</code></emphasis><emphasis role="bold"><code>3D</code></emphasis> interface method: <code>PreferLocalFrame()</code>. If this returns <code>kTRUE</code> you can make repeated calls to <code>AddObject()</code>, with <emphasis role="bold"><code>TBuffer3D</code></emphasis> containing the same <code>fID</code>, and different <code>fLocalMaster</code> placements.</para>
<para>For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of the logical object, with the exception of:</para>
<itemizedlist>
<listitem><para><code>fLocalMaster</code> transform</para></listitem>
<listitem><para>    <code>fColor </code></para></listitem>
<listitem><para>    <code>fTransparency</code></para></listitem>
</itemizedlist>
<para> attributes, which can be varied for <emphasis role="bold">each</emphasis> physical object.</para>
<para>As <emphasis role="bold">a minimum requirement</emphasis> all clients must be capable of filling the raw tessellation of the object buffer, in the master reference frame. Conversely viewers must always be capable of displaying the object described by this buffer. If either does not meet this requirement the object may not be displayed.</para>
</sect3>

<sect3>
<title>Scene Rebuilds</title>
<para><emphasis role="bold"><code>TBuffer3D</code></emphasis><code>::AddObject</code> is not an explicit command to the viewer - it may for various reasons decide to ignore it:</para>
<itemizedlist>
<listitem><para>It already has the object internally cached.</para></listitem>
<listitem><para>The object falls outside some 'interest' limits of the viewer camera.</para></listitem>
<listitem><para>The object is too small to be worth drawing.</para></listitem>
</itemizedlist>
<para>In all these cases <emphasis role="bold"><code>TBuffer3D</code></emphasis><code>::AddObject()</code> returns kNone, as it does for successful addition, indicating it does not require further information about this object. Hence you should not try to make any assumptions about what the viewer did with the object. The viewer may decide to force the client to rebuild (republish) the scene, obtaining a different collection of objects, if the internal viewer state changes .e.g. significant camera move. It does this presently by forcing a repaint on the attached <emphasis role="bold"><code>TPad</code></emphasis> object – hence you should attach you master geometry object to the pad (via <emphasis role="bold"><code>TObject</code></emphasis><code>::Draw()</code>), and perform the publishing to the viewer in response to <emphasis role="bold"><code>TObject::Paint()</code></emphasis>.</para>
</sect3>

<sect3>
<title>Physical IDs</title>
<para>TVirtualViewer3D provides for two methods of object addition:</para>

<programlisting language="c++">virtual Int_t AddObject(const TBuffer3D &amp;buffer, Bool_t * addChildren = 0)
virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D &amp; buffer,
Bool_t *addChildren = 0)
</programlisting>

<para>If you use the first (simple) case a viewer using logical/physical pairs will generate sequential IDs for each physical object internally. Scene rebuilds will require destruction and recreation of all physical objects. For the second you can specify an identifier from the client side, which must be unique and stable – i.e. the IDs of a published object is consistent, regardless of changes in termination of contained child geometry branches. In this case the viewer can safely cache the physical objects across scene rebuilds, discarding those no longer of interest.</para>
</sect3>

<sect3>
<title>Child Objects</title>
<para>In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of siblings. Both <emphasis role="bold"><code>TBuffer3D</code></emphasis><code>::AddObject()</code> methods have an <code>addChildren</code> return parameter. The viewer will complete this (if passed) indicating if children of the object just sent are worth sending.</para>
</sect3>

<sect3>
<title>Recycling TBuffer3D</title>
<para>Once add <emphasis role="bold"><code>TBuffer3D</code></emphasis><code>::AddObject()</code> has been called, the contents are copied to the viewer’s internal data structures. You are free to destroy this <emphasis role="bold"><code>TBuffer3D</code></emphasis>, or recycle it for the next object if suitable.</para>
</sect3>

<sect3>
<title>Examples</title>
<para>For an example of a simple geometry, working in master reference frame examine the code under <code>$ROOTSYS/g3d</code>. For a more complex example, which works in both master and local frames, and uses logical<code>/</code>physical division of shape geometry and placement, examine the code under <code>$ROOTSYS/geom</code> – in particular <emphasis role="bold"><code>TGeoShape</code></emphasis> hierarchy, and the painter object <emphasis role="bold"><code>TGeoPainter</code></emphasis> (under geopainter) where the negotiation with the viewer is performed.</para>
</sect3>
</sect2>
</sect1>
</chapter>
