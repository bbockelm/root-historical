<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0">
<title>The Geometry Package</title>
<para>The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.</para>

<sect1>
<title>Quick Start:  Creating the “world”</title>
<para>This chapter will provide a detailed description on how to build valid geometries as well as the ways to optimize them. There are several components gluing together the geometrical model, but for the time being let us get used with the most basic concepts.</para>
<para>The basic bricks for building-up the model are called <code>volumes</code><emphasis role="bold">. </emphasis>These represent the un-positioned pieces of the geometry puzzle. The difference is just that the relationship between the pieces is not defined by neighbors, but by <code>containment</code>. In other words, volumes are put one inside another making an in-depth hierarchy. From outside, the whole thing looks like a big pack that you can open finding out other smaller packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the “<code>world</code>” of the model. We will often call this <code>master reference system (MARS)</code>. Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong... We will call these leaves (by analogy with a tree structure).</para>
<para>On the other hand, any volume is a small world by itself – what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack – it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:</para>

<sect2>
<title>Example 1: Creating the World</title>
<para>We first need to load the geometry library. This is not needed if one does <code>make map</code> in root folder.</para>

<programlisting language="c++">
<code>root[]</code>    <code> </code>    <emphasis role="bold"><code>gSystem-&gt;Load(“libGeom”);</code></emphasis>
</programlisting>

<para>Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global <emphasis role="italic"><emphasis role="bold"><code>gGeoManager</code></emphasis></emphasis>:</para>

<programlisting language="c++">
<code>root[] </code>    <emphasis role="bold"><code>new TGeoManager(“world”, “the simplest geometry”);</code></emphasis>
</programlisting>

<para>We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TGeoMaterial *mat = new TGeoMaterial(“Vacu</code></emphasis><emphasis role="bold"><code>u</code></emphasis><emphasis role="bold"><code>m”,0,0,0);</code></emphasis>
root[] <emphasis role="bold"><code>TGeoMedium   *med = new TGeoMedium(“Vacuum”,1,mat);</code></emphasis>
</programlisting>

<para>We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TGeoVolume *top = gGeoManager</code></emphasis><emphasis role="bold"><code>-&gt;MakeBox(“Top”,med,10.,10.,10.);</code></emphasis>
</programlisting>

<para>The default units are in centimeters. Now we want to make this volume our world. We have to do this operation <emphasis role="bold">before</emphasis> closing the geometry. </para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>gGeoManager-&gt;SetTopVolume(top);</code></emphasis>
</programlisting>

<para>This should be enough, but it is not since always after defining some geometry hierarchy, <emphasis role="bold"><code>TGeo</code></emphasis> needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>gGeoManager-&gt;CloseGeometry();</code></emphasis>
</programlisting>

<para>Now we are really done with geometry building stage, but we would like to see our simple world:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>top-&gt;SetLineColor(kMagenta);</code></emphasis>
root[] <emphasis role="bold"><code>gGeoManager-&gt;SetTopVisible();</code></emphasis>  <code>// the TOP is generally invisible</code>
root[] <emphasis role="bold"><code>top-&gt;Draw();</code></emphasis>
</programlisting>

</sect2>

<sect2>
<title>Example 2: A Geometrical Hierarchy Look and Feel</title>
<para>Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at the link:  <uri xmlns:xlink="http://root.cern.ch/root/html/examples/rootgeom.C.html">http://root.cern.ch/root/html/examples/rootgeom.C.html</uri>. You will notice that this is a bit more complex that just creating the “world” since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some questions after having a first look:</para>
<para><emphasis role="italic"><emphasis role="bold"><code>Q: “OK, I understand the first lines that load the libGeom library and create a geometry manager object. I also recognize from the previous example the following lines creating some materials and media, but what about the geometrical transformations below?”</code></emphasis></emphasis></para>
<para><emphasis role="italic"><emphasis role="bold"><code>A:</code></emphasis></emphasis> As explained before, the model that we are trying to create is a hierarchy of volumes based on <emphasis role="italic"><emphasis role="bold"><code>containment</code></emphasis></emphasis>. This is accomplished by <emphasis role="italic"><emphasis role="bold"><code>positioning</code></emphasis></emphasis> some volumes <emphasis role="italic"><emphasis role="bold"><code>inside</code></emphasis></emphasis> others. Any volume is an un-positioned object in the sense that it defines only a <emphasis role="italic"><emphasis role="bold"><code>local frame</code></emphasis></emphasis> (matching the one of its <emphasis role="italic"><emphasis role="bold"><code>shape</code></emphasis></emphasis>). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a <emphasis role="italic"><emphasis role="bold"><code>local geometrical transformation</code></emphasis></emphasis> of the daughter with respect to the mother coordinate system. These transformations will be subsequently used in the example.</para>
<para><emphasis role="italic"><emphasis role="bold"><code>Q: “I see the lines defining the top level volume as in the previous example, but what about the other volumes named REPLICA and ROOT?”</code></emphasis></emphasis></para>
<para><emphasis role="italic"><emphasis role="bold"><code>A:</code></emphasis></emphasis> You will also notice that several other volumes are created by using lines like:</para>

<programlisting language="c++">
TGeoVolume *someVolume = gGeoManager-&gt;Make<emphasis role="italic"><emphasis role="bold"><code>XXX</code></emphasis></emphasis>(“someName”, ptrMedium,
/* parameters coresponding to <emphasis role="bold-italic">XXX</emphasis>… */)
</programlisting>

<para>In the method above <emphasis role="italic"><emphasis role="bold"><code>XXX</code></emphasis></emphasis> represent some shape name (Box, Tube, etc.). This is just a simple way of creating a volume having a given shape in one-step (see also section: “Creating and Positioning Volumes”). As for REPLICA and ROOT volumes, they are just some <emphasis role="italic"><emphasis role="bold"><code>virtual volumes</code></emphasis></emphasis> used for grouping and positioning together other <emphasis role="italic"><emphasis role="bold"><code>real volumes</code></emphasis></emphasis>. See “Positioned Volumes (Nodes)”. The same structure represented by (a real or) a virtual volume can be <emphasis role="italic"><emphasis role="bold"><code>replicated</code></emphasis></emphasis> several times in the geometry.</para>
<para><emphasis role="italic"><emphasis role="bold"><code>Q: “Fine, so probably the real volumes are the ones composing the letters R, O and T. Why one have to define so many volumes to make an R?”</code></emphasis></emphasis></para>
<para><emphasis role="italic"><emphasis role="bold"><code>A:</code></emphasis></emphasis> Well, in real life some objects have much more complex shapes that an <emphasis role="italic"><emphasis role="bold"><code>R</code></emphasis></emphasis>. The modeller cannot just know all of them; the idea is to make a complex object by using elementary building blocks that have known shapes (called <emphasis role="italic"><emphasis role="bold"><code>primitive shapes</code></emphasis></emphasis>). Gluing these together in the appropriate way is the user responsibility. </para>
<para><emphasis role="italic"><emphasis role="bold"><code>Q: “I am getting the global picture but not making much out of it… There are also a lot of calls to TGeoVolume::AddNode() that I do not understand.”</code></emphasis></emphasis></para>
<para><emphasis role="italic"><emphasis role="bold"><code>A:</code></emphasis></emphasis> A volume is positioned inside another one by using this method. The relative geometrical transformation as well as a copy number must be specified. When positioned, a volume becomes a <emphasis role="italic"><emphasis role="bold"><code>node</code></emphasis></emphasis> of its container and a new object of the class <emphasis role="bold"><code>TGeoNode</code></emphasis> is automatically created. This method is therefore the key element for the creation of a hierarchical link between two volumes. As it will be described further on in this document, there are few other methods performing similar actions, but let us keep things simple for the time being. In addition, notice that there are some visualization-related calls in the example followed by a final <emphasis role="bold"><code>TGeoVolume</code></emphasis><code>::Draw() </code>call for the top volume. These are explained in details in the section “Visualization Settings and Attributes”. At this point, you will probably like to see how this geometry looks like. You just need to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).</para>

<programlisting language="c++">
% root rootgeom.C
</programlisting>

<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001B1.jpg" width="180.6pt" depth="137.15pt"/></imageobject></inlinemediaobject>
</para>
<para>Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the <emphasis role="italic"><emphasis role="bold"><code>gGeoManager</code></emphasis></emphasis> object. Note that right click opens the context menu of the manager class where several global methods are available.</para>

<programlisting language="c++">
<code>root[]</code> <emphasis role="bold"><code>new TBrowser;</code></emphasis>
</programlisting>

<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001B2.jpg" width="190.55pt" depth="163.85pt"/></imageobject></inlinemediaobject>
</para>
<para>The folders <code>Materials</code>, <code>Media</code> and <code>Local transformations</code> are in fact the containers where the geometry manager stores the corresponding objects. The <code>Illegal overlaps</code> folder is empty but can be filled after performing a geometry validity check (see section: “Checking the Geometry”). If tracking is performed using <emphasis role="bold"><code>TGeo</code></emphasis>, the folder <code>Tracks</code> might contain user-defined tracks that can be visualized/animated in the geometry context (see section: “Creating and Visualizing Tracks”). Since for the time being we are interested more in the geometrical hierarchy, we will focus on the last two displayed items <code>TOP </code>and <code>TOP_1</code>. These are the top volume and the corresponding top node in the hierarchy. </para>
<para>Double clicking on the <code>TOP</code> volume will unfold all different volumes contained by the top volume. In the right panel, we will see all the volumes contained by <code>TOP</code> (if the same is positioned 4 times we will get 4 identical items). This rule will apply to any clicked volume in the hierarchy. Note that right clicking a volume item activates the volume context menu containing several specific methods. We will call the volume hierarchy developed in this way as the <code>logical geometry graph</code>. The volume objects are nodes inside this graph and the same volume can be accessed starting from different branches.</para>
<para>On the other hand, the real geometrical objects that are seen when visualizing or tracking the geometry are depicted in the <code>TOP_1</code> branch. These are the nodes of the <code>physical</code>         <code>tree</code> of positioned volumes represented by <emphasis role="bold"><code>TGeoNode</code></emphasis> objects. This hierarchy is a tree since a node can have only one parent and several daughters. For a better understanding of the hierarchy, have a look at  <uri xmlns:xlink="http://root.cern.ch/root/htmldoc/TGeoManager.html">http://root.cern.ch/root/htmldoc/TGeoManager.html</uri>. </para>
<para>Just close now the <code>X3D</code> window and focus at the wire frame picture drawn in a pad. Activate Options/Event Status. Moving the mouse in the pad, you will notice that objects are sometimes changing color to red. Volumes are highlighted in this way whenever the mouse pointer is close enough to one of its vertices. When this happens, the corresponding volume is selected and you will see in the bottom right size of the ROOT canvas its name, shape type and corresponding path in the physical tree. Right clicking on the screen when a volume is selected will also open its context menu (picking). Note that there are several actions that can be performed both at view (no volume selected) and volume level.</para>
<para><emphasis role="bold"><code>TView</code></emphasis> (mouse not selecting any volume):</para>
<itemizedlist>
<listitem><para>Click-and-drag rotates the view.</para></listitem>
<listitem><para>Pressing some keys perform different actions:</para></listitem>
<listitem><para>J/K – zoom / unzoom</para></listitem>
<listitem><para>H, L, U, I – move the viewpoint</para></listitem>
<listitem><para>Right click + <code>SetParallel</code>   <code>()/SetPerspective</code>   <code>()</code> – switch from parallel to perspective view.</para></listitem>
<listitem><para>Right click + <code>ShowAxis()</code> – show coordinate axes.</para></listitem>
<listitem><para>Right click + <code>Centered/Left/Side/Top</code> – change view direction.</para></listitem>
</itemizedlist>
<para><emphasis role="bold"><code>TGeoVolume</code></emphasis> (mouse selecting a volume):</para>
<itemizedlist>
<listitem><para>Double click will focus the corresponding volume.</para></listitem>
<listitem><para>Right click + <code>CheckOverlaps()</code> – run overlap checker on current volume.</para></listitem>
<listitem><para>Right click + <code>Draw</code>   <code>()</code> – draw that volume according current global visualization options</para></listitem>
<listitem><para>Right click + <code>DrawOnly()</code><emphasis role="italic"><emphasis role="bold"><code> – </code></emphasis></emphasis>draw only the selected volume.</para></listitem>
<listitem><para>Right click + <code>InspectShape/Material()</code> – print info about shape or material.</para></listitem>
<listitem><para>Right click + <code>Raytrace()</code>         – initiate a ray tracing algorithm on current view.</para></listitem>
<listitem><para>Right click + <code>RandomPoints/Rays()</code> – shoot random points or rays inside the bounding box of the clicked volume and display only those inside visible volumes.</para></listitem>
<listitem><para>Right click + <code>Weight()</code> – estimates the weight of a volume within a given precision.</para></listitem>
</itemizedlist>
<para>Note that there are several additional methods for visibility and line attributes settings.</para>
</sect2>
</sect1>

<sect1>
<title>Materials and Tracking Media</title>
<para>We have mentioned that volumes are the building blocks for geometry, but they describe real objects having well defined properties. In fact, there are just two of them: the material they are made from and their geometrical <code>shape</code>. These have to be created before creating the volume itself, so we will describe the bits and pieces needed for making the geometry before moving to an architectural point of view.</para>
<para>As far as materials are concerned, they represent the physical properties of the solid from which a volume is made. Materials are just a support for the data that has to be provided to the tracking engine that uses this geometry package. Due to this fact, the <emphasis role="bold"><code>TGeoMaterial</code></emphasis> class is more like a thin data structure needed for building the corresponding native materials of the Monte-Carlo tracking code that uses <emphasis role="bold"><code>TGeo</code></emphasis>. </para>

<sect2>
<title>Elements, Materials and Mixtures</title>
<para>In order to make easier material and mixture creation, one can use the pre-built table of elements owned by <emphasis role="bold"><code>TGeoManager</code></emphasis> class:</para>

<programlisting language="c++">
TGeoElementTable *table = gGeoManager-&gt;GetElementTable();
TGeoElement *element1 = table-&gt;GetElement(Int_t Z);
TGeoElement *element2 = table-&gt;FindElement(“Copper”);
</programlisting>

<para>Materials made of single elements can be defined by their atomic mass (<code>A</code>), charge (<code>Z</code>) and density (<code>rh</code>o). One can also create a material by specifying the element that it is made of. Optionally the radiation and absorption lengths can be also provided; otherwise they can be computed on-demand [<code>G3</code>]. The class representing them is <emphasis role="bold"><code>TGeoMaterial</code></emphasis>:</para>

<programlisting language="c++">
TGeoMaterial(const char *name,Double_t a,Double_t z,Double_t density,
Double_t radlen=0,Double_t intlen=0);
TGeoMaterial(const char *name, TGeoElement *elem, Double_t density);
TGeoMaterial(const char* name, Double_t a, Double_t z, Double_t rho,
TGeoMaterial::EGeoMaterialState state,
Double_t temperature = STP_temperature,
Double_t pressure = STP_pressure)
</programlisting>

<para>Any material or derived class is automatically indexed after creation. The assigned index is corresponding to the last entry in the list of materials owned by <emphasis role="bold"><code>TGeoManager</code></emphasis> class. This can be changed using the <emphasis role="bold"><code>TGeoMaterial</code></emphasis><code>::SetIndex()</code> method, however it is not recommended while using the geometry package interfaced with a transport MC. Radiation and absorption lengths can be set using:</para>

<programlisting language="c++">
TGeoMaterial::SetRadLen(Double_t radlen, Double_t intlen);
</programlisting>
<itemizedlist>
<listitem><para><code>radlen:</code> radiation length. If <code>radlen&lt;=0</code> the value is computed using GSMATE algorithm in GEANT3</para></listitem>
<listitem><para><code>intlen:</code>  absorption length</para></listitem>
</itemizedlist>
<para>Material state, temperature and pressure can be changed via setters. Another material property is transparency. It can be defined and used while viewing the geometry with OpenGL.</para>

<programlisting language="c++">
<uri xmlns:xlink="http://root.cern.ch/root/html/ListOfTypes.html">void</uri>  <uri xmlns:xlink="http://root.cern.ch/root/html/TGeoMaterial.html">SetTransparency</uri> ( <uri xmlns:xlink="http://root.cern.ch/root/html/ListOfTypes.html">Char_t</uri> transparency = 0)
</programlisting>
<itemizedlist>
<listitem><para><code>transparency:</code>  between 0 (opaque default) to 100 (fully transparent)</para></listitem>
</itemizedlist>
<para>One can attach to a material a user-defined object storing Cerenkov properties. Another hook for material shading properties is currently not in use. Mixtures are materials made of several elements. They are represented by the class <emphasis role="bold"><code>TGeoMixture</code></emphasis>, deriving from <emphasis role="bold"><code>TGeoMaterial</code></emphasis> and defined by their number of components and the density:   </para>

<programlisting language="c++">
TGeoMixture(const char *name,Int_t nel,Double_t rho);
</programlisting>

<para> Elements have to be further defined one by one:</para>

<programlisting language="c++">
void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,Double_t weigth);
void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem, Double_t weight);
void TGeoMixture ::DefineElement(Int_t iel, Int_t z, Int_t natoms);
</programlisting>

<para>or:</para>

<programlisting language="c++">
void AddElement(TGeoMaterial* mat, Double_t weight);
void AddElement(TGeoElement* elem, Double_t weight);
void AddElement(TGeoElement* elem, Int_t natoms);
void AddElement(Double_t a, Double_t z, Double_t weight)
</programlisting>
<itemizedlist>
<listitem><para><code>iel:</code> index of the element<code> [0,nel-1]</code></para></listitem>
<listitem><para><code>a </code>and <code>z:</code> the atomic mass and charge</para></listitem>
<listitem><para><code>weight:</code> proportion by mass of the elements</para></listitem>
<listitem><para><code>natoms</code>: number of atoms of the element in the molecule making the mixture</para></listitem>
</itemizedlist>
<para>The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material.</para>
</sect2>

<sect2>
<title>Radionuclides</title>
<para>A new class <emphasis role="bold"><code>TGeoElementRN</code></emphasis> was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (<emphasis role="bold"><code>TGeoElementTable</code></emphasis> class). One can make then materials/mixtures based on these radionuclides and use them in a geometry</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TGeoManager *geom = new TGeoManager("geom", "radionuclides");</code></emphasis>
root[] <emphasis role="bold"><code>TGeoElementTable *table = geom-&gt;GetElementTable</code></emphasis><emphasis role="bold"><code>();</code></emphasis>
root[] <emphasis role="bold"><code>TGeoElementRN *c14 = table-&gt;GetElementRN(14,6);</code></emphasis>  <emphasis role="bold"><code>// A,Z</code></emphasis>
root[]<emphasis role="bold"><code> c14-&gt;Print();</code></emphasis>
6-C-014      ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV]; Hlife=1.81e+11[s]    J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0
Decay modes:
BetaMinus            Diso:   0 BR:   100.000% Qval: 0.1565
</programlisting>

<para>One can make materials or mixtures from radionuclides:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TGeoMaterial *mat = new TGeoMaterial("C14", c14, 2.0);</code></emphasis>
</programlisting>

<para>The following properties of radionulides can be currently accessed via getters in the <emphasis role="bold"><code>TGeoElementRN</code></emphasis> class:</para>
<para>Atomic number and charge (from the base class <emphasis role="bold"><code>TGeoElement</code></emphasis>)</para>
<itemizedlist>
<listitem><para>Isomeric number (<code>ISO</code>)</para></listitem>
<listitem><para>ENDF code - following the convention: <code>ENDF=10000*Z+100*A+ISO</code></para></listitem>
<listitem><para>Isomeric energy level [<code>MeV</code>]</para></listitem>
<listitem><para>Mass excess [<code>MeV</code>]</para></listitem>
<listitem><para>Half life [<code>s</code>]</para></listitem>
<listitem><para>Spin/Parity - can be retrieved with: <emphasis role="bold"><code>TGeoElementRN</code></emphasis><code>::GetTitle()</code></para></listitem>
<listitem><para>Hynalation and ingestion toxicities</para></listitem>
<listitem><para>List of decays - <emphasis role="bold"><code>TGeoElementRN</code></emphasis><code>::GetDecays()</code></para></listitem>
</itemizedlist>
<para>The radioactive decays of a radionuclide are represented by the class <emphasis role="bold"><code>TGeoDecayChannel</code></emphasis> and they are stored in a <emphasis role="bold"><code>TObjArray</code></emphasis>. Decay provides:</para>
<itemizedlist>
<listitem><para>Decay mode</para></listitem>
<listitem><para>Variation of isomeric number</para></listitem>
<listitem><para><code>Q</code> value for the decay [<code>GeV</code>]</para></listitem>
<listitem><para>Parent element</para></listitem>
<listitem><para>Daughter element</para></listitem>
</itemizedlist>
<para>Radionuclides are linked one to each other via their decays, until the last element in the decay chain which must be stable. One can iterate decay chains using the iterator <emphasis role="bold"><code>TGeoElemIter</code></emphasis>:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TGeoElemIter next(c14);</code></emphasis>
root[] <emphasis role="bold"><code>TGeoElementRN *elem;</code></emphasis>
root[] <emphasis role="bold"><code>while ((elem=next())) next.Print();</code></emphasis>
6-C-014 (100% BetaMinus) T1/2=1.81e+11
7-N-014 stable
</programlisting>

<para>To create a radioactive material based on a radionuclide, one should use the constructor:</para>

<programlisting language="c++">
TGeoMaterial(const char *name, TGeoElement *elem, Double_t density)
</programlisting>

<para>To create a radioactive mixture, one can use radionuclides as well as stable elements:</para>

<programlisting language="c++">
TGeoMixture(const char *name, Int_t nelements, Double_t density);
TGeoMixture::AddElement(TGeoElement *elem, Double_t weight_fraction);
</programlisting>

<para>Once defined, one can retrieve the time evolution for the radioactive materials/mixtures by using one of the next two methods:</para>
<para>1. <emphasis role="bold"><code>TGeoMaterial</code></emphasis><code>::FillMaterialEvolution(TObjArray *population,</code>         </para>
<para><code>                                      Double_t   precision=0.001)</code> </para>
<para>To use this method, one has to provide an empty <emphasis role="bold"><code>TObjArray</code></emphasis> object that will be filled with all elements coming from the decay chain of the initial radionuclides contained by the material/mixture. The precision represent the cumulative branching ratio for which decay products are still considered.</para>

<figure><title>Concentration of C14 derived elements</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001B3.png" width="268.15pt" depth="201.7pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The population list may contain stable elements as well as radionuclides, depending on the initial elements. To test if an element is a radionuclide:</para>

<programlisting language="c++">
Bool_t TGeoElement::IsRadioNuclide() const
</programlisting>

<para>All radionuclides in the output population list have attached objects that represent the time evolution of their fraction of nuclei with respect to the top radionuclide in the decay chain. These objects (Bateman solutions) can be retrieved and drawn:</para>

<programlisting language="c++">
TGeoBatemanSol *TGeoElementRN::Ratio();
void TGeoBatemanSol::Draw();
</programlisting>

<para>Another method allows to create the evolution of a given radioactive material/mixture at a given moment in time:</para>
<para>2. <emphasis role="bold"><code>TGeoMaterial</code></emphasis><code>::DecayMaterial(Double_t time, Double_t precision=0.001)</code></para>
<para>The method will create the mixture that result from the decay of a initial material/mixture at time, while all resulting elements having a fractional weight less than precision are excluded.</para>
<para>A demo macro for radioactive material features is <code>$ROOTSYS/tutorials/geom/RadioNuclides.C</code> It demonstrates also the decay of a mixture made of radionuclides.</para>

<figure><title>Concentracion of elements derived fromCa53+Sr78</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001B4.png" width="268.15pt" depth="201.7pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect2>

<sect2>
<title>Tracking Media</title>
<para>The class <emphasis role="bold"><code>TGeoMedium</code></emphasis> describes tracking media properties. This has a pointer to a material and the additional data members representing the properties related to tracking.</para>

<programlisting language="c++">
TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,Double_t *params=0);
</programlisting>
<itemizedlist>
<listitem><para><code>name:</code> name assigned to the medium</para></listitem>
<listitem><para><code>mat:</code> pointer to a material</para></listitem>
<listitem><para><code>params:</code> array of additional parameters</para></listitem>
</itemizedlist>
<para>Another constructor allows effectively defining tracking parameters in GEANT3 style:</para>

<programlisting language="c++">
TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,
Double_t fieldm,Double_t tmaxfd,Double_t stemax,
Double_t deemax,Double_t epsil,Double_t stmin);
</programlisting>

<para>This constructor is reserved for creating tracking media from the VMC interface [...]:</para>
<itemizedlist>
<listitem><para><code>numed:</code> user-defined medium index</para></listitem>
<listitem><para><code>imat:</code> unique ID of the material</para></listitem>
<listitem><para><code>others:</code> see G3 documentation</para></listitem>
</itemizedlist>
<para>Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC's is to define and use only one <code>dummy tracking medium</code> as in the example (or a <code>NULL</code> pointer).</para>
</sect2>

<sect2>
<title>User Interface for Handling Materials and Media</title>
<para>The <emphasis role="bold"><code>TGeoManager</code></emphasis> class contains the API for accessing and handling defined materials:</para>

<programlisting language="c++">
TGeoManager::GetMaterial(name);
</programlisting>

</sect2>
</sect1>

<sect1>
<title>Shapes</title>
<para>Shapes are geometrical objects that provide the basic modeling functionality. They provide the definition of the <code>local</code> coordinate system of the volume. Any volume must have a shape. Any shape recognized by the modeller has to derive from the base <emphasis role="bold"><code>TGeoShape</code></emphasis> class, providing methods for:</para>
<itemizedlist>
<listitem><para>Finding out if a point defined in their local frame is contained or not by the shape;</para></listitem>
<listitem><para>Computing the distance to enter/exit the shape from a local point, given a known direction;</para></listitem>
<listitem><para>Computing the maximum distance in any direction from a local point that does NOT result in a boundary crossing of the shape (safe distance); </para></listitem>
<listitem><para>Computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ongoing direction.</para></listitem>
</itemizedlist>
<para>All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement additional specific abstract methods:</para>
<itemizedlist>
<listitem><para>Computation of the minimal box bounding the shape, given that this box have to be aligned with the local coordinates;</para></listitem>
<listitem><para>Algorithms for dividing the shape along a given axis.</para></listitem>
</itemizedlist>
<para>The modeller currently provides a set of 20 basic shapes, which we will call <code>primitives</code>. It also provides a special class allowing the creation of shapes as a result of Boolean operations between primitives. These are called <code>composite shapes</code> and the composition operation can be recursive (combined composites). This allows the creation of a quite large number of different shape topologies and combinations. You can have a look and run the tutorial:  <uri xmlns:xlink="http://root.cern.ch/root/html/examples/geodemo.C.html">http://root.cern.ch/root/html/examples/geodemo.C.html</uri> </para>

<figure><title>Primitive Shapes - the general inheritance scheme</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001B5.png" width="279.3pt" depth="178.15pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>Shapes are named objects and all primitives have constructors like:</para>

<programlisting language="c++">
TGeoXXX(const char *name,&lt;type&gt; param1,&lt;type&gt; param2, …);
TGeoXXX(&lt;type&gt; param1,&lt;type&gt; param2, …);
</programlisting>

<para>Naming shape primitive is mandatory only for the primitives used in Boolean composites (see “Composite Shapes”). For the sake of simplicity, we will describe only the constructors in the second form.</para>

<sect2>
<title>Units</title>
<para>The length units used in the geometry are <emphasis role="bold">arbitrary</emphasis>.  However, there are certain functionalities that work with the assumption that the used lengths are expressed in centimeters. This is the case for shape capacity or volume weight computation. The same is valid when using the ROOT geometry as navigator for an external transport MC package (e.g. GEANT) via the VMC interface.</para>
<para>Other units in use: All angles used for defining rotation matrices or some shape parameters are expressed in <emphasis role="bold">degrees</emphasis>. Material density is expressed in [<emphasis role="bold">g/cm</emphasis><emphasis role="bold">3</emphasis>].</para>
</sect2>

<sect2>
<title>Primitive Shapes</title>

<sect3>
<title>Boxes – TGeoBBox Class</title>
<para>Normally a box has to be build only with 3 parameters: <code>DX,DY,DZ</code> representing the half-lengths on X, Y and Z-axes. In this case, the origin of the box will match the one of its reference frame and the box will range from: <code>-DX</code> to <code>DX</code> on X-axis, from <code>-DY</code> to <code>DY</code> on Y and from <code>-DZ</code> to <code>DZ</code> on Z. On the other hand, any other shape needs to compute and store the parameters of their minimal bounding box. The bounding boxes are essential to optimize navigation algorithms. Therefore all other primitives derive from <emphasis role="bold"><code>TGeoBBox</code></emphasis>. Since the minimal bounding box is not necessary centered in the origin, any box allows an origin translation <code>(Ox</code>,<code>Oy</code>,<code>Oz)</code>. All primitive constructors automatically compute the bounding box parameters. Users should be aware that building a translated box that will represent a primitive shape by itself would affect any further positioning of other shapes inside. Therefore it is highly recommendable to build non-translated boxes as primitives and translate/rotate their corresponding volumes only during positioning stage. </para>

<programlisting language="c++">
TGeoBBox(Double_t dx,Double_t dy,Double_t dz,Double_t *origin=0);
</programlisting>

<figure><title>TGeoBBox class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001B6.png" width="265.05pt" depth="122.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Parallelepiped – TGeoPara class</title>
<para>A parallelepiped is a shape having 3 pairs of parallel faces out of which one is parallel with the XY plane (Z faces). All faces are parallelograms in the general case. The Z faces have 2 edges parallel with the X-axis. </para>

<figure><title>TGeoPara class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001B7.png" width="266.9pt" depth="122.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The shape has the center in the origin and it is defined by:</para>
<itemizedlist>
<listitem><para><code>dX, dY, dZ:</code> half-lengths of the projections of the edges on X, Y and Z. The lower Z face is positioned at <code>-dZ</code>, while the upper at <code>+dZ</code>.</para></listitem>
<listitem><para><code>alpha:</code> angle between the segment defined by the centers of the X-parallel edges and Y axis <code>[-90,90]</code> in degrees</para></listitem>
<listitem><para><code>theta:</code> theta angle of the segment defined by the centers of the Z faces;</para></listitem>
<listitem><para><code>phi:</code> phi angle of the same segment</para></listitem>
</itemizedlist>
<programlisting language="c++">
TGeoPara(dX,dY,dZ,alpha,theta,phi);
</programlisting>

<para>A box is a particular parallelepiped having the parameters: <code>(dX,dY,dZ,0.,0.,0.)</code>.</para>
</sect3>

<sect3>
<title>Trapezoids</title>
<para>In general, we will call trapezoidall shapes having 8 vertices and up to 6 trapezoid faces. Besides that, two of the opposite faces are parallel to XY plane and are positioned at <code> dZ</code>. Since general trapezoids are seldom used in detector geometry descriptions, there are several primitives implemented in the modeller for particular cases.</para>
<para><code>Trd1</code> is a trapezoid with only X varying with Z. It is defined by the half-length in Z, the half-length in X at the lowest and highest Z planes and the half-length in Y:</para>

<programlisting language="c++">
TGeoTrd1(Double_t dx1,Double_t dx2,Double_t dy,Double_t dz);
</programlisting>

<figure><title>TGeoTrd1 class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001B8.png" width="266.3pt" depth="121.65pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para><code>Trd2</code> is a trapezoid with both X and Y varying with Z. It is defined by the half-length in Z, the half-length in X at the lowest and highest Z planes and the half-length in Y at these planes:</para>

<programlisting language="c++">
TGeoTrd2(Double_t dx1,Double_t dx2,Double_t dy1,Double_t dy2, Double_t dz);
</programlisting>

<figure><title>TGeoTrd2 class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001B9.png" width="266.3pt" depth="122.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>General Trapezoid – TGeoTrap Class</title>
<para>A general trapezoid is one for which the faces perpendicular to z are trapezes but their centers are not necessary at the same x, y coordinates. </para>

<figure><title>TGeoTrap Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/image443.jpg"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>It has eleven parameters: the half length in z, the polar angles from the center of the face at low z to that at high z, <code>H1</code> the half length in y at low z, <code>LB1</code> the half length in x at low z and y low edge, <code>LB2</code> the half length in x at low z and y high edge, <emphasis role="bold"><code>TH1</code></emphasis> the angle with respect to the y axis from the center of low y edge to the center of the high y edge, and <code>H2,LB2,LH2,TH2</code>, the corresponding quantities at high z.</para>

<programlisting language="c++">
TGeoTrap(Double_t dz,Double_t theta,Double_t phi,
Double_t h1,Double_t bl1,Double_t tl1,Double_t alpha1,
Double_t h2,Double_t bl2,Double_t tl2,Double_t alpha2);
</programlisting>

</sect3>

<sect3>
<title>Twisted Trapezoid – TGeoGtra class</title>
<para>A twisted trapezoid is a general trapezoid defined in the same way but that is twisted along the Z-axis. The twist is defined as the rotation angle between the lower and the higher Z faces.</para>

<programlisting language="c++">
TGeoGtra(Double_t dz,Double_t theta,Double_t phi,Double_t twist,
Double_t h1,Double_t bl1,Double_t tl1,Double_t alpha1,
Double_t h2,Double_t bl2,Double_t tl2,Double_t alpha2 );
</programlisting>

<figure><title>TGeoGtra class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001BB.png" width="266.3pt" depth="148.95pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Arbitrary 8 vertices shapes - TGeoArb8 class</title>
<para>An <code>Arb8</code> is defined by two quadrilaterals sitting on parallel planes, at <code>dZ</code>. These are defined each by 4 vertices having the coordinates <code>(Xi,Yi,+/-dZ)</code>,<code> i=0</code>,<code> 3</code>. The lateral surface of the <code>Arb8</code> is defined by the 4 pairs of edges corresponding to vertices (<code>i,i+1</code>) on both <code>-dZ</code> and <code>+dZ</code>. If M and M' are the middles of the segments <code>(i,i+1)</code> at <code>-dZ</code> and <code>+dZ</code>, a lateral surface is obtained by sweeping the edge at <code>-dZ</code> along MM' so that it will match the corresponding one at <code>+dZ</code>. Since the points defining the edges are arbitrary, the lateral surfaces are not necessary planes – but twisted planes having a twist angle linear-dependent on Z.</para>

<programlisting language="c++">
TGeoArb8::TGeoArb8(Double_t dz,Double_t ivert);
</programlisting>
<itemizedlist>
<listitem><para><code>dz:</code>  half-length in Z;</para></listitem>
<listitem><para><code>ivert = [0,7]</code></para></listitem>
</itemizedlist>

<para>Vertices have to be defined clockwise in the XY pane, both at <code>+dz</code> and <code>–dz</code>. The quadrilateral at <code>-dz</code> is defined by indices [0,3], whereas the one at <code>+dz</code> by vertices [4,7]. The vertex with <code>index=7</code> has to be defined last, since it triggers the computation of the bounding box of the shape. Any two or more vertices in each Z plane can have the same (X,Y) coordinates. It this case, the top and bottom quadrilaterals become triangles, segments or points. The lateral surfaces are not necessary defined by a pair of segments, but by pair segment-point (making a triangle) or point-point (making a line). Any choice is valid as long as at one of the end-caps is at least a triangle.</para>

<figure><title>TGeoArb8 class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001BC.png" width="198.6pt" depth="162.6pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Tubes – TGeoTube Class</title>
<para>Tubes have Z as their symmetry axis. They have a range in Z, a minimum and a maximum radius:</para>

<programlisting language="c++">
TGeoTube(Double_t rmin,Double_t rmax,Double_t dz);
</programlisting>

<para>The full Z range is from <code>-dz</code> to <code>+dz</code>.</para>

<figure><title>TGeoTube Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001BD.png" width="266.3pt" depth="121.65pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Tube Segments – TGeoTubeSeg Class</title>
<para>A tube segment is a tube having a range in phi. The tube segment class derives from <emphasis role="bold"><code>TGeoTube</code></emphasis>, having 2 extra parameters: <code>phi1</code> and <code>phi2</code>.</para>

<programlisting language="c++">
TGeoTubeSeg(Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2);
</programlisting>

<para>Here <code>phi1</code> and <code>phi2 </code>are the starting and ending <code>phi </code>values in degrees. The <code>general phi convention</code> is that the shape ranges from <code>phi1</code> to <code>phi2</code> going counterclockwise. The angles can be defined with either negative or positive values. They are stored such that <code>phi1</code> is converted to <code>[0,360]</code> and <code>phi2 &gt; phi1</code>.</para>

<figure><title>TGeoTubeSeg Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001BE.png" width="266.3pt" depth="121.65pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Cut Tubes – TGeoCtub Class</title>
<para>The cut tubes constructor has the form:</para>

<programlisting language="c++">
TGeoCtub(Double_t rmin,Double_t rmax,Double_t dz,Double_t phi1,Double_t phi2,
Double_t nxlow,Double_t nylow,Double_t nzlow, Double_t nxhi,
Double_t nyhi,Double_t nzhi);
</programlisting>

<figure><title>TGeoCtub Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001BF.png" width="266.3pt" depth="126.6pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>A cut tube is a tube segment cut with two planes. The centers of the 2 sections are positioned at <code>dZ</code>.  Each cut plane is therefore defined by a point <code>(0,0,dZ)</code> and its normal unit vector pointing outside the shape:</para>
<para><code>Nlow=(Nx,Ny,Nz&lt;0)</code>,  <code>Nhigh=(Nx’,Ny’,Nz’&gt;0)</code>.</para>
</sect3>

<sect3>
<title>Elliptical Tubes – TGeoEltu Class</title>
<para>An elliptical tube is defined by the two semi-axes A and B. It ranges from <code>–dZ</code> to <code>+dZ</code> as all other tubes:</para>

<programlisting language="c++">
TGeoEltu(Double_t a,Double_t b,Double_t dz);
</programlisting>

<figure><title>TGeoEltu Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001C0.png" width="266.3pt" depth="127.25pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Hyperboloids – TGeoHype Class</title>
<para>A hyperboloid is represented as a solid limited by two planes perpendicular to the Z axis (top and bottom planes) and two hyperbolic surfaces of revolution about Z axis (inner and outer surfaces). The class describing hyperboloids is <emphasis role="bold"><code>TGeoHype</code></emphasis> has 5 input parameters:</para>

<programlisting language="c++">
TGeoHype(Double_t rin,Double_t stin,Double_t rout,Double_t stout,Double_t dz);
</programlisting>

<figure><title>TGeoHype Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001C1.png" width="266.3pt" depth="121.65pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The hyperbolic surface equation is taken in the form:</para>

<programlisting language="c++">
r2 – z2tan2() = r2min
</programlisting>
<itemizedlist>
<listitem><para><code>r,z:</code> cylindrical coordinates for a point on the surface</para></listitem>
<listitem><para><code>:</code> stereo angle between the hyperbola asymptotic lines and Z axis </para></listitem>
<listitem><para><code>r2min:</code> minimum distance between hyperbola and Z axis (at <code>z=0</code>)</para></listitem>
</itemizedlist>
<para>The input parameters represent:</para>
<itemizedlist>
<listitem><para><code>rin, stin:</code> minimum radius and tangent of stereo angle for inner surface</para></listitem>
<listitem><para><code>rout, stout:</code> minimum radius and tangent of stereo angle for outer surface</para></listitem>
<listitem><para><code>dz:</code> half length in Z (bounding planes positions at <code>+/-dz</code>)</para></listitem>
</itemizedlist>
<para>The following conditions are mandatory in order to avoid intersections between the inner and outer hyperbolic surfaces in the range <code>+/-dz</code>:</para>
<itemizedlist>
<listitem><para>    <code>rin&lt;rout</code></para></listitem>
<listitem><para>    <code>rout&gt;0</code></para></listitem>
<listitem><para>    <code>rin2 + dz2*stin2 &gt; rout2 + dz2*stout2</code></para></listitem>
</itemizedlist>
<para>Particular cases:</para>
<itemizedlist>
<listitem><para><code>rin=0, stin0:</code> the inner surface is conical</para></listitem>
<listitem><para><code>stin=0 / stout=0:</code> cylindrical surface(s)</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Cones – TGeoCone Class</title>
<para>The cones are defined by 5 parameters:</para>

<programlisting language="c++">
TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,Double_t rmin2,Double_t rmax2);
</programlisting>
<itemizedlist>
<listitem><para><code>rmin1:</code> internal radius at Z is <code>-dz</code></para></listitem>
<listitem><para><code>rmax1:</code> external radius at Z is  <code>-dz</code></para></listitem>
<listitem><para><code>rmin2:</code> internal radius at Z is <code>+dz</code></para></listitem>
<listitem><para><code>rmax2:</code> external radius at Z is <code>+dz</code></para></listitem>
<listitem><para><code>dz:</code>       half length in Z (a cone ranges from <code>–dz</code> to +<code>dz</code>)</para></listitem>
</itemizedlist>
<para>A cone has Z-axis as its symmetry axis.</para>

<figure><title>TGeoCone Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001C2.png" width="252pt" depth="115.45pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Cone Segments – TGeoConeSeg Class</title>
<para>A cone segment is a cone having a range in <code>phi.</code> The cone segment class derives from <emphasis role="bold"><code>TGeoCone</code></emphasis>, having two extra parameters: <code>phi1</code> and <code>phi2</code>.</para>

<programlisting language="c++">
TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,Double_t rmin2,
Double_t rmax2,Double_t phi1,Double_t phi2);
</programlisting>

<para>Parameters<code> phi1</code> and <code>phi2</code> have the same meaning and convention as for tube segments.</para>

<figure><title>TGeoConeSeg Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001C3.png" width="252pt" depth="115.45pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Sphere – TGeoSphere Class</title>
<para>Spheres in <emphasis role="bold"><code>TGeo</code></emphasis> are not just balls having internal and external radii, but sectors of a sphere having defined theta and phi ranges. The <emphasis role="bold"><code>TGeoSphere</code></emphasis> class has the following constructor.</para>

<figure><title>TGeoSphere Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001C4.png" width="252pt" depth="121.05pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<programlisting language="c++">
TGeoSphere(Double_t rmin,Double_t rmax,Double_t theta1, Double_t theta2,
Double_t phi1, Double_t phi2);
</programlisting>
<itemizedlist>
<listitem><para><code>rmin: </code> internal radius of the spherical sector</para></listitem>
<listitem><para><code>rmax:</code>   external radius </para></listitem>
<listitem><para><code>theta1:</code> starting theta value [0, 180) in degrees</para></listitem>
<listitem><para><code>theta2:</code> ending theta value (0, 180] in degrees (<code>theta1&lt;theta2</code>)</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Torus :  TGeoTorus Class</title>
<para>The torus is defined by its axial radius, its inner and outer radius.  </para>

<figure><title>TGeoTorus Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001C5.png" width="284.3pt" depth="135.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>It may have a <code>phi </code>range:</para>

<programlisting language="c++">
TGeoTorus(Double_t R,Double_t Rmin,Double_t Rmax,Double_t Phi1,Double_t Dphi);
</programlisting>
<itemizedlist>
<listitem><para><code>R:</code>       axial radius of the torus</para></listitem>
<listitem><para><code>Rmin:</code> inner radius</para></listitem>
<listitem><para><code>Rmax:</code> outer radius</para></listitem>
<listitem><para><code>Phi1:</code> starting phi angle</para></listitem>
<listitem><para><code>Dphi:</code> total phi range</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Paraboloid :  TGeoParaboloid Class</title>
<para>A paraboloid is defined by the revolution surface generated by a parabola and is bounded by two planes perpendicular to Z axis. The parabola equation is taken in the form: <code>z = a·r2 + b</code>, where:  <code>r2 = x2 + y2</code>. Note the missing linear term (parabola symmetric with respect to Z axis). </para>
<para>The coefficients a and b are computed from the input values which are the radii of the circular sections cut by the planes at <code>+/-dz</code>:</para>
<itemizedlist>
<listitem><para>    <code>-dz = a*r2low  + b</code></para></listitem>
<listitem><para>    <code> dz = a*r2high + b</code></para></listitem>
</itemizedlist>
<programlisting language="c++">
TGeoParaboloid(Double_t rlo,Double_t rhi,Double_t dz);
</programlisting>

<figure><title>TGeoParaboloid Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001C6.png" width="284.3pt" depth="135.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Polycone :  TGeoPcon Class</title>
<para>A polycone is represented by a sequence of tubes/cones, glued together at defined Z planes. The polycone might have a phi segmentation, which globally applies to all the pieces. It has to be defined in two steps:</para>
<para>1. First call the <emphasis role="bold"><code>TGeoPcon</code></emphasis> constructor to define a polycone:</para>

<programlisting language="c++">
TGeoPcon(Double_t phi1,Double_t dphi,Int_t nz
</programlisting>
<itemizedlist>
<listitem><para><code>phi1:</code> starting phi angle in degrees</para></listitem>
<listitem><para><code>dphi:</code> total phi range</para></listitem>
<listitem><para><code>nz:</code>     number of Z planes defining polycone sections (minimum 2)</para></listitem>
</itemizedlist>
<para>  2. Define one by one all sections [0, nz-1]</para>

<programlisting language="c++">
void TGeoPcon::DefineSection(Int_t i,Double_t z,Double_t rmin, <code>Double_t rmax);</code>
</programlisting>
<itemizedlist>
<listitem><para><code>i:</code>       section index [0, nz-1]</para></listitem>
<listitem><para><code>z:</code>       z coordinate of the section</para></listitem>
<listitem><para><code>rmin:</code> minimum radius corresponding too this section</para></listitem>
<listitem><para><code>rmax:</code> maximum radius.</para></listitem>
</itemizedlist>
<para>The first section (<code>i=0</code>) has to be positioned always the lowest Z coordinate. It defines the radii of the first cone/tube segment at its lower Z. The next section defines the end-cap of the first segment, but it can represent also the beginning of the next one. Any discontinuity in the radius has to be represented by a section defined at the same Z coordinate as the previous one. The Z coordinates of all sections must be sorted in increasing order. Any radius or Z coordinate of a given plane have corresponding getters:</para>

<programlisting language="c++">
Double_t TGeoPcon::GetRmin(Int_t i);
Double_t TGeoPcon::GetRmax(Int_t i);
Double_t TGeoPcon::GetZ(Int_t i);
</programlisting>

<para>Note that the last section should be defined last, since it triggers the computation of the bounding box of the polycone.</para>

<figure><title>TGeoPcon Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001C7.png" width="266.3pt" depth="143.4pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>

<sect3>
<title>Polygon:  TGeoPgon Class</title>
<para>Polygons are defined in the same way as polycones, the difference being just that the segments between consecutive Z planes are regular polygons. The phi segmentation is preserved and the shape is defined in a similar manner, just that <code>rmin</code> and <code>rmax</code> represent the radii of the circles inscribed in the inner/outer polygon. </para>

<figure><title>TGeoPgon Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/060001C8.png" width="266.3pt" depth="148.95pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The constructor of a polygon has the form:</para>

<programlisting language="c++">
TGeoPgon(Double_t phi1,Double_t dphi,Int_t nedges,Int_t nz);
</programlisting>

<para>The extra parameter <code>nedges</code> represent the number of equal edges of the polygons, between <code>phi1</code> and <code>phi1+dphi.</code></para>
</sect3>

<sect3>
<title>Polygonal extrusion:  TGeoXtru Class</title>
<para>A <emphasis role="bold"><code>TGeoXtru</code></emphasis> shape is represented by the extrusion of an arbitrary polygon with fixed outline between several Z sections. Each Z section is a scaled version of the same “blueprint” polygon. Different global XY translations are allowed from section to section.  Corresponding polygon vertices from consecutive sections are connected. </para>
<para>An extruded polygon can be created using the constructor:</para>

<programlisting language="c++">
TGeoXtru::TGeoXtru(Int_t nplanes) ;
</programlisting>
<itemizedlist>
<listitem><para><code>nplanes:  </code>number of Z sections (minimum 2)</para></listitem>
</itemizedlist>
<para/>

<figure><title>TGeoXtru Class</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001C9.png" width="324pt" depth="180pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>
<code>The lists of X and Y positions for all vertices have to be provided for the “blueprint” polygon:</code></para>

<programlisting language="c++">
TGeoXtru::DefinePolygon (Int_t nvertices, Double_t *xv, Double_t *yv) ;
</programlisting>
<itemizedlist>
<listitem><para><code>nvertices:  </code>number of vertices of the polygon</para></listitem>
<listitem><para><code>xv,yv:  </code>arrays of X and Y coordinates for polygon vertices</para></listitem>
</itemizedlist>
<para>
<code>The method creates an object of the class </code>
<emphasis role="bold"><code>TGeoPolygon</code></emphasis>
<code> for which the convexity is automatically determined . The polygon is decomposed into convex polygons if needed. </code></para>
<para>
<code>Next step is to define the Z positions for each section plane as well as the XY offset and scaling for the corresponding polygons.</code></para>

<programlisting language="c++">
<code>TGeoXtru::DefineSection(Int_t snum,Double_t zsection,Double_t x0,Double_t y0,</code>
<code>                        Double_t scale);</code>
</programlisting>
<itemizedlist>
<listitem><para><code>snum: </code>Z section index (0, nplanes-1). The section with <code>snum = nplanes-1</code> must be defined last and triggers the computation of the bounding box for the whole shape</para></listitem>
<listitem><para><code>zsection: </code>Z position of section <code>snum</code>. Sections must be defined in increasing order of Z (e.g. <code>snum=0</code> correspond to the minimum Z and <code>snum=nplanes-1</code> to the maximum one).</para></listitem>
<listitem><para><code>x0,y0: </code>offset of section <code>snum</code> with respect to the local shape reference frame <code>T</code></para></listitem>
<listitem><para><code>scale: </code>factor that multiplies the X/Y coordinates of each vertex of the polygon at section <code>snum</code>:</para></listitem>
<listitem><para>    <code>x[ivert] = x0 + scale*xv[ivert]</code></para></listitem>
<listitem><para>    <code>y[ivert] = y0 + scale*yv[ivert]</code></para></listitem>
</itemizedlist>

</sect3>

<sect3>
<title>Half Spaces:  TGeoHalfSpace Class</title>
<itemizedlist>
<listitem><para>A half space is limited just by a plane, defined by a point and the normal direction. The point lies on the plane and the normal vector points outside the half space. The half space is the only shape which is infinite and can be used only in Boolean operations that result in non-infinite composite shapes (see also “Composite Shapes” below). A half space has to be defined using the constructor:</para></listitem>
</itemizedlist>
<programlisting language="c++">
TGeoHalfSpace (const char *name, Double_t *point[3], Double_t *norm[3]);
</programlisting>

</sect3>
</sect2>

<sect2>
<title>Composite Shapes</title>
<para>Composite shapes are Boolean combinations of two or more shape components. The supported Boolean operations are union (+), intersection (*) and subtraction(-). Composite shapes derive from the base <emphasis role="bold"><code>TGeoShape</code></emphasis> class, therefore providing all shape features: computation of bounding box, finding if a given point is inside or outside the combination, as well as computing the distance to entering/exiting. They can be directly used for creating volumes or used in the definition of other composite shapes.</para>
<para>Composite shapes are provided in order to complement and extend the set of basic shape primitives. They have a binary tree internal structure, therefore all shape-related geometry queries are signals propagated from top level down to the final leaves, while the provided answers are assembled and interpreted back at top. This <code>CSG</code> <code>(composite solid geometry)</code> hierarchy is effective for small number of components, while performance drops dramatically for large structures. Building a complete geometry in this style is virtually possible but highly not recommended.</para>

<sect3>
<title>The Structure of Composite Shapes</title>
<para> A composite shape can always be looked as the result of a Boolean operation between only two shape components. All information identifying these two components as well as their positions with respect to the frame of the composite is represented by an object called Boolean node. A composite shape has a pointer to such a Boolean node. Since the shape components may also be composites, they will also contain binary Boolean nodes branching out other two shapes in the hierarchy. Any such branch ends-up when the final leaves are no longer composite shapes, but basic primitives. The figure shows the composite shapes structure.</para>

<figure><title>The composite shapes structure</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001CA.png" width="212.9pt" depth="129.1pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>Suppose that A, B, C and D represent basic shapes, we will illustrate how the internal representation of few combinations look like. We do this only for understanding how to create them in a proper way, since the user interface for this purpose is in fact very simple. We will ignore for the time being the positioning of components. The definition of a composite shape takes an expression where the identifiers are shape names. The expression is parsed and decomposed in 2 sub-expressions and the top-level Boolean operator.</para>
<para>1. Union: <code>A+B+C</code></para>
<para>Just to illustrate the Boolean expression parsing and the composite shape structure, let’s take a simple example. We will describe the union of A, B and C. Both union operators are at the same level. Since:</para>
<para><code>A+B+C = (A+B)+C = A+(B+C)</code> </para>
<para>The first<code> (+)</code> is taken as separator, hence the expression split in: <code>A</code> and <code>(B+C)</code>. A Boolean node of type <emphasis role="bold"><code>TGeoUnion</code></emphasis><code>("A","B+C")</code> is created. This tries to replace the 2 expressions by actual pointers to corresponding shapes. The first expression (A) contains no operators therefore is interpreted as representing a shape. The shape named "A" is searched into the list of shapes handled by the manager class and stored as the "left" shape in the Boolean union node. Since the second expression is not yet fully decomposed, the "right" shape in the combination is created as a new composite shape. This will split at its turn B+C into B and C and create a <emphasis role="bold"><code>TGeoUnion</code></emphasis><code>("B","C")</code>. The B and C identifiers will be looked for and replaced by the pointers to the actual shapes into the new node. Finally, the composite "<code>A+B+C</code>" will be represented as shown in Fig.17-23.</para>

<figure><title>Representation of A+B+C</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001CB.png" width="214.15pt" depth="145.25pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>To build this composite shape:</para>

<programlisting language="c++">
TGeoCompositeShape *cs1 = new TGeoCompositeShape("CS1","A+B+C");
</programlisting>

<para>Any shape entering a Boolean combination can be prior positioned. In order to do so, one has to attach a matrix name to the shape name by using a colon (:). As for shapes, the named matrix has to be prior defined:</para>

<programlisting language="c++">
TGeoMatrix *mat;
<code>// … code creating some geometrical transformation</code>
mat-&gt;SetName(“mat1”);
mat-&gt;RegisterYourself();  <code>// see Geometrical transformations</code>
</programlisting>

<para>An identifier <code>shape:matrix</code> have the meaning: <code>shape</code> is translated or rotated with <code>matrix</code> with respect to the Boolean combination it enters as operand. Note that in the expression A+B+C no matrix identifier was provided, therefore the identity matrix was used for positioning the shape components. The next example will illustrate a more complex case. </para>
<para>2. <code>(A:m1+B):m2-(C:m3*D:m4):m5</code></para>
<para>Let’s try to understand the expression above. This expression means: subtract the intersection of <emphasis role="bold">C</emphasis> and <emphasis role="bold">D</emphasis> from the union of <emphasis role="bold">A</emphasis> and <emphasis role="bold">B</emphasis>. The usage of parenthesis to force the desired precedence is always recommended. One can see that not only the primitive shapes have some geometrical transformations, but also their intermediate compositions. </para>

<figure><title>Internal representation for composite shapes</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001CC.png" width="254.5pt" depth="167.6pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<programlisting language="c++">
TGeoCompositeShape *cs2 = new TGeoCompositeShape("CS2",
"(<code>A:m1+B):m2-(C:m3*D:m4):m5");</code>
</programlisting>

<para>Building composite shapes as in the first example is not always quite useful since we were using un-positioned shapes. When supplying just shape names as identifiers, the created Boolean nodes will assume that the shapes are positioned with an identity transformation with respect to the frame of the created composite. In order to provide some positioning of the combination components, we have to attach after each shape identifier the name of an existing transformation, separated by a colon. Obviously all transformations created for this purpose have to be objects with unique names in order to be properly substituted during parsing.</para>
</sect3>

<sect3>
<title>Composite Shape Example</title>
<para>One should have in mind that the same shape or matrix identifiers can be used many times in the same expression, as in the following example:</para>

<programlisting language="c++">
const Double_t sq2 = TMath::Sqrt(2.);
gSystem-&gt;Load("libGeom");
TGeoManager *mgr = new TGeoManager("Geom","composite shape example");
TGeoMedium *medium = 0;
TGeoVolume *top = mgr-&gt;MakeBox("TOP",medium,100,250,250);
mgr-&gt;SetTopVolume(top);

<code>// make shape components</code>
TGeoBBox *sbox  = new TGeoBBox("B",100,125*sq2,125*sq2);
TGeoTube *stub  = new TGeoTube("T",0,100,250);
TGeoPgon *spgon = new TGeoPgon("P",0.,360.,6,2);
spgon-&gt;DefineSection(0,-250,0,80);
spgon-&gt;DefineSection(1,250,0,80);

<code>// define some rotations </code>
TGeoRotation *r1 = new TGeoRotation("r1",90,0,0,180,90,90);
r1-&gt;RegisterYourself();
TGeoRotation *r2 = new TGeoRotation("r2",90,0,45,90,45,270);
r2-&gt;RegisterYourself();
<code>// create a composite</code>
TGeoCompositeShape *cs = new TGeoCompositeShape("cs",
"((T+T:r1)-(P+P:r1))*B:r2");
TGeoVolume *comp = new TGeoVolume("COMP",cs);
comp-&gt;SetLineColor(5);

<code>// put it in the top volume</code>
top-&gt;AddNode(comp,1);
mgr-&gt;CloseGeometry();
<code>// visualize it with ray tracing</code>
top-&gt;Raytrace();
</programlisting>

<figure><title>A composite shape example</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001CD.png" width="266.3pt" depth="181.85pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>Composite shapes can be subsequently used for defining volumes. Moreover, these volumes contain other volumes, following the general criteria. Volumes created based on composite shapes cannot be divided. </para>
</sect3>
</sect2>

<sect2>
<title>Navigation Methods Performed By Shapes</title>
<para>Shapes are named objects and register themselves to the <code>manager class</code> at creation time. This is responsible for their final deletion. Shapes can be created without name if their retrieval by name is no needed. Generally shapes are objects that are useful only at geometry creation stage. The pointer to a shape is in fact needed only when referring to a given volume and it is always accessible at that level. Several volumes may reference a single shape; therefore its deletion is not possible once volumes were defined based on it.</para>
<para>The navigation features related for instance to tracking particles are performed in the following way: Each shape implement its specific algorithms for all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:</para>

<programlisting language="c++">
Bool_t TGeoShape::Contains(Double_t *point[3]);
</programlisting>

<para>The method above returns <code>kTRUE</code> if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having <code>DX,DY</code> and <code>DZ </code>half-lengths a point will be considered inside if:</para>
<para>
<code>-DX &lt;= point[0] &lt;= DX</code></para>
<para>
<code>-DY &lt;= point[1] &lt;= DY</code></para>
<para>
<code>-DZ &lt;= point[2] &lt;= DZ</code></para>

<programlisting language="c++">
Double_t TGeoShape::DistFromInside(Double_t *point[3],Double_t *dir[3],
Int_t iact,Double_t step,Double_t *safe);
</programlisting>

<para>The method computes the distance to exiting a shape from a given point <code>inside</code>, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of <code>iact</code> input parameter:</para>
<itemizedlist>
<listitem><para><code>iact = 0</code>computes only safe distance and fill it at the location given by SAFE;</para></listitem>
<listitem><para><code>iact = 1</code>a proposed STEP is supplied. The safe distance is computed first. If this   is bigger  than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;</para></listitem>
<listitem><para><code>iact = 2</code>computes both safe distance and distance to exiting, ignoring the proposed step;</para></listitem>
<listitem><para><code>iact &gt; 2</code>computes only the distance to exiting, ignoring anything else</para></listitem>
</itemizedlist>
<programlisting language="c++">
Double_t TGeoShape::DistFromOutside(Double_t *point[3],Double_t *dir[3],
Int_t iact,Double_t step,Double_t *safe);
</programlisting>

<para>This method computes the distance to entering a shape from a given point <code>outside</code>. It acts in the same way as the previous method.</para>

<programlisting language="c++">
Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);
</programlisting>

<para>This computes the maximum shift of a point in any direction that does not change its <code>inside/outside </code>state (does not cross shape boundaries). The state of the point has to be properly supplied.</para>

<programlisting language="c++">
Double_t *TGeoShape::ComputeNormal(Double_t *point[3],Double_t *dir[3],
Double_t *norm[3]);
</programlisting>

<para>The method above computes the director cosines of normal to the crossed shape surface from a given point towards direction. This is filled into the <code>norm</code> array, supplied by the user. The normal vector is always chosen such that its dot product with the direction is positive defined.</para>
</sect2>

<sect2>
<title>Creating Shapes</title>
<para>Shape objects embeds only the minimum set of parameters that are fully describing a valid physical shape. For instance, the half-length, the minimum and maximum radius represent a tube. Shapes are used together with media in order to create volumes, which in their turn are the main components of the geometrical tree. A specific shape can be created stand-alone: </para>

<programlisting language="c++">
TGeoBBox *box = new TGeoBBox("s_box",halfX,halfY,halfZ);  <code>// named</code>
TGeoTube *tub = new TGeoTube(rmin,rmax,halfZ);            <code>// no name</code>
<code>//...  (See all specific shape constructors)</code>
</programlisting>

<para>Sometimes it is much easier to create a volume having a given shape in one step, since shapes are not directly linked in the geometrical tree but volumes are:</para>

<programlisting language="c++">
TGeoVolume *vol_box = gGeoManager-&gt;MakeBox("BOX_VOL",pmed,halfX,halfY,halfZ);
TGeoVolume *vol_tub = gGeoManager-&gt;MakeTube("TUB_VOL",pmed,rmin,rmax,halfZ);
<code>// ...(See MakeXXX() utilities in TGeoManager class)</code>
</programlisting>

</sect2>

<sect2>
<title>Dividing Shapes</title>
<para>Shapes can generally be divided along a given axis. Supported axes are: <code>X</code>, <code>Y</code>, <code>Z</code>, <code>Rxy</code>, <code>Phi</code>, <code>Rxyz</code>. A given shape cannot be divided however on any axis. The general rule is that that divisions are possible on whatever axis that produces still known shapes as slices. The division of shapes are performed by the call <emphasis role="bold"><code>TGeoShape</code></emphasis><code>::Divide()</code>, but this operation can be done only via <emphasis role="bold"><code>TGeoVolume</code></emphasis><code>::Divide()</code> method. In other words, the algorithm for dividing a specific shape is known by the shape object, but is always invoked in a generic way from the volume level. Details on how to do that can be found in the paragraph ‘Dividing volumes’. One can see how all division options are interpreted and which their result inside specific shape classes is.</para>
</sect2>

<sect2>
<title>Parametric Shapes</title>
<para>Shapes generally have a set of parameters that is well defined at build time. In fact, when the final geometrical hierarchy is assembled and the geometry is closed, all constituent shapes <code>MUST</code><emphasis role="bold-italic"> </emphasis>have well defined and valid parameters. In order to ease-up geometry creation, some parameterizations are however allowed.</para>
<para>For instance let’s suppose that we need to define several volumes having exactly the same properties but different sizes. A way to do this would be to create as many different volumes and shapes. The modeller allows however the definition of a single volume having undefined shape parameters.</para>

<programlisting language="c++">
TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);
</programlisting>
<itemizedlist>
<listitem><para><code>name:</code> the name of the newly created volume;</para></listitem>
<listitem><para><code>shape:</code>the type of the associated shape. This has to contain the case-insensitive first 4 letters of the corresponding class name (e.g. “<code>tubs</code>” will match <emphasis role="bold"><code>TGeoTubeSeg</code></emphasis>, “<code>bbox</code>” will match <emphasis role="bold"><code>TGeoBBox</code></emphasis>)</para></listitem>
<listitem><para><code>nmed:</code> the medium number.</para></listitem>
</itemizedlist>
<para>This will create a special volume that will not be directly used in the geometry, but whenever positioned will require a list of actual parameters for the current shape that will be created in this process. Such volumes having shape parameters known only when used have to be positioned only with <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::Node()</code> method (see ‘Creating and Positioning Volumes’).</para>
<para>Other case when shape parameterizations are quite useful is scaling geometry structures. Imagine that we would like to enlarge/shrink a detector structure on one or more axes. This happens quite often in real life and is handled by “fitting mother” parameters. This is accomplished by defining shapes with one or more invalid (negative) parameters. For instance, defining a box having <code>dx=10.</code>, <code>dy=10.</code>, and <code>dz=-1</code> will not generate an error but will be interpreted in a different way: A special volume <emphasis role="bold"><code>TGeoVolumeMulti</code></emphasis> will be created. Whenever positioned inside a mother volume, this will create a normal <emphasis role="bold"><code>TGeoVolume</code></emphasis> object having as shape a box with <code>dz</code> fitting the corresponding <code>dz </code>of the mother shape. Generally, this type of parameterization is used when positioning volumes in containers having a matching shape, but it works also for most reasonable combinations.</para>
</sect2>
</sect1>

<sect1>
<title>Geometry Creation</title>
<para>A given geometry can be built in various ways, but one has to follow some mandatory steps. Even if we might use some terms that will be explained later, here are few general rules: </para>
<itemizedlist>
<listitem><para>Volumes need media and shapes in order to be created.</para></listitem>
<listitem><para>Both containers and contained volumes must be created before linking them together, and the relative transformation matrix must be provided.</para></listitem>
<listitem><para>Any volume have to be positioned somewhere otherwise it will not be considered as part of the geometry. </para></listitem>
<listitem><para>Visibility or tracking properties of volumes can be provided both at build time or after geometry is closed, but global visualization settings (see section: “The Drawing Package”) should not be provided at build time, otherwise the drawing package will be loaded. </para></listitem>
</itemizedlist>
<para>There is also a list of specific rules: </para>
<itemizedlist>
<listitem><para>Positioned volumes should not extrude their container or intersect with others within this unless it is specified (see section: Overlapping Volumes).</para></listitem>
<listitem><para>The top volume (containing all geometry trees) must be specified before closing the geometry and must not be positioned - it represents the global reference frame. </para></listitem>
<listitem><para>After building the full geometry tree, the geometry must be closed (see the method  <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::CloseGeometry()</code>). Voxelization can be redone per volume after this process.</para></listitem>
</itemizedlist>
<para>The list is much bigger and we will describe in more detail the geometry creation procedure in the following sections. Provided that geometry was successfully built and closed, the <emphasis role="bold"><code>TGeoManager</code></emphasis> class will register itself to ROOT and the logical/physical structures will become immediately browsable.</para>

<sect2>
<title>The Volume Hierarchy</title>
<para>The basic components used for building the logical hierarchy of the geometry are the positioned volumes called <code>nodes</code>. Volumes are fully defined geometrical objects having a given shape and medium and possibly containing a list of nodes. Nodes represent just positioned instances of volumes inside a container volume but users do not directly create them. They are automatically created as a result of adding one volume inside other or dividing a volume. The geometrical transformation held by nodes is always defined with respect to their mother (relative positioning). Reflection matrices are allowed. </para>
<para>A hierarchical element is not fully defined by a node since nodes are not directly linked to each other, but through volumes (a node points to a volume, which at its turn points to a list of nodes):</para>
<para>
<code>NodeTop </code>

<code> VolTop </code>

<code> NodeA </code>

<code> VolA </code>

<code>…</code></para>
<para>One can therefore talk about “the node or volume hierarchy”, but in fact, an element is made by a pair volume-node. In the line above is represented just a single branch, but of course from any volume other branches can also emerge. The index of a node in such a branch (counting only nodes) is called <code>depth</code>. The top node have always <code>depth=0</code>. </para>
<para>Volumes need to have their daughter nodes defined when the geometry is closed. They will build additional structures (called <code>voxels</code>  ) in order to fasten-up the search algorithms. Finally, nodes can be regarded as bi-directional links between containers and contained volumes.</para>
<para>The structure defined in this way is a graph structure since volumes are replicable (same volume can become daughter node of several other volumes), every volume becoming a branch in this graph. Any volume in the logical graph can become the actual top volume at run time (see <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::SetTopVolume()</code>). All functionalities of the modeller will behave in this case as if only the corresponding branch starting from this volume is the active geometry.</para>

<figure><title>A geometry hierarchy in memory</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001CE.png" width="216.6pt" depth="216.6pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>Nodes are never instantiated directly by users, but created as a result of volume operations. Adding a volume named A with a given <code>user id</code> inside a volume B will create a node named <code>A_id.</code> This will be added to the list of nodes stored by B. In addition, when applying a division operation in N slices to a volume A, a list of nodes <code>B_1</code>, <code>B_2</code>, ... , <code>B_N</code> is also created. A node <code>B_i</code>         does not represent a unique object in the geometry because its container A might be at its turn positioned as node inside several other volumes. Only when a complete branch of nodes is fully defined up to the top node in the geometry, a given path:<code> /TOP_1/</code>...<code>/A_3/B_7</code> will represent a unique object. Its global transformation matrix can be computed as the pile-up of all local transformations in its branch. We will therefore call <code>logical graph</code> the hierarchy defined by nodes and volumes. The expansion of the logical graph by all possible paths defines a tree structure where all nodes are unique "touchable" objects. We will call this the "physical tree". Unlike the logical graph, the physical tree can become a huge structure with several millions of nodes in case of complex geometries; therefore, it is not always a good idea to keep it transient in memory. Since the logical and physical structures are correlated, the modeller rather keeps track only of the current branch, updating the current global matrix at each change of the level in geometry. The current physical node is not an object that can be asked for at a given moment, but rather represented by the combination: current node/current global matrix. However, physical nodes have unique ID's that can be retrieved for a given modeller state. These can be fed back to the modeller in order to force a physical node to become current. The advantage of this comes from the fact that all navigation queries check first the current node; therefore the location of a point in the geometry can be saved as a starting state for later use. </para>
<para>Nodes can be declared as <code>overlapping</code> in case they do overlap with other nodes inside the same container or extrude this container (see also ‘Checking the Geometry’). Non-overlapping nodes can be created with:</para>

<programlisting language="c++">
TGeoVolume::AddNode(TGeoVolume *daughter,Int_t copy_No,TGeoMatrix *matr);
</programlisting>

<para>The creation of overlapping nodes can be done with a similar prototype:</para>

<programlisting language="c++">
TGeoVolume::AddNodeOverlap(<code>/*same arguments*/</code>);
</programlisting>

<para>When closing the geometry, overlapping nodes perform a check of possible overlaps with their neighbors. These are stored and checked all the time during navigation; therefore, navigation is slower when embedding such nodes into geometry. Nodes have visualization attributes as the volume has. When undefined by users, painting a node on a pad will take the corresponding volume attributes.</para>
</sect2>

<sect2>
<title>Creating and Positioning Volumes</title>

<sect3>
<title>Making Volumes</title>
<para>As mentioned before, volumes are the basic objects used in building the geometrical hierarchy. They represent objects that are not positioned, but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. As it was explained, in order to create a volume, one has to put together a shape and a medium, which are already defined. </para>
<para>Volumes have to be named by users at creation time. Every different name may represent a unique volume object, but may also represent more general a family (class) of volume objects having the same shape type and medium, but possibly different shape parameters. It is the user's task to provide different names for different volume families in order to avoid ambiguities at tracking time.</para>
<para>A generic family rather than a single volume is created only in two cases: when a parametric shape is used or when a division operation is applied. Each volume in the geometry stores a unique ID corresponding to its family. In order to ease-up their creation, the manager class is providing an API that allows making a shape and a volume in a single step.</para>
</sect3>

<sect3>
<title>Example of Volume Creation</title>

<programlisting language="c++">
<emphasis role="italic"><code>// Making a volume out of a shape and a medium.</code></emphasis>
TGeoVolume *vol = new TGeoVolume(“VNAME”,ptrShape,ptrMed);

<emphasis role="italic"><code>// Making a volume out of a shape but without a defined medium.</code></emphasis>
TGeoVolume *vol = new TGeoVolume(“VNAME”,ptrShape);

<emphasis role="italic"><code>// Making a volume with a given shape in one step</code></emphasis>
TGeoVolume *vol = gGeoManager-&gt;MakeBox(“VNAME”,ptrMed,dx,dy,dz);
TGeoVolume *vol = gGeoManager-&gt;MakeTubs(“VNAME”,ptrMed,rmin,rmax,dz,phi1,phi2);

<emphasis role="italic"><code>// See class TGeoManager for the rest of shapes.</code></emphasis>
<emphasis role="italic"><code>// Making a volume with a given shape with a unique prototype</code></emphasis>
TGeoVolume *vol = gGeoManager-&gt;Volume(“VNAME”,“XXXX”,nmed,upar,npar);

<emphasis role="italic"><code>// Where XXXX stands for the first 4 letters of the specific shape </code></emphasis>
<emphasis role="italic"><code>// classes, nmed is the medium number, upar is an Double_t * array of </code></emphasis>
<emphasis role="italic"><code>// the shape parameters and npar is the number of parameters. This </code></emphasis>
<emphasis role="italic"><code>// prototype allows (npar = 0) to define volumes with shape defined only </code></emphasis>
<emphasis role="italic"><code>// at positioning time (volumes defined in this way need to be </code></emphasis>
<emphasis role="italic"><code>// positioned using TGeoManager::Node() method) </code></emphasis>
</programlisting>

</sect3>

<sect3>
<title>Positioned Volumes (Nodes)</title>
<para>Geometrical modeling is a difficult task when the number of different geometrical objects is 106-108. This is more or less the case for detector geometries of complex experiments, where a ‘flat’ CSG model description cannot scale with the current CPU performances. This is the reason why models like GEANT [1] introduced an additional dimension (depth) in order to reduce the complexity of the problem. This concept is also preserved by the ROOT modeller and introduces a pure geometrical constraint between objects (volumes in our case) – containment. This means in fact that any positioned volume has to be contained by another. Now what means contained and positioned?</para>
<itemizedlist>
<listitem><para>We will say that a volume <code>contains</code> a point if this is inside the shape associated to the volume. For instance, a volume having a box shape will contain all points <code>P=(X,Y,Z)</code> verifying the conditions: <code>Abs(Pi)dXi</code>. The points on the shape boundaries are considered as inside the volume. The volume contains a daughter if it contains all the points contained by the daughter.</para></listitem>
<listitem><para>The definition of containment works of course only with points defined in the local coordinate system of the considered volume. <code>Positioning</code> a volume inside another have to introduce a geometrical transformation between the two. If <code>M</code> defines this transformation, any point in the daughter reference can be converted to the mother reference by:  <code>Pmother = MPdaughter</code></para></listitem>
</itemizedlist>
<para>When creating a volume one does not specify if this will contain or not other volumes. Adding daughters to a volume implies creating those and adding them one by one to the list of daughters. Since the volume has to know the position of all its daughters, we will have to supply at the same time a geometrical transformation with respect to its local reference frame for each of them.</para>

<programlisting language="c++">
TGeoVolume::AddNode(TGeoVolume *daughter,Int_t usernumber,
TGeoMatrix *matrix=gGeoIdentity)
</programlisting>

<para>The objects referencing a volume and a transformation are called <code>NODES</code> and their creation is fully handled by the modeller. They represent the link elements in the hierarchy of volumes. Nodes are unique and distinct geometrical objects ONLY from their container point of view. Since volumes can be replicated in the geometry, the same node may be found on different branches.</para>
<para>In order to provide navigation features, volumes have to be able to find the proper container of any point defined in the local reference frame. This can be the volume itself, one of its positioned daughter volumes or none if the point is actually outside. On the other hand, volumes have to provide also other navigation methods such as finding the distances to its shape boundaries or which daughter will be crossed first. The implementation of these features is done at shape level, but the local mother-daughters management is handled by volumes. These build additional optimization structures upon geometry closure. In order to have navigation features properly working one has to follow some rules for building a valid geometry.</para>
<itemizedlist>
<listitem><para>The daughter volume(s) must not extrude the mother shape. They are allowed however to have a common boundaries.</para></listitem>
<listitem><para>The volumes positioned in the same container must not overlap with each other. They may touch on one boundaries or shape vertex.</para></listitem>
</itemizedlist>
<para>The daughter nodes of a volume can be also removed or replaced with other nodes:</para>

<programlisting language="c++">
void RemoveNode(TGeoNode* node)
TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,
TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0)
</programlisting>

<para>The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node but having exactly the same parameters as the old one. This helps in case of divisions for decoupling a node from the logical hierarchy so getting new content/properties. For non-divided volumes, one can change the shape and/or the position of the daughter.</para>
</sect3>

<sect3>
<title>Virtual Containers and Assemblies of Volumes</title>
<para>Virtual containers are volumes that do not represent real objects, but they are needed for grouping and positioning together other volumes. Such grouping helps not only geometry creation, but also optimizes tracking performance; therefore, it is highly recommended. Virtual volumes need to inherit material/medium properties from the volume they are placed into in order to be “invisible” at tracking time.</para>
<para>Let us suppose that we need to group together two volumes <code>A</code> and <code>B</code> into a structure and position this into several other volumes <code>D,E,</code> and <code>F</code>. What we need to do is to create a virtual container volume <code>C</code> holding <code>A</code> and <code>B</code>, then position <code>C</code> in the other volumes.</para>
<para>Note that <code>C</code> is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of <code>D,E</code> or <code>F</code> in order to make it ‘invisible’ (same physics properties). In other words, the limitation in proceeding this way is that <code>D,E,</code> and <code>F</code> must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: <code>C</code>, <code>C’</code> and <code>C”</code>, having the same shape but different media matching the corresponding containers. This might not happen so often, but when it does, it forces the creation of several extra virtual volumes. Other limitation comes from the fact that any container is directly used by navigation algorithms to optimize tracking. These must geometrically contain their belongings (positioned volumes) so that these do not extrude its shape boundaries. Not respecting this rule generally leads to unpredictable results. Therefore <code>A</code> and <code>B</code> together must fit into <code>C</code> that has to fit also into <code>D,E,</code> and <code>F</code>. This is not always straightforward to accomplish, especially when instead of <code>A</code> and <code>B</code> we have many more volumes.</para>
<para>In order to avoid these problems, one can use for the difficult cases the class <emphasis role="bold"><code>TGeoVolumeAssembly</code></emphasis>, representing an assembly of volumes. This behaves like a normal container volume supporting other volumes positioned inside, but it has neither shape nor medium. It cannot be used directly as a piece of the geometry, but just as a temporary structure helping temporary assembling and positioning volumes.</para>
<para>If we define now <code>C</code> as an assembly containing <code>A</code> and <code>B</code>, positioning the assembly into <code>D,E</code> and <code>F</code> will actually position only <code>A</code> and <code>B </code>directly into these volumes, taking into account their combined transformations <code>A/B</code> to <code>C</code> and <code>C</code> to <code>D/E/F</code>. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ‘unnecessary’ volume <code>C</code> in our geometry, but we end-up with a more flat structure for <code>D,E</code> and <code>F</code> (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.</para>
<para>For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both cases, after the geometry was closed:</para>

<programlisting language="c++">
gGeoManager-&gt;SetTopVolume(ptr_D);
gGeoManager-&gt;Test();
gGeoManager-&gt;RestoreMasterVolume();
</programlisting>

<para>The <code>ptr_D</code> is a pointer to volume <code>D</code> containing the interesting structure. The test will provide the timing for classifying 1 million random points inside <code>D</code>.</para>
</sect3>

<sect3>
<title>Examples of Volume Positioning</title>
<para>Now let us make a simple volume representing a copper wire. We suppose that a medium is already created (see <emphasis role="bold"><code>TGeoMedium</code></emphasis> class on how to create media). </para>
<para>We will create a <code>TUBE</code> shape for our wire, having <code>Rmin=0cm</code>, <code>Rmax=0.01cm</code> and a half-length <code>dZ=1cm</code>:  </para>

<programlisting language="c++">
TGeoTube <code>*tube = new TGeoTube("wire_tube",0,0.01,1);</code>
</programlisting>

<para>One may omit the name for the shape <code>wire_tube,</code> if no retrieving by name is further needed during geometry building. Different volumes having different names and materials can share the same shape. </para>
<para>Now let's make the volume for our wire:</para>

<programlisting language="c++">
TGeoVolume <code>*wire_co = new TGeoVolume("WIRE_CO",tube,ptrCOPPER); </code><code>//(*)</code>
</programlisting>

<para><emphasis role="bold">(*)</emphasis>Do not bother to delete the media, shapes or volumes that you have created since all will be automatically cleaned on exit by the manager class.</para>
<para>If we would have taken a look inside <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::MakeTube()</code> method, we would have been able to create our wire with a single line:</para>

<programlisting language="c++">
TGeoVolume *wire_co = gGeoManager-&gt;MakeTube("WIRE_CO",ptrCOPPER,0,0.01,1); <code>//(*)</code>
</programlisting>

<para><emphasis role="bold">(*)</emphasis>The same applies for all primitive shapes, for which there can be found corresponding <code>MakeSHAPE()</code> methods. Their usage is much more convenient unless a shape has to be shared between more volumes. </para>
<para>Let us make now an aluminum wire having the same shape, supposing that we have created the copper wire with the line above: </para>

<programlisting language="c++">
TGeoVolume *wire_al = new TGeoVolume("WIRE_AL",wire_co&gt;GetShape(),ptrAL);
</programlisting>

<para>We would like now to position our wire in the middle of a gas chamber. We need first to define the gas chamber:</para>

<programlisting language="c++">
TGeoVolume *chamber = gGeoManager-&gt;MakeTube("CHAMBER",ptrGAS,0,1,1);
</programlisting>

<para>Now we can put the wire inside:</para>

<programlisting language="c++">
chamber-&gt;AddNode(wire_co,1);
</programlisting>

<para>If we inspect now the chamber volume in a browser, we will notice that it has one daughter. Of course, the gas has some container also, but let us keeps it like that for the sake of simplicity. Since we did not supply the third argument, the wire will be positioned with an identity transformation inside the chamber. </para>
</sect3>

<sect3>
<title>Overlapping Volumes</title>
<para>Positioning volumes that does not overlap their neighbors nor extrude their container is sometimes quite strong constraint. Having a limited set of geometric shapes might force sometimes overlaps. Since overlapping is contradictory to containment, a point belonging to an overlapping region will naturally belong to all overlapping partners. The answer provided by the modeller to “Where am I?” is no longer deterministic if there is no priority assigned. </para>
<para>There are two ways out provided by the modeller in such cases and we will illustrate them by examples.</para>
<itemizedlist>
<listitem><para>Suppose we have 2 crossing tubes that we have to describe. Such a structure cannot be decomposed in a containment schema. This is a typical example of simple structure that can be handled by using composite shapes. What we have to do is to define as shapes the inner and outer parts of the tubes (tubes having <code>Rmin=0</code>,<code> Rmax=</code>inner/outer radius), then to make a composite:</para></listitem>
<listitem><para>    <code>C = (Tub1out+Tub2out)-(Tub1in+Tub2in)</code></para></listitem>
<listitem><para>On the other hand, if we have an EM calorimeter having a honeycomb structure, Boolean combinations do not help anymore. Here the problem is that we usually have a very large number of cells that are naturally belonging to the same container. This result in a very flat and slow structure for that particular container, which we would very much want to avoid by introducing additional levels in depth. We can describe the basic cell as a hexahedron that we can represent by using a polygon primitive shape. Instead of putting one by one all cells in the same container, we can define rows of such elements, fitting in box-shaped containers. Then we can put row-beside-row inside the container, making life much easier for its navigation algorithms. The problem is that in order to reproduce the honeycomb structure out of rows of cells, we have to overlap row containers. Woops – we have not obeyed rule No. 2 in positioning. The way out is to position our rows with a special prototype:</para></listitem>
</itemizedlist>
<programlisting language="c++">
ptrCAL-&gt;AddNodeOverlap(“ROW”,nRow,matrixRow);
</programlisting>

<para>This will instruct the modeller that the daughter ROW inside CAL overlaps with something else. The modeller will check this at closure time and build a list of possibly overlapping candidates. This option is equivalent with the option MANY in GEANT3.</para>
<para>The modeller supports such cases only if user declares the overlapping nodes. In order to do that, one should use <emphasis role="bold"><code>TGeoVolume</code></emphasis><code>::AddNodeOverlap()</code> instead of <emphasis role="bold"><code>TGeoVolume</code></emphasis><code>::AddNode()</code>. When two or more positioned volumes are overlapping, not all of them have to be declared so, but at least one. A point inside an overlapping region equally belongs to all overlapping nodes, but the way these are defined can enforce the modeller to give priorities.</para>
<para>The general rule is that the deepest node in the hierarchy containing a point has the highest priority. For the same geometry level, non-overlapping is prioritized over overlapping. In order to illustrate this, we will consider few examples. We will designate non-overlapping nodes as ONLY and the others MANY as in GEANT3, where this concept was introduced:</para>
<para>1. The part of a MANY node B extruding its container A will never be "seen"  during navigation, as if B was in fact the result of the intersection of A and B.</para>
<para>2. If we have two nodes A (ONLY) and B (MANY) inside the same container, all points in the overlapping region of A and B will be designated as belonging to A.</para>
<para>3. If A an B in the above case were both MANY, points in the overlapping part will be designated to the one defined first. Both nodes must have the same medium.</para>
<para>4. The slices of a divided MANY will be as well MANY.</para>
<para>One needs to know that navigation inside geometry parts MANY nodes is much slower. Any overlapping part can be defined based on composite shapes – might be in some cases a better way out. </para>
</sect3>

<sect3>
<title>Replicating Volumes</title>
<para>What can we do if our chamber contains two identical wires instead of one? What if then we would need 1000 chambers in our detector? Should we create 2000 wires and 1000 chamber volumes? No, we will just need to replicate the ones that we have already created.</para>

<programlisting language="c++">
chamber-&gt;AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));
chamber-&gt;AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));
</programlisting>

<para>The 2 nodes that we have created inside chamber will both point to a <code>wire_co</code> object, but will be completely distinct: <code>WIRE_CO_1</code> and <code>WIRE_CO_2</code>. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a <code>(x,y,z)</code> point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called <code>voxels</code> to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway loose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.</para>
</sect3>

<sect3>
<title>Volume Families</title>
<para>A volume family is represented by the class <emphasis role="bold"><code>TGeoVolumeMulti</code></emphasis>. It represents a class of volumes having the same shape type and each member will be identified by the same name and volume ID. Any operation applied to a <emphasis role="bold"><code>TGeoVolumeMulti</code></emphasis> equally affects all volumes in that family. The creation of a family is generally not a user task, but can be forced in particular cases:</para>

<programlisting language="c++">
TGeoManager::Volume(const char *vname,const char *shape,Int_t nmed);
</programlisting>

<para>Where: <code>vname</code> is the family name, <code>nmed</code> is the medium number and <code>shape</code> is the shape type that can be:</para>
<itemizedlist>
<listitem><para>  <code>box</code>for <emphasis role="bold"><code>TGeoBBox</code></emphasis></para></listitem>
<listitem><para>  <code>trd1</code>for <emphasis role="bold"><code>TGeoTrd1</code></emphasis></para></listitem>
<listitem><para>  <code>trd2</code>for <emphasis role="bold"><code>TGeoTrd2</code></emphasis></para></listitem>
<listitem><para>  <code>trap</code>for <emphasis role="bold"><code>TGeoTrap</code></emphasis></para></listitem>
<listitem><para>  <code>gtra</code>for <emphasis role="bold"><code>TGeoGtra</code></emphasis></para></listitem>
<listitem><para>  <code>para</code>for <emphasis role="bold"><code>TGeoPara</code></emphasis></para></listitem>
<listitem><para>  <code>tube</code>, <code>tubs </code>for <emphasis role="bold"><code>TGeoTube</code></emphasis>, <emphasis role="bold"><code>TGeoTubeSeg</code></emphasis></para></listitem>
<listitem><para><code> cone</code>, <code>cons </code>for <emphasis role="bold"><code>TGeoCone</code></emphasis>, <emphasis role="bold"><code>TGeoCons</code></emphasis></para></listitem>
<listitem><para>  <code>eltu</code>for <emphasis role="bold"><code>TGeoEltu</code></emphasis></para></listitem>
<listitem><para>  <code>ctub</code>for <emphasis role="bold"><code>TGeoCtub</code></emphasis></para></listitem>
<listitem><para>  <code>pcon</code>for <emphasis role="bold"><code>TGeoPcon</code></emphasis></para></listitem>
<listitem><para>  <code>pgon</code>for <emphasis role="bold"><code>TGeoPgon</code></emphasis></para></listitem>
</itemizedlist>
<para>Volumes are then added to a given family upon adding the generic name as node inside other volume:</para>

<programlisting language="c++">
TGeoVolume *box_family = gGeoManager-&gt;Volume("BOXES","box",nmed);
<code>//   ...</code>
gGeoManager-&gt;Node("BOXES",Int_t copy_no,"mother_name",Double_t x,Double_t y,
Double_t z,Int_t rot_index,Bool_t is_only,
Double_t *upar,Int_t npar);
</programlisting>
<itemizedlist>
<listitem><para><code>BOXES</code>- name of the family of boxes</para></listitem>
<listitem><para><code>copy_no</code>- user node number for the created node</para></listitem>
<listitem><para><code>mother_name</code>- name of the volume to which we want to add the node</para></listitem>
<listitem><para><code>x,y,z</code>- translation components</para></listitem>
<listitem><para><code>rot_index</code>- index of a rotation matrix in the list of matrices</para></listitem>
<listitem><para><code>upar</code>- array of actual shape parameters</para></listitem>
<listitem><para><code>npar</code>- number of parameters</para></listitem>
</itemizedlist>
<para>The parameters order and number are the same as in the corresponding shape constructors. Another particular case where volume families are used is when we want that a volume positioned inside a container to match one ore more container limits. Suppose we want to position the same box inside 2 different volumes and we want the Z size to match the one of each container:</para>

<programlisting language="c++">
TGeoVolume *container1 = gGeoManager-&gt;MakeBox("C1",imed,10,10,30);
TGeoVolume *container2 = gGeoManager-&gt;MakeBox("C2",imed,10,10,20);
TGeoVolume *pvol       = gGeoManager-&gt;MakeBox("PVOL",jmed,3,3,-1);
container1-&gt;AddNode(pvol,1);
container2-&gt;AddNode(pvol,1);
</programlisting>

<para>Note that the third parameter of <code>PVOL</code> is negative, which does not make sense as half-length on Z. This is interpreted as: when positioned, create a box replacing all invalid parameters with the corresponding dimensions of the container. This is also internally handled by the <emphasis role="bold"><code>TGeoVolumeMulti</code></emphasis> class, which does not need to be instantiated by users.</para>
</sect3>

<sect3>
<title>Dividing Volumes</title>
<para>Volumes can be divided according a pattern. The simplest division can be done along one axis that can be: <code>X,Y,Z,Phi,Rxy or Rxyz</code>. Let's take a simple case: we would like to divide a box in N equal slices along X coordinate, representing a new volume family. Supposing we already have created the initial box, this can be done like:</para>

<programlisting language="c++">
TGeoVolume *slicex = box-&gt;Divide("SLICEX",1,N);
</programlisting>

<para>Here <code>SLICEX</code> is the name of the new family representing all slices and 1 is the slicing axis. The meaning of the axis index is the following: for all volumes having shapes like <code>box</code>, <code>trd1</code>, <code>trd2</code>, <code>trap</code>, <code>gtra </code>or<code> para - </code>1, 2, 3 mean X, Y, Z; for <code>tube</code>, <code>tubs</code>, <code>cone</code>, <code>cons - </code>1 means <code>Rxy</code>, 2 means <code>phi</code> and 3 means Z; for <code>pcon</code> and <code>pgon</code> - 2 means <code>phi</code> and 3 means Z; for spheres 1 means <code>R </code>and 2 means <code>phi.</code></para>
<para>In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family.</para>
<para>Divisions can be also performed in a given range of one axis. For that, one has to specify also the starting coordinate value and the step:</para>

<programlisting language="c++">
TGeoVolume *slicex = box-&gt;Divide("SLICEX",1,N,start,step);
</programlisting>

<para>A check is always done on the resulting division range: if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 up to N. The first one has the lower X limit at <code>START</code> position, while the last one will have the upper X limit at <code>START+N*STEP</code>. The resulting slices cannot be positioned inside another volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:</para>

<programlisting language="c++">
TGeoVolume *slicey = slicex-&gt;Divide("SLICEY",2,N1);
slicey-&gt;AddNode(other_vol,index,some_matrix);
</programlisting>

<para>When doing that, we have to remember that <code>SLICEY</code> represents a family, therefore all members of the family will be divided on Y and the other volume will be added as node inside all.</para>
<para>In the example above all the resulting slices had the same shape as the divided volume (box). This is not always the case. For instance, dividing a volume with <code>TUBE</code> shape on <code>PHI </code>axis will create equal slices having <code>TUBESEG</code> shape. Other divisions can also create slices having shapes with different dimensions, e.g. the division of a <code>TRD1</code> volume on Z. </para>
<para>When positioning volumes inside slices, one can do it using the generic volume family (e.g. <code>slicey</code>). This should be done as if the coordinate system of the generic slice was the same as the one of the divided volume. The generic slice in case of <code>PHI</code> division is centered with respect to X-axis. If the family contains slices of different sizes, any volume positioned inside should fit into the smallest one.</para>
<para>Examples for specific divisions according to shape types can be found inside shape classes.</para>

<programlisting language="c++">
TGeoVolume::Divide(N,Xmin,Xmax,"X");
</programlisting>

<para>Create a new volume by dividing an existing one (GEANT3 like).</para>
<para>Divides <code>MOTHER</code> into <code>NDIV</code> divisions called <code>NAME</code> along axis <code>IAXIS</code> starting at coordinate value <code>START</code> and having size <code>STEP</code>. The created volumes will have tracking media <code>ID=NUMED</code> (if <code>NUMED=0</code> -&gt; same media as <code>MOTHER</code>).</para>
<para>The behavior of the division operation can be triggered using <code>OPTION</code> (case insensitive):</para>
<itemizedlist>
<listitem><para>   <code>N</code>divide all range in <code>NDIV</code> cells (same effect as <code>STEP&lt;=0</code>)  (GSDVN in G3)</para></listitem>
<listitem><para>   <code>NX</code>divide range starting with <code>START</code> in <code>NDIV</code> cells (GSDVN2 in G3)</para></listitem>
<listitem><para>   <code>S</code>divide all range with given <code>STEP</code>; <code>NDIV</code> is computed and divisions will be centered in full range (same effect as <code>NDIV&lt;=0</code>)  (GSDVS, GSDVT in G3)</para></listitem>
<listitem><para>   <code>SX</code>same as <code>DVS</code>, but from <code>START</code> position  (GSDVS2, GSDVT2 in G3)</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Volume Assemblies</title>
<para>In general, geometry contains structures of positioned volumes that have to be grouped and handled together, for different possible reasons. One of these is that the structure has to be replicated in several parts of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.</para>
<para>Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry.  There are few ways out of this:</para>
<itemizedlist>
<listitem><para>Defining the container for the structure as “overlapping” (see also “ Overlapping Volumes <emphasis role="bold">”</emphasis>)</para></listitem>
<listitem><para>Representing the container as a composite shape – the Boolean union of all components (see also “ Composite Shapes ”)</para></listitem>
<listitem><para>Using an assembly volume – this will be described in the following.</para></listitem>
</itemizedlist>
<para>The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure.
The best solution is the third one because it uses all volume-related navigation optimizations. The class <emphasis role="bold"><code>TGeoVolumeAssembly</code></emphasis> represents
an assembly volume. Its shape is represented by <emphasis role="bold"><code>TGeoShapeAssembly</code></emphasis> class that is the union of all components. It uses volume voxelization
to perform navigation tasks.</para>
<para>An assembly volume creates a hierarchical level and it geometrically insulates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a <emphasis role="bold"><code>TGeoShapeAssembly</code></emphasis> is always inside one of the components, so a <emphasis role="bold"><code>TGeoVolumeAssembly</code></emphasis> does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at:  <uri xmlns:xlink="http://root.cern.ch/root/html/examples/assembly.C.html">http://root.cern.ch/root/html/examples/assembly.C.html</uri><code>.</code></para>
<para>Creation of an assembly is very easy:  one has just to create a <emphasis role="bold"><code>TGeoVolumeAssembly</code></emphasis> object and position the components inside as for any volume:</para>

<programlisting language="c++">
TGeoVolume *vol = new TGeoVolumeAssembly(name);
vol-&gt;AddNode(vdaughter1, cpy1, matrix1);
vol-&gt;AddNode(vdaughter2, cpy2, matrix2);
</programlisting>

<para>Note that components cannot be declared as “overlapping” and that a component can be an assembly volume.  For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible.</para>

<figure><title>Assemblies of volumes</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001CF.png" width="235.25pt" depth="162pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>
</sect2>

<sect2>
<title>Geometrical Transformations</title>
<para>All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in <emphasis role="bold"><code>TGeo</code></emphasis> has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If <code>T</code> is a transformation used for positioning volume daughters, then: <code>MASTER = T * LOCAL</code></para>
<para>Therefore <code>T </code>is used to perform a local to master conversion, while <code>T-1</code> for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.</para>
<para>A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.</para>
<para>Rotation:     Translation:     Scale                             </para>

<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001D0.png" width="68.3pt" depth="61.45pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001D1.png" width="59.6pt" depth="63.3pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001D2.png" width="65.8pt" depth="61.45pt"/></imageobject></inlinemediaobject>
</para>

<para>Inverse rotation:Inverse translation:Inverse scale:</para>

<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001D3.png" width="68.3pt" depth="61.45pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001D4.png" width="81.95pt" depth="63.3pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001D5.png" width="92.5pt" depth="61.45pt"/></imageobject></inlinemediaobject>
</para>

<itemizedlist>
<listitem><para><code>rij</code>         are the 3x3 rotation matrix components </para></listitem>
<listitem><para><code>tx,ty,tz</code> are the translation components</para></listitem>
<listitem><para><code>sx,sy,sz</code> are arbitrary scale constants on each axis</para></listitem>
</itemizedlist>
<para>The disadvantage in using this approach is that computation for 4x4 matrices is expensive. Even combining two translations would become a multiplication of their corresponding matrices, which is quite an undesired effect. On the other hand, it is not a good idea to store a translation as a block of 16 numbers. We have therefore chosen to implement each basic transformation type as a class deriving from the same basic abstract class and handling its specific data and point/vector transformation algorithms.</para>
<para>The base class <emphasis role="bold"><code>TGeoMatrix</code></emphasis> defines abstract methods for:</para>
<itemizedlist>
<listitem><para>Translation, rotation and scale getters. Every derived class stores only its specific data, e.g. a translation stores an array of 3 doubles and a rotation an array of 9. However, getting the <emphasis role="bold"><code>TGeoTranslation</code></emphasis> rotation array through the base <emphasis role="bold"><code>TGeoMatrix</code></emphasis> interface is a legal operation. The answer in this case is a pointer to a global constant array representing an identity rotation.</para></listitem>
</itemizedlist>
<programlisting language="c++">
Double_t *TGeoMatrix::GetTranslation() const;
Double_t *TGeoMatrix::GetRotation() const;
Double_t *TGeoMatrix::GetScale() const;
</programlisting>
<itemizedlist>
<listitem><para>Master-to-local and local-to-master point and vector transformations :</para></listitem>
</itemizedlist>
<programlisting language="c++">
void TGeoMatrix::MasterToLocal(const Double_t *master,Double_t *local)
void TGeoMatrix::LocalToMaster(const Double_t *local,Double_t *master)
void TGeoMatrix::MasterToLocalVect(const Double_t *master,Double_t *local)
void TGeoMatrix::LocalToMasterVect(const Double_t *local,Double_t *master)
</programlisting>

<para>Here <code>master</code> and <code>local</code> are arrays of size 3. These methods allow correct conversion also for reflections.</para>
<itemizedlist>
<listitem><para>Transformation type finding:</para></listitem>
</itemizedlist>
<programlisting language="c++">
Bool_t TGeoMatrix::IsIdentity() const;
Bool_t TGeoMatrix::IsTranslation() const;
Bool_t TGeoMatrix::IsRotation() const;
Bool_t TGeoMatrix::IsScale() const;
Bool_t TGeoMatrix::IsCombi() const;   <code>// (tr. </code><code>+ rot.)</code>
Bool_t TGeoMatrix::IsGeneral() const; <code>// (tr. + rot. + scale)</code>
</programlisting>

<para>Specific classes deriving from <emphasis role="bold"><code>TGeoMatrix</code></emphasis> represent combinations of basic transformations. In order to define a matrix as a combination of several others, a special class <emphasis role="bold"><code>TGeoHMatrix</code></emphasis> is provided. Here is an example of matrix creation:</para>

<sect3>
<title>Matrix Creation Example</title>

<programlisting language="c++">
TGeoRotation r1,r2;
r1.SetAngles(90,0,30);          <code>//rotation defined by Euler angles</code>
r2.SetAngles(90,90,90,180,0,0); <code>//rotation defined by GEANT3 angles</code>
TGeoTranslation t1(-10,10,0);
TGeoTranslation t2(10,-10,5);
TGeoCombiTrans c1(t1,r1);
TGeoCombiTrans c2(t2,r2);
TGeoHMatrix h = c1 * c2;        <code>// composition is done via TGeoHMatrix class</code>
TGeoHMatrix *ph = new TGeoHMatrix(hm); <code>// it is what we want to</code> <code>use for</code>
<code>                                       // positioning a volume</code>
ph-&gt;Print();
...
pVolume-&gt;AddNode(pVolDaughter,id,ph)   <emphasis role="italic"><code>// now ph is owned by the manager</code></emphasis>
</programlisting>

</sect3>

<sect3>
<title>Rule for Creation of Transformations</title>
<para>Unless explicitly used for positioning nodes <code>(</code><emphasis role="bold"><code>TGeoVolume</code></emphasis><code>::AddNode())</code> all matrices deletion have to be  managed by users. Matrices passed to geometry have to be created by using <code>new()</code> operator and <emphasis role="bold"><code>TGeoManager</code></emphasis> class is responsible for their deletion. Matrices that are used for the creation of composite shapes have to be named and registered to the manager class:</para>

<programlisting language="c++">
transf-&gt;SetName(name);       <emphasis role="italic"><code>// if not already named in the constructor</code></emphasis>
transf-&gt;RegisterYourself();
</programlisting>

<para>Generally, it is advisable to create all intermediate transformations used for making the final combined one on the heap:</para>

<programlisting language="c++">
TGeoRotation r1(…);
TGeoRotation r2(…);
<code>TGeoHMatrix *mat = new TGeoHMatrix(“name”); </code>    <emphasis role="italic"><code>// we want to use only this</code></emphasis>
<emphasis role="italic"><code>// one in geometry</code></emphasis>
*mat = r1 * r2;
</programlisting>

</sect3>

<sect3>
<title>Available Geometrical Transformations</title>
<itemizedlist>
<listitem><para>Translations (<emphasis role="bold"><code>TGeoTranslation</code></emphasis> class) represent a <code>(dx,dy,dz)</code> translation. The only data member is:  <code>Double_t fTranslation[3]</code>. Translations can be added or subtracted.</para></listitem>
</itemizedlist>
<programlisting language="c++">
TGeoTranslation t1;
t1-&gt;SetTranslation(-5,10,4);
TGeoTranslation *t2 = new TGeoTranslation(4,3,10);
t2-&gt;Subtract(&amp;t1);
</programlisting>
<itemizedlist>
<listitem><para>Rotations (<emphasis role="bold"><code>TGeoRotation</code></emphasis> class) represent a pure rotation. Data members are <code>Double_t fRotationMatrix[3*3]</code>. Rotations can be defined either by Euler angles, either, by GEANT3 angles:</para></listitem>
</itemizedlist>
<programlisting language="c++">
TGeoRotation *r1 = new TGeoRotation();
r1-&gt;SetAngles(phi,theta,psi);        <code>// all angles in degrees</code>
</programlisting>

<para>This represents the composition of: first a rotation about Z axis with angle phi, then a rotation with theta about the rotated X axis, and finally a rotation with <code>psi </code>about the new Z axis.</para>

<programlisting language="c++">
r1-&gt;SetAngles(th1,phi1,th2,phi2,th3,phi3)
</programlisting>

<para>This is a rotation defined in GEANT3 style. Theta and phi are the spherical angles of each axis of the rotated coordinate system with respect to the initial one. This construction allows definition of malformed rotations, e.g. not orthogonal. A check is performed and an error message is issued in this case.</para>
<para>Specific utilities: determinant, inverse.</para>
<itemizedlist>
<listitem><para>Scale transformations (<emphasis role="bold"><code>TGeoScale</code></emphasis> class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: <code>Double_t fScale[3]</code>. Not implemented yet.</para></listitem>
<listitem><para>Combined transformations - represent a rotation followed by a translation. Data members: <code>Double_t fTranslation[3], </code><emphasis role="bold"><code>TGeoRotation</code></emphasis><code> *fRotation</code>.</para></listitem>
</itemizedlist>
<programlisting language="c++">
TGeoRotation *rot = new TGeoRotation("rot",10,20,30);
TGeoTranslation trans;
...
TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);
TGeoCombiTrans *c2 = new TGeoCombiTrans("somename",10,20,30,rot)
</programlisting>
<itemizedlist>
<listitem><para>General transformations: (<emphasis role="bold"><code>TGeoHMatrix</code></emphasis> class) represent combined transformations in any order.</para></listitem>
<listitem><para>Identity transformation: (<emphasis role="bold"><code>TGeoIdentity</code></emphasis> class) is a generic identity transformation represented by a singleton class object <emphasis role="bold"><code>gGeoIdentity</code></emphasis>. </para></listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2>
<title>Ownership of Geometry Objects</title>
<para>The class <emphasis role="bold"><code>TGeoManager</code></emphasis> class contains the entire API needed for building and tracking geometry. It defines a global pointer <emphasis role="italic"><emphasis role="bold"><code>gGeoManager</code></emphasis></emphasis> in order to be fully accessible from external code. The manager class is the owner of all geometry objects defined in a session; therefore, users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. A special case is the one of geometrical transformations. When creating a matrix or a translation, this is by default owned by external objects. The manager class becomes owner of all transformations used for positioning volumes. In order to force the ownership for other transformations, one can use <emphasis role="bold"><code>TGeoMatrix</code></emphasis><code>::RegisterYourself()</code> method. Do not be therefore surprised that some transformations cannot be found by name when creating a composite shape for instance if you did not register them after creation.</para>
<para>Logical nodes (positioned volumes) are created and destroyed by the <emphasis role="bold"><code>TGeoVolume</code></emphasis> class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of <emphasis role="bold"><code>TGeoManager</code></emphasis>. The manager class also controls the drawing/checking package (<emphasis role="bold"><code>TGeoPainter</code></emphasis> client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions.</para>
</sect2>
</sect1>

<sect1>
<title>Navigation and Tracking</title>
<para>Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position <inlinemediaobject><imageobject><imagedata fileref="pictures/080001D6.png" width="9.95pt" depth="13.05pt"/></imageobject></inlinemediaobject> and direction <inlinemediaobject><imageobject><imagedata fileref="pictures/080001D7.png" width="9.95pt" depth="13.65pt"/></imageobject></inlinemediaobject> with respect to the world reference frame. The direction <inlinemediaobject><imageobject><imagedata fileref="pictures/080001D8.png" width="9.95pt" depth="13.65pt"/></imageobject></inlinemediaobject> must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.</para>
<para>We will hereby describe the user interface of <emphasis role="bold"><code>TGeo</code></emphasis> to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in <code>$ROOTSYS/vmc</code> folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.</para>
<para>The interface methods related to tracking are incorporated into <emphasis role="bold"><code>TGeoManager</code></emphasis> class and implemented in the navigator class <emphasis role="bold"><code>TGeoNavigator</code></emphasis>. In order to be able to start tracking, one has to define the initial state providing the starting point <inlinemediaobject><imageobject><imagedata fileref="pictures/080001D9.png" width="11.15pt" depth="18pt"/></imageobject></inlinemediaobject> and direction<inlinemediaobject><imageobject><imagedata fileref="pictures/080001DA.png" width="13.65pt" depth="18pt"/></imageobject></inlinemediaobject>. There are several ways of doing that.</para>

<sect2>
<title>TGeoNavigator Class</title>
<para>One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:</para>

<programlisting language="c++">
TObjArray *navigators = gGeoManager-&gt;GetListOfNavigators();
</programlisting>

<para>Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:</para>

<programlisting language="c++">
TGeoNavigator *navig = new TGeoNavigator(gGeoManager);
<emphasis role="italic"><code>// Store the index of the user navigator </code></emphasis>
Int_t inav = gGeoManager-&gt;AddNavigator(navig);
// Make its own navigator the active one
gGeoManager-&gt;SetCurrentNavigator(inav);
// Switch between navigators
gGeoManager-&gt;SetCurrentNavigator(0);
</programlisting>

<para>A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator.  All setters/getters for navigation state parameters as well as navigation queries provided by <emphasis role="bold"><code>TGeoNavigator</code></emphasis> are interfaced by <emphasis role="bold"><code>TGeoManager</code></emphasis> and will act on the current navigator.</para>
</sect2>

<sect2>
<title>Initializing the Starting Point</title>
<para>The current point (<code>x,y,z</code>) known by the modeller is stored as <code>Double_t fCurrentPoint[3]</code> by the navigator class. This array of the three coordinates is defined in the current global reference system and can be retrieved any time:</para>

<programlisting language="c++">
Const Double_t *cpoint = gGeoManager-&gt;GetCurrentPoint();
</programlisting>

<para>Initializing this point can be done like:</para>

<programlisting language="c++">
gGeoManager-&gt;SetCurrentPoint(x,y,z);
<emphasis role="italic"><code>// or:</code></emphasis>
gGeoManager-&gt;SetCurrentPoint(Double_t *point[3]);
</programlisting>

</sect2>

<sect2>
<title>Initializing the Direction</title>
<para>In order to move inside geometry starting with the current point, the modeller needs to know the current direction <code>(nx,ny,nz)</code>. This direction is stored as  <code>Double_t fCurrentDirection[3]</code>         by the navigator and it represents a direction in the global frame. It can be retrieved with: </para>

<programlisting language="c++">
Const Double_t *cdir = gGeoManager-&gt;GetCurrentDirection();
</programlisting>

<para>The direction can be initialized in a similar manner as the current point:</para>

<programlisting language="c++">
gGeoManager-&gt;SetCurrentDirection(nx,ny,nz);
<emphasis role="italic"><code>// or:</code></emphasis>
gGeoManager-&gt;SetCurrentDirection(Double_t *dir);
</programlisting>

</sect2>

<sect2>
<title>Initializing the State</title>
<para>Setting the initial point and direction is not enough for initializing tracking. The modeller needs to find out where the initial point is located in the geometrical hierarchy. Due to the containment based architecture of the model, this is the deepest positioned object containing the point. For illustrating this, imagine that we have a simple structure with a top volume <code>A</code> and another one <code>B </code>positioned inside. Since <code>A </code>is a top volume, its associated node <code>A_1</code> will define <code>MARS</code> and our simple hierarchy of nodes (positioned volumes) will be: <code>/A_1/B_1</code>. Suppose now that the initial point is contained by <code>B_1</code>. This implies by default that the point is also contained by <code>A_1</code>, since <code>B_1</code> have to be fully contained by this. After searching the point location, the modeller will consider that the point is located inside <code>B_1</code>, which will be considered as the representative object (node) for the current state. This is stored as: <emphasis role="bold"><code>TGeoNode</code></emphasis> *<emphasis role="bold"><code>TGeoManager</code></emphasis><code>::fCurrentNode </code>and can be asked from the manager class only after the <code>’Where am I?’</code> was completed:</para>

<programlisting language="c++">
TGeoNode *current = gGeoManager-&gt;GetCurrentNode();
</programlisting>

<para>In order to find the location of the current point inside the hierarchy of nodes, after setting this point it is mandatory to call the <code>‘Where am I?’</code>  method:</para>

<programlisting language="c++">
gGeoManager-&gt;FindNode();
</programlisting>

<para>In order to have more flexibility, there are in fact several alternative ways of initializing a modeller state:</para>

<programlisting language="c++">
<emphasis role="italic"><code>// Setting the point and finding the state in one step:</code></emphasis>
gGeoManager-&gt;FindNode(Double_t x,Double_t y,Double_t z);
gGeoManager-&gt;FindNode(Double_t *point[3]);
<emphasis role="italic"><code>// Setting both initial point and direction and finding the state:</code></emphasis>
<code>gGeoManager-&gt;InitTrack(Double_t x,Double_t y,Double_t z,Double_t nx,</code>
<code>                       Double_t ny,Double_t nz);</code>
<code>gGeoManager-&gt;InitTrack(Double_t *point[3],Double_t *dir[3]);</code>
</programlisting>

<para>Note that the current point coordinates can be changed and the state re-initialized at any time. This represents the <code>‘Where am I?’</code> geometrical query representing the basic navigation functionality provided by the modeller.</para>
</sect2>

<sect2>
<title>Checking the Current State</title>
<para>The current state and all variables related to this are essential during tracking and have to be checked several times. Besides the current point and direction, the following additional information can be retrieved from <emphasis role="bold"><code>TGeoManager</code></emphasis> interface:</para>
<itemizedlist>
<listitem><para>The <code>current path</code>. This represents a string containing the names and copy numbers of all positioned objects in the current <code>branch</code> written in the /folder/folder/…/folder/file fashion. The final node pointed by the path is the deepest object containing the current point and is representative for the current state. All intermediate <code>folders</code> in the path are in fact also nodes “touched” by the current point, but having some “touched” containment. The current path can be retrieved only after the state was initialized and is useful for getting an idea of the current point location.</para></listitem>
</itemizedlist>
<programlisting language="c++">
const char *path = gGeoManager-&gt;GetPath();
cout &lt;&lt; “Current path is: “ &lt;&lt; path &lt;&lt; endl;
<code>/A_1/B_34/C_3/D_1</code>
</programlisting>
<itemizedlist>
<listitem><para>The <code>current node</code><emphasis role="italic"><emphasis role="bold"><code>, </code></emphasis></emphasis><code>volume</code>         and         <code>material</code>. In order to take decisions on post-step or further stepping actions, one has to know these. In order to get a pointer to the current node one can do:</para></listitem>
</itemizedlist>
<programlisting language="c++">
TGeoNode *cnode = gGeoManager-&gt;GetCurrentNode();
<emphasis role="italic"><code>// then:</code></emphasis>
TGeoVolume *cvol = gGeoManager-&gt;GetCurrentVolume();
<code>// or:</code>
cvol = cnode-&gt;GetVolume();    // <code>(*)</code>
<emphasis role="italic"><code>// then:</code></emphasis>
TGeoMaterial *cmat = cvol-&gt;GetMedium()-&gt;GetMaterial();
</programlisting>

<para>(*) Note: If the current point is in fact outside the geometry, the current node pointer will not be NULL, but pointing to the top node.</para>
<para>In order to take decisions in such case one needs always to test:</para>

<programlisting language="c++">
if (gGeoManager-&gt;IsOutside()) {
<emphasis role="italic"><code>   // current point is actually outside</code></emphasis>
<emphasis role="italic"><code>   … // corresponding action</code></emphasis>
}
</programlisting>

<para>Specific information related to the current volume/node like ID’s or shape can be then retrieved from the corresponding objects.</para>
<itemizedlist>
<listitem><para>Current state <code>index</code>. The number of possible different states of the modeller corresponds to the number of different objects/paths in the geometry. This has nothing to do with the number of nodes, since the same node can be found on different branches. In other words, the number of states corresponds to the number of nodes in the <code>expanded geometry tree</code>. Since unfortunately this expansion from logical to physical hierarchy cannot be stored on regular basis due to the large size of the latter, one cannot directly assign state numbers. If the size of the expansion proves however to be small enough (less than about 50 million objects), a parallel structure storing these state indices is built and stored in memory. In such case each state automatically gets an index that can be retrieved after any state initialization. These indices can prove to be quite useful for being able to keep track of the navigation history and force certain states. Let’s illustrate how this works with a simple example:</para></listitem>
<listitem><para>Suppose we have a simple geometry with a volume B positioned twice inside a container A. Then A is positioned twice in a top container T. The complete list of logical nodes is: <code>T_1</code>, <code>A_1</code>, <code>A_2</code>, <code>B_1</code>, <code>B_2</code>. On the other hand we will have more states than logical nodes:</para></listitem>
<listitem><para><code>/T_1</code>- 1 state at level = 0</para></listitem>
<listitem><para><code>/T_1/A_1,/T_1/A_2</code>- 2 states at level = 1</para></listitem>
<listitem><para><code>/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2</code>  - 4 states at level = 2</para></listitem>
<listitem><para>All these states will get automatic numbers, starting with 0 corresponding to the top-level state and ending with an integer corresponding to Ntotal_states-1. The mapping from a given logical node to a state number is generally not possible, as for the node B_1 that appears as current node for 2 different states. The numbering order of states is therefore not important, but it can be used as in the following lines:</para></listitem>
</itemizedlist>
<programlisting language="c++">
gGeoManager-&gt;InitTrack(pt,dir); <code>// or anything to initialize a state</code>
Int_t istate = gGeoManager-&gt;GetCurrentNodeId();  <code>// in fact state Id</code>
{
<code>   //… code changing the current state</code>
}
gGeoManager-&gt;CdNode(istate);   <code>// forces re-initialization of the state</code>
</programlisting>
<itemizedlist>
<listitem><para>Current <code>global transformation</code>. This represents the transformation from <code>MARS</code> to the local reference of the current node, being the product of all local mother-daughter transformations in the branch. The global transformation can be referenced or copied:</para></listitem>
</itemizedlist>
<programlisting language="c++">
const TGeoHMatrix *global = gGeoManager-&gt;GetCurrentMatrix();
TGeoHMatrix *copy = new TGeoHMatrix(*global);
</programlisting>
<itemizedlist>
<listitem><para>One often needs to perform <code>master-to-local</code> and <code>local-to-master</code> point and vector conversions to get from <code>MARS</code> to the local node coordinates. This can be done by using the global transformation or directly the <emphasis role="bold"><code>TGeoManager</code></emphasis> corresponding interfaces:</para></listitem>
</itemizedlist>
<programlisting language="c++">
Double_t *glob_pt = gGeoManager-&gt;GetCurrentPoint();
Double_t *glob_dir = gGeoManager-&gt;GetCurrentDirection();
Double_t loc_pt[3], loc_dir[3];
<emphasis role="italic"><code>// Go from MARS to local coordinates:</code></emphasis>
gGeoManager-&gt;MasterToLocal(glob_pt,loc_pt); <code>// or:</code>
global-&gt;MasterToLocal(glob_pt,loc_pt);      <code>// will be omitted from now</code><emphasis role="bold-italic"> </emphasis>
<code>// on, but can be done just the same for all other conversions</code>
gGeoManager-&gt;MasterToLocalVect(glob_dir,loc_dir);
<emphasis role="italic"><code>…      // perform some local computation changing the local </code></emphasis>
<emphasis role="italic"><code>       // point/direction then go back to MARS:</code></emphasis>
Double_t new_pt[3],new_dir[3];
gGeoManager-&gt;LocalToMaster(loc_pt,new_pt );
gGeoManager-&gt;LocalToMasterVect(loc_dir,new_dir);
</programlisting>

</sect2>

<sect2>
<title>Saving and Restoring the Current State</title>
<para>As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore and will be automatically disabled by the modeller. Fortunately there is a backup solution working in any condition: the modeller maintains a stack of states that is internally used by its own navigation algorithms, but user code is also allowed to access it. This works on any stack principle by using PUSH and POP calls and user code is responsible for popping the pushed states in order to keep the stack clean.</para>

<programlisting language="c++">
<code>// push the current state in the stack</code>
Int_t index = gGeoManager-&gt;PushPath();
<code>// push state and current poin</code><code>t</code>
Int_t index = gGeoManager-&gt;PushPoint();
<code>// retrieves the last pushed state (decrements stack index)</code>
gGeoManager-&gt;PopPath();
<code>// the same but retrieves also the point location </code>
gGeoManager-&gt;PopPoint();
<code>// just decrement stack index without changing state </code>
gGeoManager-&gt;PopDummy();
<code>// retrieves a state at given index without changing the stack index </code>
gGeoManager-&gt;PopPath(Int_t index);
</programlisting>

</sect2>

<sect2>
<title>Navigation Queries</title>
<para>After initializing the current state related to a given point and direction defined in <code>MARS</code> <code>(‘Where am I?’)</code>, one can query for several geometrical quantities. All the related algorithms work in the assumption that the current point has been localized inside the geometry (by the methods <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::FindNode()</code> or <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::InitTrack()</code>) and the current node or path has not been changed by the user.</para>

<sect3>
<title>Finding If Current State Is Changed For a New Point</title>
<para>One can find fast if a point different from the current one has or not the same location inside the geometry tree. To do that, the new point should not be introduced by using <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::SetCurrentPoint()</code> method, but rather by calling the specific method:</para>

<programlisting language="c++">
Bool_t TGeoManager::IsSameLocation(Double_t x,Double_t y,Double_t z,
Bool_t change=kFALSE);
</programlisting>

<para>In the prototype above, <code>x, y</code> and <code>z</code> are the coordinates of the new point. The modeller will check whether the current volume still contains the new point or its location has changed in the geometry hierarchy. If the new location is different, two actions are possible according to the value of <code>change</code>:</para>
<itemizedlist>
<listitem><para><code>change = kFALSE</code> (default) – the modeller does not change the current state but just inform the caller about this change.</para></listitem>
<listitem><para><code>change = kTRUE</code> – the modeller will actually perform a new <code>‘Where am I?’ </code>search after finding out that the location has changed. The current state will be actualized accordingly.</para></listitem>
</itemizedlist>
<para>Note that even when performing a normal search on the current state after changing the current point coordinates (e.g. <code>gGeoManager-&gt;FindNode(newX,newY,newZ)</code>), users can always query if the previous state has changed by using a method having the same name but without parameters:</para>

<programlisting language="c++">
Bool_t TGeoManager::IsSameLocation();
</programlisting>

</sect3>

<sect3>
<title>Finding the Distance to the Next Boundary</title>
<para>All tracking engines need to compare the currently proposed physical step with the maximum allowed distance in the current material. The modeller provides this information by computing the distance to the first boundary starting from the current point along a straight line. The starting point and direction for this procedure are the ones corresponding to the current state. The boundary search is initialized inside the current volume and the crossed boundary can belong either to the current node or to one of its daughters. The full prototype of the method is:</para>

<programlisting language="c++">
TGeoNode *TGeoManager<code>::FindNextBoundary</code>(Double_t step=kBig);
</programlisting>

<para>In the prototype above, besides the current point and direction that are supposed already initialized, the only input parameter is <code>step</code>. This represents the maximum step allowed by the tracking algorithm or the <code>physical step</code>.  The modeller will search for a boundary crossing only up to a distance equal to this value. If a boundary is found, a pointer to the object (node) having it is returned; otherwise the method returns <code>NULL</code>.</para>
<para>The computed value for the computed distance can be subsequently retrieved from the manager class:</para>

<programlisting language="c++">
Double_t snext  = gGeoManager-&gt;<code>GetStep();</code>
Double_t safety = gGeoManager-&gt;<code>GetSafeDistance();</code>
</programlisting>

<para> According the step value, two use cases are possible:</para>
<itemizedlist>
<listitem><para><code>step =</code> <emphasis role="bold"><code>TGeoShape</code></emphasis><code>::kBig </code>(default behavior; <code>kBig = 1030</code>). In this case, there is no limitation on the search algorithm, the first crossed node is returned and the corresponding distance computed. If the current point is outside geometry and the top node is not crossed, the corresponding distance will be set to <code>kBig</code> and a <code>NULL</code> pointer returned. No additional quantity will be computed.</para></listitem>
<listitem><para><code>step &lt; kBig</code>. In this case, the progressive search starting from the current point will be stopped after a distance equal with the supplied step. In addition to the distance to the first crossed boundary, the <code>safety radius</code> is also computed. Whenever the information regarding the maximum required step is known it is recommended to be provided as input parameter in order to speed-up the search.</para></listitem>
</itemizedlist>
<para>In addition to the distance computation, the method sets an additional flag telling if the current track will enter inside some daughter of the current volume or it will exit inside its container:</para>

<programlisting language="c++">
Bool_t TGeoManager<code>::IsStepEntering() const</code>;
</programlisting>

<para>A combined task is to first find the distance to the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method <code>FindNextBoundary()</code> whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).</para>

<programlisting language="c++">
TGeoNode *TGeoManager<code>::FindNextBoundaryAndStep</code>(Double_t stepmax,
Bool_t comp_safe=kFALSE);
</programlisting>

<para>The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.</para>
</sect3>

<sect3>
<title>Computing the Safe Radius</title>
<para>Other important navigation query for tracking is the computation of the safe distance. This represents the <code>maximum</code> step that can be made from the current point in <code>any direction</code> that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range <code>without checking</code> if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.</para>
<para>The computation of the safe radius is <code>automatically</code> computed any time when the next boundary is queried within a <code>limited step:</code></para>

<programlisting language="c++">
TGeoNode *crossed = gGeoManager<code>-&gt;FindNextBoundary</code>   <code>(pstep);</code>
Double_t safety = gGeoManager<emphasis role="italic"><emphasis role="bold"><code>-&gt;GetSafeDistance</code></emphasis></emphasis>   <emphasis role="italic"><emphasis role="bold"><code>();</code></emphasis></emphasis>
</programlisting>

<para>Otherwise, the computation of safety can always be forced:</para>

<programlisting language="c++">
Double_t safety = <emphasis role="italic"><emphasis role="bold"><code>gGeoManager</code></emphasis></emphasis>   <emphasis role="italic"><emphasis role="bold"><code>-&gt;Safety</code></emphasis></emphasis>   <emphasis role="italic"><emphasis role="bold"><code>();</code></emphasis></emphasis>
</programlisting>

</sect3>

<sect3>
<title>Making a Step</title>
<para>The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:</para>

<programlisting language="c++">
TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,Bool_t cross = kTRUE);
</programlisting>

<para>We will explain the method above by its use cases. The input flag <code>is_geom</code> allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to cross or not the boundary. The returned node represents the new current node after the step was made.</para>
<itemizedlist>
<listitem><para>Making a geometrically contained step with boundary crossing (<code>is_geom=kTRUE</code>, <code>cross=kTRUE</code>) – This is the default method behavior. In this case, the step size is supposed to be already set by a previous <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::FindNextBoundary()</code> call. Due to floating-point boundary uncertainties, making a step corresponding <code>exactly</code> to the distance to next boundary does not insure boundary crossing. If the method is called with this purpose, an extra small step will be made in order to make the crossing the most probable event (<code>epsil=10-6cm</code>). Even with this extra small step cannot insure 100% boundary crossing for specific crossed shapes at big incident angles. After such a step is made, additional cross-checks become available: </para></listitem>
</itemizedlist>
<programlisting language="c++">
gGeoManager-&gt;FindNextBoundary(pstep);
Double_t snext = gGeoManager-&gt;GetStep();       <code>// The geometrical</code>         <code>step</code>         <code>is taken</code>
TGeoNode *newNode = gGeoManager-&gt;Step();       <code>// The step=snext+epsil is made </code>
Bool_t hasCrossed = gGeoManager-&gt;IsEntering(); <code>// Is the boundary crossed or not? </code>
Bool_t isOnBoundary = gGeoManager-&gt;IsOnBoundary();   <code>// The proposed </code>
<code>// geometrically limited step to be made was smaller than epsil value.</code>
Bool_t isOutside = gGeoManager-&gt;IsOutside();   <code>//Did we exit geometry ?</code>
</programlisting>

<para>In case the desired end-point of the step should be in the same starting volume, the input flag <code>cross</code> should be set to <code>kFALSE</code>. In this case, the <code>epsil</code> value will be subtracted from the current step.</para>
<itemizedlist>
<listitem><para>Making a step of arbitrary value (<code>is_geom=kFALSE</code>, <code>cross=</code>no matter). In this case, the step to be made can be either resulting from a <code>next</code> computation, either set by hand:</para></listitem>
</itemizedlist>
<programlisting language="c++">
gGeoManager-&gt;SetStep(stepvalue);
gGeoManager-&gt;Step(kFALSE);
</programlisting>

<para>The step value in this case will <code>exactly</code> match the desired step. In case a boundary crossing failed after geometrically limited stepping, one can force as many small steps as required to really cross the boundary. This is not what generally happens during the stepping, but sometimes small rounding of boundary positions may occur and cause problems. These have to be properly handled by the stepping code.</para>
</sect3>

<sect3>
<title>The Normal Vector to the Next Crossed Surface at Crossing Point</title>
<para>Supposing we have found out that a particle will cross a boundary during the next step, it is sometimes useful to compute the normal to the crossed surface. The modeller uses the following convention: we define as <code>normal</code> (<inlinemediaobject><imageobject><imagedata fileref="pictures/080001DB.png" width="9.95pt" depth="13.65pt"/></imageobject></inlinemediaobject>) the unit vector perpendicular to a surface in the <code>next crossing point</code>, having the orientation such that: <inlinemediaobject><imageobject><imagedata fileref="pictures/080001DC.png" width="36.6pt" depth="14.9pt"/></imageobject></inlinemediaobject>. Here <inlinemediaobject><imageobject><imagedata fileref="pictures/080001DD.png" width="10.55pt" depth="17.4pt"/></imageobject></inlinemediaobject> represents the current direction. The next crossing point represents the point where a ray shot from the current point along the current direction crosses the surface.</para>

<programlisting language="c++">
Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);
</programlisting>

<para>The method above computes the normal to the next crossed surface in forward or backward direction (i.e. the current one), assuming the state corresponding to a current arbitrary point is initialized. An example of usage of normal computation is ray tracing.</para>
<para>The two most important features of the geometrical modeller concerning tracking are scalability and performance as function of the total number of physical nodes. The first refers to the possibility to make use of the available memory resources and at the same time be able to resolve any geometrical query, while the second defines the capability of the modeller to respond quickly even for huge geometries. These parameters can become critical when simulating big experiments like those at LHC.</para>
</sect3>
</sect2>

<sect2>
<title>Creating and Visualizing Tracks</title>
<para>In case the modeller is interfaced with a tracking engine, one might consider quite useful being able to store and visualize at least a part of the tracks in the context of the geometry. The base class <emphasis role="bold"><code>TVirtualGeoTrack</code></emphasis> provides this functionality. It currently has one implementation inside the drawing package (<emphasis role="bold"><code>TGeoTrack</code></emphasis>         class). A track can be defined like:</para>

<programlisting language="c++">
TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,
TObject *particle=0);
</programlisting>

<para>Where:         <code>id</code> is user-defined id of the track, <code>pdg</code> - <code>pdg</code> code, <code>parent</code>         - a pointer to parent track, <code>particle</code> -  a pointer to an arbitrary particle object (may be a <emphasis role="bold"><code>TParticle</code></emphasis>).</para>
<para>A track has a list of daughters that have to be filled using the following method:</para>

<programlisting language="c++">
TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,
TObject *particle=0);
</programlisting>

<para>The method above is pure virtual and have to create a track daughter object. Tracks are fully customizable objects when inheriting from <emphasis role="bold"><code>TVirtualGeoTrack</code></emphasis> class. We will describe the structure and functionality provided by the default implementation of these, which are <emphasis role="bold"><code>TGeoTrack</code></emphasis> objects.</para>
<para>A <emphasis role="bold"><code>TGeoTrack</code></emphasis> is storing a list of <code>control points</code> <code>(x,y,z)</code> belonging to the track, having also time information <code>(t)</code>. The painting algorithm of such tracks allows drawing them in any time interval after their creation. The track position at a given time is computed by interpolation between control points.</para>

<programlisting language="c++">
myTrack-&gt;AddPoint(x,y,z,t);
</programlisting>

<para>The creation and management of tracks is in fact fully controlled by the <emphasis role="bold"><code>TGeoManager</code></emphasis> class. This holds a list of <code>primary tracks</code> that is also visible during browsing as <code>Tracks</code> folder. Primary tracks are tracks having no parent in the tracking history (for instance the output of particle generators may be considered as primaries from tracking point of view). The manager class holds in<emphasis role="bold"><code> TGeoManager</code></emphasis><code>::fCurrentTrack</code> a pointer to the current track. When starting tracking a particle, one can create a track object like:</para>

<programlisting language="c++">
Int_t track_index = gGeoManager-&gt;AddTrack(id,pdg,ptrParticle);
</programlisting>

<para>Here <code>track_index</code> is the index of the newly created track in the array of primaries. One can get the pointer of this track and make it known as current track by the manager class:</para>

<programlisting language="c++">
TVirtualGeoTrack *track = gGeoManager-&gt;GetTrack(track_index);
gGeoManager-&gt;SetCurrentTrack(track);
<code>// or directly</code>
gGeoManager-&gt;SetCurrentTrack(track_index);
TVirtualGeoTrack *current = gGeoManager-&gt;GetCurrentTrack();
</programlisting>

<para>One can also look for a track by <code>user id</code> or <code>track index</code>:</para>

<programlisting language="c++">
ptrTrack = gGeoManager-&gt;GetTrackOfId(user_id);
ptrParent = gGeoManager-&gt;GetParentTrackOfId(user_id);
ptrTrack = gGeoManager-&gt;GetTrack(index);
</programlisting>

<para>Supposing a particle represented by a primary track decays or interacts, one should not create new primaries as described before, but rather add them as secondary:</para>


<programlisting language="c++">
TVirtualGeoTrack *secondary = ptrTrack-&gt;AddTrack(secondId,pdg,secondParticle);
</programlisting>

<para>At any step made by the current track, one is able to add control points to either primary or secondary:</para>

<programlisting language="c++">
track-&gt;AddPoint(x,y,z,t);
</programlisting>

<para>After tracks were defined and filled during tracking, one will be able to browse directly the list of tracks held by the manager class. Any track can be drawn using its <code>Draw()</code> and <code>Animate()</code> methods, but there are also global methods for drawing or animation that can be accessed from <emphasis role="bold"><code>TGeoManager</code></emphasis> context menu:</para>

<programlisting language="c++">
TGeoManager::DrawTracks(Option_t *option);
TGeoManager::AnimateTracks(Double_t tmin=0.,Double_t tmax=1E-8,
Int_t nframes=200,Option_t *option=””) ;
</programlisting>

<para>The drawing/animation time range is a global variable that can be directly set:</para>

<programlisting language="c++">
gGeoManager-&gt;SetTminTmax(tmin, tmax);
<code>// without arguments resets the time range to the maximum value</code>
</programlisting>

<para>Once set, the time range will be active both for individual or global track drawing. For animation, this range is divided to the desired number of frames and will be automatically updated at each frame in order to get the animation effect. </para>
<para>The option provided to all track-drawing methods can trigger different track selections:</para>
<para><code>default: </code>A track (or all primary tracks) drawn without daughters</para>
<para><code>/D:</code>      Track and first level descendents only are drawn</para>
<para><code>/*: </code>     Track and all descendents are drawn</para>
<para><code>/Ntype:</code>   All tracks having <code>name=type</code> are drawn</para>
<para>Generally several options can be concatenated in the same string (E.g. <code>“/D /Npion-“</code>). </para>
<para>For animating tracks, additional options can be added:</para>
<para><code>/G:</code>Geometry animate. Generally when drawing or animating tracks, one has to first perform a normal drawing of the geometry as convenient. The tracks will be drawn over the geometry. The geometryitself will be animated (camera moving and rotating in order to “catch” the majority of current track segments.)</para>
<para><code>/S:</code>Save all frames in gif format in the current folder. This option allows creating a movie based on individual frames.</para>
</sect2>
</sect1>

<sect1>
<title>Checking the Geometry</title>
<para>Several checking methods are accessible from the context menu of volume objects or of the manager class. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the <emphasis role="bold"><code>TGeoChecker</code></emphasis> class. The checking package contains an overlap checker and several utility methods that generally have visualization outputs.</para>

<sect2>
<title>The Overlap Checker</title>
<para>An overlap is any region in the Euclidian space being contained by more than one positioned volume. Due to the containment scheme used by the modeller, all points inside a volume have to be also contained by the mother therefore are overlapping in that sense. This category of overlaps is ignored due to the fact that any such point is treated as belonging to the deepest node in the hierarchy. </para>

<figure><title>Extruding volumes</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001DE.png" width="204.85pt" depth="180pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>A volume containment region is in fact the result of the subtraction of all daughters. On the other hand, there are two other categories of overlaps that are considered illegal since they lead to unpredictable results during tracking.</para>
<para>A) If a positioned volume contains points that are not also contained by its mother, we will call the corresponding region as an <code>extrusion</code>. When navigating from outside to inside (trying to enter such a node) these regions are invisible since the current track has not yet reached its mother. This is not the case when going the other way since the track has first to exit the extruding node before checking the mother. In other words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.</para>
<para>B) We will call <emphasis role="italic"><emphasis role="bold"><code>overlaps</code></emphasis></emphasis>   only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from. </para>
<para>When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters. </para>
<para>We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using <emphasis role="bold"><code>TGeoVolume</code></emphasis><code>::AddNodeOverlap()</code>         method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.</para>
<para/>

<figure><title>Overlap checking</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001DF.png" width="211.65pt" depth="187.45pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):</para>

<programlisting language="c++">
myVolume-&gt;CheckOverlaps(precision, option);
gGeoManager-&gt;CheckOverlaps(precision);
myNode-&gt;CheckOverlaps(precision);
</programlisting>

<para>Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using <code>option</code>="<code>d</code>" or <code>option</code>="<code>d&lt;number&gt;</code>" to perform overlap checking by sampling the volume with &lt;<code>number</code>&gt; random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.</para>
<para>An extrusion A) is declared in any of the following cases:</para>
<itemizedlist>
<listitem><para>At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;</para></listitem>
<listitem><para>At least one of the mother vertices is contained also by one of its daughters, in the same conditions.</para></listitem>
</itemizedlist>
<para>An overlap B) is declared if:</para>
<itemizedlist>
<listitem><para>At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates.</para></listitem>
</itemizedlist>
<para>The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a <emphasis role="bold"><code>TBrowser</code></emphasis>) held by the manager class will be filled with <emphasis role="bold"><code>TGeoOverlap</code></emphasis> objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a <emphasis role="bold"><code>TBrowser</code></emphasis> produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling <code>gGeoManager-&gt;PrintOverlaps()</code> prints the list of overlaps.</para>
</sect2>

<sect2>
<title>Graphical Checking Methods</title>

<figure><title>Safety computation checking</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001E0.png" width="158.4pt" depth="98.8pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>In order to check a given point, <code>Ch</code><code>eckPoint</code><code>(x,y,z)</code> method of <emphasis role="bold"><code>TGeoManager</code></emphasis> draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary.</para>
<para/>
<para/>
<para/>

<figure><title>Random points</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001E1.png" width="158.4pt" depth="99.9pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>A method to check the validity of a given geometry is shooting random points. This can be called with  the method <emphasis role="bold"><code>TGeoVolume::</code></emphasis><code>RandomPoints</code><code>()</code> and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn.</para>

<para/>

<figure><title>Random rays</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001E2.png" width="158.4pt" depth="103.35pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>
A ray tracing method can be called <emphasis role="bold"><code>TGeoVolume::</code></emphasis><code>RandomRays()</code>.
This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes
appear as segments having the color of the touched node.
</para>

<para/>
<para/>
<para/>
<para/>
<para/>
</sect2>
</sect1>

<sect1>
<title>The Drawing Package</title>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030001E3.png" width="192.95pt" depth="156.75pt"/></imageobject></inlinemediaobject>The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies. </para>
<para>The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing. </para>
<para>The method <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::GetGeomPainter()</code>loads the painting library in memory. </para>
<para>This is generally not needed since it is called automatically by <emphasis role="bold"><code>TGeoVolume</code></emphasis><code>::Draw()</code> as well as by few other methods setting visualization attributes.</para>

<sect2>
<title>Drawing Volumes and Hierarchies of Volumes</title>
<para>The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:</para>

<programlisting language="c++">
<code>//… code for geometry building</code>
root[] <emphasis role="bold"><code>gGeoManager-&gt;CloseGeometry();</code></emphasis>
root[] <emphasis role="bold"><code>gGeoManager-&gt;GetMasterVolume()-&gt;Draw();</code></emphasis>
</programlisting>

<para>Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry <code>root</code>. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:</para>
<itemizedlist>
<listitem><para><emphasis role="italic"><emphasis role="bold"><code>Q: “The picture is strangely rotated; where are the coordinate axes?”</code></emphasis></emphasis></para></listitem>
</itemizedlist>
<para><emphasis role="italic"><emphasis role="bold"><code>A:</code></emphasis></emphasis> If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can then perform mouse/keyboard actions to change them:</para>

<para>- Mouse left-click and drag will rotate the view;</para>
<para>- Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the <emphasis role="bold"><code>TView</code></emphasis> context menu: right-click on the picture when no object is selected; </para>
<itemizedlist>
<listitem><para><emphasis role="italic"><emphasis role="bold"><code>Q: “Every line is black! I cannot figure out what is what…”</code></emphasis></emphasis></para></listitem>
</itemizedlist>
<para><emphasis role="italic"><emphasis role="bold"><code>A:</code></emphasis></emphasis> Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: <code>myvolume-&gt;SetLineColor(Int_t color);</code> otherwise everything is by default black.</para>
<itemizedlist>
<listitem><para><emphasis role="italic"><emphasis role="bold"><code>Q: “The top volume of my geometry is a box but I see only its content.”</code></emphasis></emphasis></para></listitem>
</itemizedlist>
<para><emphasis role="italic"><emphasis role="bold"><code>A:</code></emphasis></emphasis> By default the drawn volume is not displayed just because we do not want to hide its content when changing the view to HLR or solid mode. In order to see it in the default wire frame picture one has to call <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::SetTopVisible()</code>.</para>
<itemizedlist>
<listitem><para><emphasis role="italic"><emphasis role="bold"><code>Q: “I do not see all volumes in my tree but just something inside.”</code></emphasis></emphasis></para></listitem>
</itemizedlist>
<para><emphasis role="italic"><emphasis role="bold"><code>A:</code></emphasis></emphasis> By default, <emphasis role="bold"><code>TGeoVolume</code></emphasis><code>::Draw()</code> paints the content of a given volume three levels down. You can change this by using: <emphasis role="italic"><emphasis role="bold"><code>gGeoManager</code></emphasis></emphasis><code>::SetVisLevel(n);</code></para>
<para>Not only that, but none of the volumes at intermediate levels (0-2) are visible on the drawing unless they are final ‘leaves’ on their branch (e.g. have no other volumes positioned inside). This behavior is the default one and corresponds to ‘leaves’ global visualization mode (<emphasis role="bold"><code>TGeoManager</code></emphasis><code>::fVisOption = 1</code>). In order to see on the screen the intermediate containers, one can change this mode: <code>gGeoManager-&gt;SetVisOption(0)</code>.</para>
<itemizedlist>
<listitem><para>    <emphasis role="italic"><emphasis role="bold"><code>Q: “Volumes are highlighted when moving the mouse over their vertices. What does it mean?”</code></emphasis></emphasis></para></listitem>
</itemizedlist>
<para><emphasis role="italic"><emphasis role="bold"><code>A:</code></emphasis></emphasis> Indeed, moving the mouse close to some volume vertices selects it. By checking the <code>Event Status</code> entry in the root canvas <code>Options</code> menu, you will see exactly which is the selected node in the bottom right. Right-clicking when a volume is selected will open its context menu where several actions can be performed (e.g. drawing it).</para>
<itemizedlist>
<listitem><para><emphasis role="italic"><emphasis role="bold"><code>Q: “OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?”</code></emphasis></emphasis></para></listitem>
</itemizedlist>
<para><emphasis role="italic"><emphasis role="bold"><code>A:</code></emphasis></emphasis> Once you have set a convenient global visualization option and level, what you need is just call the <code>Draw()</code> method of your interesting volume. You can do this either by interacting with the expanded tree of volumes in a ROOT browser (where the context menu of any volume is available), either by getting a pointer to it (e.g. by name): <code>gGeoManager-&gt;GetVolume(“vol_name”)-&gt;Draw();</code> </para>
</sect2>

<sect2>
<title>Visualization Settings and Attributes</title>
<para>Supposing you now understand the basic things to do for drawing the geometry or parts of it, you still might be not happy and wishing to have more control on it. We will describe below how you can tune some fine settings. Since the corresponding attributes are flags belonging to volume and node objects, you can change them at any time (even when the picture is already drawn) and see immediately the result. </para>

<sect3>
<title>Colors and Line Styles</title>
<para>We have already described how to change the line colors for volumes. In fact, volume objects inherit from TAttLine class so the line style or width can also be changed:</para>

<programlisting language="c++">
myVolume-&gt;SetLineColor(kRed);
myVolume-&gt;SetLineWith(2);
myVolume-&gt;SetLineStyle(kDotted);
</programlisting>

<para>When drawing in solid mode, the color of the drawn volume corresponds to the line color.</para>
</sect3>

<sect3>
<title>Visibility Settings</title>
<para>The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together.  One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:</para>

<programlisting language="c++">
myVolumeContainer-&gt;SetVisibility(kFALSE);
</programlisting>

<para>As described before, the drawing package supports two main global options: 1 (default) – only final volume leaves; 0 – all volumes down the drawn one appear on the screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: <code>Visible daughters</code>. By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume.</para>
</sect3>
</sect2>

<sect2>
<title>Ray Tracing</title>
<para>Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, <emphasis role="bold"><code>TGeo</code></emphasis> is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are considering providing a base class in order to be able to derive more complex models.</para>

<para>Due to the fact that the number of rays that have to be tracked matches the size in pixels of the pad, the time required by this
algorithm is proportional to the pad size. On the other hand, the speed is quite acceptable for the default ROOT pad size and the images produced by using this technique have high quality.
Since the algorithm is practically using all navigation features, producing ray-traced pictures is also a geometry validation check. Ray tracing can be activated at volume level as the
normal <code>Draw()</code>.</para>

<figure><title>Ray-traced view in a pad</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001E4.jpg" width="207.95pt" depth="155.8pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<programlisting language="c++">
myVolume-&gt;Raytrace()
</programlisting>

<para>Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible. </para>

<sect3>
<title>Clipping Ray-traced Images</title>
<para>A ray-traced view can be <code>clipped</code> with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):</para>
<para>
<code>1. TGeoShape *clip1, *clip2, …</code></para>
<para>One might switch between several clipping shapes. Note that these shapes are considered defined in the current <code>MARS</code>. Composite shapes may be used.</para>
<para>2<code>. gGeoManager-&gt;SetClippingShape(clip1);</code></para>
<para>One can activate or deactivate clipping at any time:  <code>gGeoManager-&gt;SetClipping(flag);</code></para>
<para>3. Perform ray-tracing:<code> gGeoManager-&gt;GetTopVolume()-&gt;Raytrace();</code></para>
<para>
One can redo the steps 2-3 as many times as needed.  Let us look how the <emphasis role="italic"><emphasis role="bold"><code>rootgeom</code></emphasis></emphasis>
example looks clipped with a tube.</para>

<figure><title>Ray-tracing example with box-clipping</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001E5.png" width="207.95pt" depth="147.1pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>
</sect2>
</sect1>

<sect1>
<title>Representing Misalignments of the Ideal Geometry</title>
<para>The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. <emphasis role="bold"><code>TGeo</code></emphasis> offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information.</para>

<sect2>
<title>Physical Nodes</title>
<para>Physical nodes are the actual “touchable” objects in the geometry, representing actually a path of positioned volumes starting witrh the top node: <code>path=/TOP/A_1/B_4/C_3</code> , where <code>A</code>, <code>B</code>, <code>C</code> represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In <emphasis role="bold"><code>TGeo</code></emphasis>, physical nodes are represented by the class <emphasis role="bold"><code>TGeoPhysicalNode</code></emphasis> and can be created on demand for alignment purposes:</para>

<programlisting language="c++">
TGeoPhysicalNode(const char* path)
</programlisting>

<para>The knowledge of the path to the objects that need to be misaligned is essential since there is no other way of identifying them. One can however create “symbolic links” to any complex path to make it more representable for the object it designates:</para>

<programlisting language="c++">
TGeoPNEntry(const char* unique_name, const char* path)
void TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *node)
</programlisting>

<para>Such a symbolic link hides the complexity of the path to the align object and replaces it with a more meaningful name. In addition, <emphasis role="bold"><code>TGeoPNEntry</code></emphasis> objects are faster to search by name and they may optionally store an additional user matrix.  </para>

<programlisting language="c++">
// Creating a symlink object.
TGeoPNEntry *TGeoManager::SetAlignableEntry(const char *unique_n,const char*path)
// Retrieving an existing alignable object.
TGeoPNEntry *TGeoManager::GetAlignableEntry(const char *name)
// Retrieving an existing alignable object at a given index.
TGeoPNEntry *GetAlignableEntry(Int_t index)
</programlisting>

<para>Physical nodes store internally the full list of logical nodes corresponding to the elements from the string path, as well as the global transformation matrix for each of them. The top node corresponds to the level 0 in the stored array, while the last node will correspond to level <code>n</code>. For each level, the node, volume and global matrix can be retrieved using corresponding getters:</para>

<programlisting language="c++">
TGeoHMatrix *GetMatrix(Int_t level=-1) const
TGeoNode    *GetNode(Int_t level=-1) const
TGeoShape   *GetShape(Int_t level=-1) const
TGeoVolume  *GetVolume(Int_t level=-1) const
</programlisting>

<para>By default the object at level n is retrieved (the alignable object).</para>
<para>Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:</para>

<programlisting language="c++">
void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0, Bool_t check=kFALSE)
</programlisting>

<para>The convention used is that newmat represents the new local matrix of the last node in the branch with respect to its mother volume. The <code>Align()</code> method will actually duplicate the corresponding branch within the logical hierarchy, creating new volumes and nodes. This is mandatory in order to avoid problems due to replicated volumes and can create exhaustive memory consumption if used abusively. </para>
<para>Once aligned, a physical node is ready to be tracked. The operation can be done only after the geometry was closed.</para>
<para>Important NOTE: Calling the <code>Align()</code> method for a physical node changes the node pointers for the stored node branch in the active geometry, Due to this the other defined physical nodes containing elements of this path will be invalid. Example:</para>

<programlisting language="c++">
TGeoPhysicalNode *pn1 = gGeoManager-&gt;MakePhysicalNode(“/A_1/B_1/C_2”);
TGeoPhysicalNode *pn2 = gGeoManager-&gt;MakePhysicalNode(“/A_1/B_1/C_3”);
…
pn1-&gt;Align(…);
</programlisting>

<para>The call to <code>pn1-&gt;Align()</code> will invalidate the pointer to the node <code>B_1</code> in <code>pn2</code> object.. The way out is to either call <code>pn1-&gt;Align()</code> before the creation of <code>pn2</code>, eithr to use a global method that will correct all existing physical nodes:</para>

<programlisting language="c++">
void RefreshPhysicalNodes(Bool_t lock = kTRUE)
</programlisting>

<para>The method above will optionally lock the possibility of doing any further misalignment.</para>
</sect2>
</sect1>

<sect1>
<title>Geometry I/O</title>
<para>Once geometry is successfully built, it can be saved in a root file or as C++ macro by calling: </para>

<programlisting language="c++">
TGeoManager::Export(const char *filename,const char*keyname="",Option_t *opt="v")
</programlisting>
<itemizedlist>
<listitem><para><code>Filename</code>is the name of the file to be written (mandatory). Depending on the extension of the file, the geometry is exported either as ,root file or .C(.cxx) macro. </para></listitem>
<listitem><para><code>keyname</code>is the name of the key in the file (default "") </para></listitem>
<listitem><para><code>opt</code> = <code>"v"</code>          is an export voxelization (default), otherwise voxelization is recomputed after loading the geometry </para></listitem>
</itemizedlist>
<para>Loading geometry from a root file can be done in the same way as for any other ROOT object, but a static method is also provided: </para>

<programlisting language="c++">
TGeoManager::Import(const char *filename,const char *keyname="",Option_t *opt="")
</programlisting>

<para>Example: </para>

<programlisting language="c++">
<code>// Writing to a file geometry definition ending with:</code>
root[] <emphasis role="bold"><code>gGeoManager</code></emphasis><emphasis role="bold"><code>-&gt;CloseGeometry();</code></emphasis>
<code>// geometry is ready</code>
root[] <emphasis role="bold"><code>gGeoManager-&gt;Export("MyGeom.root")</code></emphasis>;  <code>// file MyGeom.root produced</code>
root[] <emphasis role="bold"><code>gGeoManager-&gt;Export(“MyGeom.C”);</code></emphasis><emphasis role="italic"><code>      // C++ macro MyGeom.C produced</code></emphasis>
root[] <emphasis role="bold"><code>myVolume-&gt;SaveAs(“MyVolume.C”);</code></emphasis>      <emphasis role="italic">// C++ macro for the branch starting</emphasis>
<emphasis role="italic"><code>                                           // with MyVolume</code></emphasis>
<code>// Reading from a file</code>
root[] <emphasis role="bold"><code>gSystem-&gt;Load(“libGeom”);</code></emphasis>
root[] <emphasis role="bold"><code>TGeoManager</code></emphasis><emphasis role="bold"><code>::Import("MyGeom.root");</code></emphasis>  <code>// geometry is ready</code>
</programlisting>

<para>Note that not all-current information held by the modeller is written on the file. For instance, the painter and checker objects are not written, as well as the temporary current navigation properties: current node path, point or direction. On the other hand, all objects belonging to the geometrical hierarchy will always be written. The idea is to be able to retrieve the geometry in a ready state, ignoring what the state variables that can be always re-initialized. When the code is generated for a given <emphasis role="bold"><code>TGeoVolume</code></emphasis> in the geometry, just the branch starting with that volume will be saved in the file. Executing the generated code will create a geometry that has <code>MyVolume</code> as top volume. In this case, only the materials/media/matrices used effectively in the <code>MyVolume</code> branch are exported to file.</para>
<para>Volumes can be made persistent in the same way the full geometry is. Exporting is straightforward (module1, 2 are pointers to <emphasis role="bold"><code>TGeoVolume</code></emphasis> objects):</para>

<programlisting language="c++">
module1-&gt;Export("file.root");                   <emphasis role="italic"><code>// by default file is overwritten</code></emphasis>
module2-&gt;Export("file.root","","update");       <emphasis role="italic"><code>// to the same file</code></emphasis>
</programlisting>

<para>Importing will append the volume to the current TGeoManager or will create one:</para>

<programlisting language="c++">
TGeoManager *geom = new TGeoManager("myGeom", "");
TGeoVolume *top = geom-&gt;MakeBox(...);
geom-&gt;SetTopVolume(top);
<emphasis role="italic"><code>//name</code></emphasis> <emphasis role="italic"><code>of volume or key (depending on export usage)</code></emphasis>
TGeoVolume *module1 = TGeoVolume::Import("file.root", "MOD1");
TGeoVolume *module2 = TGeoVolume::Import("file.root", "MOD2");
top-&gt;AddNode(module1, 1, new TGeoTranslation(0,0,100));
top-&gt;AddNode(module2, 1, new TGeoTranslation(0,0,-100));
<emphasis role="italic"><code>// One should close himself the geometry</code></emphasis>
geom-&gt;CloseGeometry();
</programlisting>

</sect1>

<sect1>
<title>Navigation Algorithms</title>
<para>This section will describe the main methods and algorithms used for implementing the navigation features within the geometrical modeller. This includes navigation queries at shape level, global geometrical queries and optimization mechanisms.</para>

<sect2>
<title>Finding the State Corresponding to a Location (x,y,z)</title>
<para>For reminder, a geometry state is a ‘touchable’ object in the geometry hierarchy. It is represented by a path like: <emphasis role="bold">/TOP_1/A_1/B_3/C_1</emphasis>, where <emphasis role="bold">B_3</emphasis> for instance is a copy of volume <emphasis role="bold">B</emphasis> positioned inside volume <emphasis role="bold">A</emphasis>. A state is always associated to a transformation matrix <emphasis role="bold">M</emphasis> of the touchable with respect to the global reference frame (obtained by piling-up all local transformations of nodes in the branch with respect to their containers). The current state and the corresponding global matrix are updated whenever the geometry depth is modified. The global transformations corresponding to all nodes in the current branch are kept in an array: (<emphasis role="bold">M</emphasis><emphasis role="bold">TOP_1</emphasis><emphasis role="bold">, M</emphasis><emphasis role="bold">A_1</emphasis><emphasis role="bold">, M</emphasis><emphasis role="bold">B_3</emphasis><emphasis role="bold">, …</emphasis>). </para>

<figure><title>Navigation in the geometry hierarchy</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001E6.png" width="334.55pt" depth="228.4pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The elementary operations for changing the state are:</para>

<programlisting language="c++">
TGeoManager::CdUp();
TGeoManager::CdDown(i);
TGeoManager::CdTop()
</programlisting>

<para>The current state accounting and global matrix handling after these operations are depicted in the figure below. Now let us suppose that we have a particle at position <emphasis role="bold-italic">P</emphasis><emphasis role="italic">(x,y,z)</emphasis>. The first thing needed for transporting it is the current object our particle is into, so that we can retrieve its material properties. This task is done by:</para>

<programlisting language="c++">
TGeoNode *TGeoManager::FindNode(x,y,z)
</programlisting>

<para>Note that the current particle position can be set using <emphasis role="bold"><code>SetCurrentPosition(x,y,z)</code></emphasis> method of the manager class, in which case <emphasis role="bold"><code>FindNode()</code></emphasis> can be called without arguments. The method returns a pointer to the <emphasis role="italic">deepest node</emphasis> that geometrically contains <emphasis role="bold-italic">P</emphasis> (in our case let us suppose it is <emphasis role="bold-italic">B_3</emphasis>). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. <emphasis role="italic">Deepest</emphasis> means that <emphasis role="bold-italic">B_3</emphasis> still contains point <emphasis role="bold-italic">P</emphasis> (as well as <emphasis role="bold-italic">A_1</emphasis> and <emphasis role="bold-italic">TOP_1</emphasis>), but none of the daughters of volume <emphasis role="bold">B</emphasis> does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:</para>

<programlisting language="c++">
Bool_t *TGeoManager::IsSameLocation()
</programlisting>

<para>The algorithm for finding where a point is located in geometry is presented in the figure 17-36. </para>
<para>It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:</para>
<itemizedlist>
<listitem><para>moving up and down in the logical node tree while updating the current  node and its global matrix</para></listitem>
<listitem><para>converting the global position into the local frame of the current node/volume</para></listitem>
<listitem><para>checking whether the local position lies within the geometrical shape of the current volume – if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.</para></listitem>
<listitem><para>the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.</para></listitem>
<listitem><para>in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):</para></listitem>
<listitem><para>Is declared as non-overlapping (these are anyway searched first)</para></listitem>
<listitem><para>Has at least one daughter that contains the current point</para></listitem>
<listitem><para>Was already declared as containing the point at a previous step</para></listitem>
</itemizedlist>

<figure><title>Finding the location of a point in the geometry hierarchy</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001E7.png" width="393.5pt" depth="490.95pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect2>

<sect2>
<title>Finding the Distance to Next Crossed Boundary</title>
<para>The most important feature provided by the modeller related to track propagation is the computation of the distance to the next boundary along a straight line. </para>
<para>The relevant state parameters used for this task are:</para>
<itemizedlist>
<listitem><para>Current particle position and direction <code>(x,y,z,nx,ny,nz)</code>, where ni is the direction cosine with axis (<code>i</code>). </para></listitem>
<listitem><para>Current node (and path) in geometry must be set by calling <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::FindNode(x,y,z) </code>beforehand The method computing the distance to next boundary is:</para></listitem>
</itemizedlist>

<programlisting language="c++">
TGeoNode *TGeoManager::FindNextBoundary(stepmax, path)
</programlisting>

<para>The output node returned by the method is the object which shape boundary will be crossed first. The distance to the next crossing can be retrieved after the call:</para>

<programlisting language="c++">
Double_t TGeoManager::GetStep()
</programlisting>
<itemizedlist>
<listitem><para>The main input parameter is <code>stepmax,</code> which act as a trigger for different features. The absolute value of this parameter represents the step value proposed by the user. The algorithm will never try o search for boundaries further than this distance. In case no boundary is found the returned node will be the current one and the computed step to boundary will be equal to abs (<code>stepmax</code>) having the meaning <emphasis role="italic">“step approved”</emphasis>. The default value for <code>stepmax</code> is <emphasis role="bold"><code>TGeoShape</code></emphasis><code>::Big </code>with the meaning that boundaries are looked for without limitation.</para></listitem>
</itemizedlist>

<figure><title>Finding the distance to the next crossed boundary</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/080001E8.png" width="363.7pt" depth="473.6pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para/>
<para>According the values of the input parameters the method will perform additional optional tasks:</para>
<para>
<emphasis role="bold"><code>|stepmax| &lt; </code></emphasis>
<emphasis role="italic"><emphasis role="bold"><code>TGeoShape::Big()</code></emphasis></emphasis>
<emphasis role="bold"><code> </code></emphasis></para>
<para>The safe distance in the current volume is also computed. Moving the particle from its current location with this distance in any direction is safe in the sense that will never change the current state.</para>
<para>
<emphasis role="bold"><code>stepmax &lt; 0</code></emphasis></para>
<para>The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: <emphasis role="bold"><code>TGeoManager</code></emphasis>::<code>GetNextMatrix</code>()</para>
<para>In case the computation of the normal vector to the next crossed surface is required, using a negative  stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:</para>

<programlisting language="c++">
Double_t *TGeoManager::FindNormalFast()
</programlisting>

<para>
<emphasis role="bold"><code>path </code></emphasis>

<emphasis role="bold"><code> 0</code></emphasis></para>
<para>In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry</para>

<sect3>
<title>Output Values</title>
<para><emphasis role="bold"><code>TGeoManager</code></emphasis><code>::GetStep()</code>: distance to next boundary.</para>
<para><emphasis role="bold"><code>TGeoManager</code></emphasis><code>::GetSafeDistance()</code>: safe distance (in case it was computed).</para>
<para><emphasis role="bold"><code>TGeoManager</code></emphasis><code>::IsOnBoundary()</code>: the initial point <code>(x,y,z)</code> was (or was not) on a boundary within <emphasis role="bold"><code>TGeoShape</code></emphasis><code>::Tolerance()</code>.</para>
<para>
The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates
did not change from the last query,  the last computed safety is taken. Otherwise, the method
<emphasis role="bold"><code>TGeoManager</code></emphasis>
<code>::Safety ()</code>
is invoked. A safety value less than
<emphasis role="bold"><code>TGeoShape</code></emphasis>
<code>::Tolerance()</code>
will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop
the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.</para>
<para>The next stage is to check if computation of the distance to a give physical object specified by a path was required.
If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and c
omputes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL.
In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::FindNode()</code>
was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the
distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and
the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the
current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.</para>
<para>
After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by
<emphasis role="bold"><code>TGeoManager</code></emphasis>
<code>::FindNextDaughterBoundary().</code>
This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if
<code>step&lt;stepmax</code>
.</para>
<para>
A special case is when the current node is declared as possibly overlapping with something else. If this is the case, the distance is computed for all possibly overlapping candidates, taking into account the overlapping priorities (see also: “
Overlapping volumes ”).</para>
<para>
The global matrix describing the next crossed physical node is systematically computed in case the value of t
he proposed step is negative. In
this case, one can subsequently call
<emphasis role="bold"><code>TGeoManager</code></emphasis><code>::ComputeNormalFast()</code>

to get the normal vector to the crossed surface, after propagating the current point with the
<emphasis role="bold"><code>TGeoManager</code></emphasis><code>::GetStep()</code>
value. This propagation can be done like:</para>

<programlisting language="c++">
Double_t *current_point = gGeoManager-&gt;GetCurrentPoint();
Double_t *current_dir = gGeoManager-&gt;GetCurrentDirection() ;
for (Int_t i=0 ; i&lt;3 ; i++) current_point[i] += step * current_dir[I];
</programlisting>

<para>Note: The method <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::FindNextBoundary()</code> does not modify the current point/direction nor the current volume/state. The returned node is the next crossed one, but the physical path (state) AFTER crossing the boundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is <emphasis role="bold"><code>TGeoManager</code></emphasis><code>::Step()</code>, described in “ Making a Step ”, but users may implement more precise methods to insure post-step boundary crossing.</para>
</sect3>
</sect2>
</sect1>

<sect1>
<title>Geometry Graphical User Interface</title>
<para>The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class
<emphasis role="bold"><code>TGeoXXX</code></emphasis> have a correspondent editor <emphasis role="bold"><code>TGeoXXXEditor</code></emphasis> that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism.</para>

<sect2>
<title>Editing a Geometry</title>
<para>There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:</para>

<programlisting language="c++">
root[] TGeoManager *geom = new TGeoManager(“MyGeom”, “Test builder”);
root[] geom-&gt;Edit(Option_t *option=””);
</programlisting>

<para>The lines above will create a new <emphasis role="bold"><code>TGeoManager</code></emphasis> class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the <code>Edit()</code> method.</para>

<figure><title>The geometry manager editor</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001E9.png" width="243.95pt" depth="180.6pt"/></imageobject></inlinemediaobject>
</para>
</figure>
</sect2>

<sect2>
<title>The Geometry Manager Editor</title>

<figure><title>Accessing/creating different categories of editable objects</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001EA.jpg" width="77.6pt" depth="201.1pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001EB.jpg" width="77.6pt" depth="201.1pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001EC.jpg" width="77.6pt" depth="201.1pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001ED.jpg" width="77.6pt" depth="201.1pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001EE.jpg" width="77.6pt" depth="201.1pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry objects. For this, the menu entry View/Editor of the canvas containing for instance a drawn volume must be activated. For starting the volume editor one can click on a volume. The GUI of the <emphasis role="bold"><code>TGeoManager</code></emphasis> class can be started by clicking on the top-right <code>40x40</code> pixels corner of the pad with a drawn geometry.</para>
<para>This is the main entry point for editing the geometry or creating new objects. Once the interface is created (using one of the methods described above), several categories can be accessed via a shutter GUI widget:</para>
<itemizedlist>
<listitem><para><emphasis role="italic">General.</emphasis> This allows changing the name/title of the geometry, setting the top volume, closing the geometry and saving the geometry in a file. The file name is formed by <code>geometry_name.C</code> or         <code>.root</code> depending if the geometry need to be saved as a <code>C</code> macro or a <code>.root</code> file.</para></listitem>
<listitem><para><emphasis role="italic">Shapes.</emphasis> The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.</para></listitem>
<listitem><para><emphasis role="italic">Volumes.</emphasis> The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.</para></listitem>
<listitem><para><emphasis role="italic">Materials.</emphasis> Allows creation of new materials/mixtures or editing existing ones.</para></listitem>
<listitem><para><emphasis role="italic">Media.</emphasis> The same for creation/editing of tracking media (materials having a set of properties related to tracking)</para></listitem>
<listitem><para><emphasis role="italic">Matrices.</emphasis> Allows creation of translations, rotations or combined transformations.  Existing matrices can also be browser/edited.</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>Editing Existing Objects</title>
<para>For editing an existing object from one of the categories described above, the interface imposes first a selection among all objects of the corresponding type stored in the geometry. This can be done by clicking the button next to the blue label <emphasis role="italic">Select &lt;object&gt;</emphasis>. The dialog interfaces are generally different for different types of objects. The volume selection dialog offers the possibility to select either a volume already connected to the geometry hierarchy or non-connected ones. Selection for shapes and matrices is split into categories represented by top-level list tree items for: boxes, tubes, translations, rotations, etc.</para>

<figure><title>Selection dialogs for different TGeo objects</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001EF.png" width="176.9pt" depth="140.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>Once a selection is made and the dialog is closed, the selected item name will appear in the corresponding label and the button Edit will start the object editor in a transient frame. Closing these transient frames will not delete, but just hide existing opened editors for later reuse. Their lifetime is determined by the canvas to which the manager editor is attached to, since these will be destroyed together.</para>

<figure><title>Editors for shapes, materials, media, matrices</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001F0.jpg" width="72.6pt" depth="201.7pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001F1.jpg" width="1in" depth="201.7pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001F2.jpg" width="1in" depth="201.7pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001F3.jpg" width="69.5pt" depth="201.7pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001F4.png" width="86.3pt" depth="255.7pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>For most editors, the functionalities Apply and Undo are provided.</para>
<para>For shapes, changing any of the shape parameters will activate the “<emphasis role="italic">Apply</emphasis>” button only if the check button “<emphasis role="italic">Delayed draw</emphasis>” is checked, otherwise the changes are immediately applied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The “<emphasis role="italic">Undo</emphasis>” button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape. </para>
<para>NOTE: In this version the “<emphasis role="italic">Undo</emphasis>”  does not allow restoring an intermediate state of the parameters that was applied – it will always restore the parameters at the moment the shape was edited.</para>
<para>All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other mehod is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsability. Adding materials as components of a mixture is not supported in this version. </para>
<para>The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable.</para>
</sect2>

<sect2>
<title>Creation of New Objects</title>
<para>As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object.</para>
</sect2>

<sect2>
<title>Editing Volumes</title>
<para>Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:</para>
<itemizedlist>
<listitem><para><emphasis role="italic">General</emphasis>. This category allows changing the name of the volume and selecting other shape or medium among existing ones. </para></listitem>
<listitem><para><emphasis role="italic">Daughters</emphasis>. The category allows removing existing daughter nodes or adding new ones. The button “<emphasis role="italic">Position</emphasis>” allows editing the positioning matrix of a given node.</para></listitem>
</itemizedlist>

<figure><title>Setting volume properties and modifying volume hierarchy</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001F5.jpg" width="3in" depth="162.6pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001F6.jpg" width="3in" depth="161.4pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para/>
<itemizedlist>
<listitem><para><emphasis role="italic">Visualization</emphasis>. This category allows changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button “<emphasis role="italic">All</emphasis>” allows viewing all volumes down to the selected depth. “<emphasis role="italic">Leaves</emphasis>” will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside.  “<emphasis role="italic">Only</emphasis>” will allow drawing only the edited volume.  The check button “<emphasis role="italic">Raytrace</emphasis>” will just draw the current selection in solid mode using the ray-tracing algorithm provided by TGeo.</para></listitem>
</itemizedlist>

<figure><title>Volume visualisation settings and division interface for volumes</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001F7.jpg" width="3in" depth="162.6pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/020001F8.jpg" width="3in" depth="162.6pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para/>
<itemizedlist>
<listitem><para><emphasis role="italic">Division</emphasis>. Allows dividing the edited volume according a given pattern. The division axes that are allowed are presented in a radio-button group. The number entries labeled “<emphasis role="italic">From</emphasis>”, “<emphasis role="italic">Step</emphasis>” and “<emphasis role="italic">Nslices</emphasis>” correspond to the divisioning parameters on the selected axis. The range of the division is between <code>start</code> and <code>start+ndiv*step</code> values and its validity is checked upon changing one of the values.</para></listitem>
</itemizedlist>
<para>NOTE: When changing a value in a number entry by typing a number, press ENTER at the end to validate. This applies for taking into account and validation of any number change in the geometry editors. </para>
</sect2>

<sect2>
<title>How to Create a Valid Geometry with Geometry Editors</title>
<para>1. Create a new geometry manager and start the editor as described at the beginning.</para>
<para>2. Create at least one material from the "<emphasis role="italic">Materials</emphasis>" shutter item category. Generally, for creating objects, the interface is always in the <emphasis role="bold"><code>TGeoManagerEditor</code></emphasis> in different categories - one should just provide a name and requested parameters.</para>
<para>3. Create a shape that will be used for the top volume within the "<emphasis role="italic">Shapes</emphasis>" category. For the moment, the shapes that have editors are Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype, Pcon, Torus and Sphere.</para>
<para>4. Create a medium from one of the existing materials from the "<emphasis role="italic">Medium</emphasis>" category. You will notice that some categories as "<emphasis role="italic">Volume</emphasis>" and "<emphasis role="italic">Medium</emphasis>" are inactive at the beginning because at that time there is no material yet (for making a medium) and no shape (for making a volume). These categories are dynamically activated once all the required components are defined.</para>
<para>5. Create a volume from the "<emphasis role="italic">Volumes</emphasis>" category. You will notice that contrary to the other editors, the volume editor is opened in a tab, not transient - this is because it is more complex.</para>
<para>6. Go back to "<emphasis role="italic">General</emphasis>" category and select the newly created volume as the top one (you can do it also from the volume category). This is just for starting. To create some hierarchy, one has to create several other volumes and the matrices to position them. Once this is done, use the volume editor interface to:</para>
<itemizedlist>
<listitem><para>add/remove daughters, change shape, edit position of daughters</para></listitem>
<listitem><para>change visualization settings</para></listitem>
<listitem><para>divide the volume (only if there are no daughters yet)</para></listitem>
</itemizedlist>
<para>7. Close the geometry from the “<emphasis role="italic">General</emphasis>” category.</para>
</sect2>
</sect1>
</chapter>



