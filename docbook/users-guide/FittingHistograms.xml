<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0">
<title>Fitting Histograms</title>
<para>To fit a histogram you can use the Fit Panel on a visible histogram via the context menu, or you can use the <emphasis role="bold"><code>TH1</code></emphasis><code>::Fit</code>    method. The Fit Panel, which is limited, is best for prototyping. The histogram needs to be drawn in a pad before the Fit Panel is invoked. The method <emphasis role="bold"><code>TH1</code></emphasis><code>::Fit</code> is more powerful and is used in scripts and programs.</para>

<sect1>
<title>The Fit Method</title>
<para>To fit a histogram programmatically, you can use the <emphasis role="bold"><code>TH1</code></emphasis><code>::Fit</code> method. Here is the signature of <emphasis role="bold"><code>TH1</code></emphasis><code>::Fit</code> and an explanation of the parameters:</para>

<programlisting language="c++">
void Fit(const char *fname, Option_t *option, Option_t *goption,
Axis_t xxmin, Axis_t  xxmax)
</programlisting>

<itemizedlist>
<listitem><para><code>*fname: </code>The name of the fitted function (the model) is passed as the first parameter. This name may be one of ROOT pre-defined function names or a
user-defined function. The functions below are predefined, and can be used with the <emphasis role="bold"><code>TH1</code></emphasis><code>::Fit</code>
method:</para></listitem>
<listitem><para>"<code>gaus</code>" Gaussian function with 3 parameters:              <code>f(x) = p0*exp(-0.5*((x-p1)/p2)^2))</code></para></listitem>
<listitem><para>"<code>expo</code>"An Exponential with 2 parameters:  <code>f(x) = exp(p0+p1*x)</code> </para></listitem>
<listitem><para>"<code>pol</code><emphasis role="italic"><code>N</code></emphasis>" A polynomial of degree <emphasis role="italic">N</emphasis>:   <code>f(x) = p0 + p1*x + p2*x2 +...</code> </para></listitem>
<listitem><para>"<code>landau</code>" Landau function with mean and sigma. This function has been adaptedfrom the <code>CERNLIB</code> routine <code>G110 denlan</code>.</para></listitem>
<listitem><para><code>*option:</code>The second parameter is the fitting option. Here is the list of fitting options:</para></listitem>
<listitem><para>"<code>W</code>" Set all weights to 1 for non empty bins; ignore error bars</para></listitem>
<listitem><para>"<code>WW</code>" Set all weights to 1 including empty bins; ignore error bars</para></listitem>
<listitem><para>"<code>I</code>" Use integral of function in bin instead of value at bin center</para></listitem>
<listitem><para>"<code>L</code>" Use log likelihood method (default is chi-square method)</para></listitem>
<listitem><para>"<code>U</code>" Use a user specified fitting algorithm </para></listitem>
<listitem><para>"<code>Q</code>" Quiet mode (minimum printing)</para></listitem>
<listitem><para>"<code>V</code>" Verbose mode (default is between Q and V)</para></listitem>
<listitem><para>"<code>E</code>" Perform better errors estimation using the Minos technique</para></listitem>
<listitem><para>"<code>M</code>" Improve fit results</para></listitem>
<listitem><para>"<code>R</code>" Use the range specified in the function range</para></listitem>
<listitem><para>"<code>N</code>" Do not store the graphics function, do not draw</para></listitem>
<listitem><para>"<code>0</code>" Do not plot the result of the fit. By default the fitted function is drawn unless the option "<code>N</code>" above is specified.</para></listitem>
<listitem><para>"<code>+</code>" Add this new fitted function to the list of fitted functions (by default, the previous function is deleted and only the last one is kept)</para></listitem>
<listitem><para>"<code>B</code>"Use this option when you want to fix one or more parameters and the fitting function is like <code>polN</code>, <code>expo</code>, <code>landau</code>, <code>gaus</code>.</para></listitem>
<listitem><para>“<code>LL</code>”An improved Log Likelihood fit in case of very low statistics and when bincontentsare not integers. Do not use this option if bin contents are large (greater than 100).</para></listitem>
<listitem><para>“<code>C</code>”In case of linear fitting, don't calculate the chisquare (saves time).</para></listitem>
<listitem><para>“<code>F</code>”If fitting a <code>polN</code>, switch to <code>Minuit</code> fitter (by default, <code>polN</code> functions are fitted by the linear fitter).</para></listitem>
<listitem><para><code>*goption: </code>The third parameter is the graphics option that is the same as in the <emphasis role="bold"><code>TH1</code></emphasis><code>::Draw</code> (see the chapter Draw Options).</para></listitem>
<listitem><para><code>xxmin</code>, <code>xxmax:</code>Thee fourth and fifth parameters specify the range over which to apply the fit. </para></listitem>
</itemizedlist>

<para>By default, the fitting function object is added to the histogram and is drawn in the current pad.</para>
</sect1>

<sect1>
<title>Fit with a Predefined Function</title>
<para>To fit a histogram with a predefined function, simply pass the name of the function in the first parameter of <emphasis role="bold"><code>TH1</code></emphasis><code>::Fit</code>. For example, this line fits histogram object <code>hist</code> with a Gaussian.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>hist.Fit("gaus");</code></emphasis>
</programlisting>

<para>The initial parameter values for pre-defined functions are set automatically.</para>
</sect1>

<sect1>
<title>Fit with a User-Defined Function</title>
<para>You can create a <emphasis role="bold"><code>TF1</code></emphasis> object and use it in the call the <emphasis role="bold"><code>TH1</code></emphasis><code>::Fit</code>. The parameter in to the <code>Fit</code> method is the NAME of the <emphasis role="bold"><code>TF1</code></emphasis> object. There are three ways to create a <emphasis role="bold"><code>TF1</code></emphasis>. </para>
<itemizedlist>
<listitem><para>Using C++ expression using x with a fixed set of operators and functions defined in <emphasis role="bold"><code>TFormula</code></emphasis>.</para></listitem>
<listitem><para>Same as first one, with parameters</para></listitem>
<listitem><para>Using a function that you have defined </para></listitem>
</itemizedlist>
<sect2>
<title>Creating a TF1 with a Formula</title>
<para>Let's look at the first case. Here we call the <emphasis role="bold"><code>TF1</code></emphasis> constructor by giving it the formula: <code>sin(x)/x</code>.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TF1  *f1 = new TF1("f1","sin(x)/x",0,10)</code></emphasis>
</programlisting>

<para>You can also use a <emphasis role="bold"><code>TF1</code></emphasis> object in the constructor of another <emphasis role="bold"><code>TF1</code></emphasis>.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TF1  *f2 = new TF1("f2","f1*2",0,10)</code></emphasis>
</programlisting>

</sect2>

<sect2>
<title>Creating a TF1 with Parameters</title>
<para>The second way to construct a <emphasis role="bold"><code>TF1</code></emphasis> is to add parameters to the expression. Here we use two parameters:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TF1 *f1 = new TF1("f1","[0]*x*sin([1]*x)",-3,3);</code></emphasis>
</programlisting>

<figure><title>The function x*<code>sin(x)</code></title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/03000060.png" width="207.95pt" depth="147.7pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para/>
<para>The parameter index is enclosed in square brackets. To set the initial parameters explicitly you can use:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>f1-&gt;SetParameter(0,10);</code></emphasis>
</programlisting>

<para>This sets parameter 0 to 10. You can also use <code>SetParameters</code> to set multiple parameters at once.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>f1-&gt;SetParameters(10,5);</code></emphasis>
</programlisting>

<para>This sets parameter 0 to 10 and parameter 1 to 5. We can now draw the <emphasis role="bold"><code>TF1</code></emphasis><code>:</code>   </para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>f1-&gt;Draw()</code></emphasis>
</programlisting>

</sect2>

<sect2>
<title>Creating a TF1 with a User Function</title>
<para>The third way to build a <emphasis role="bold"><code>TF1</code></emphasis> is to define a function yourself and then give its name to the constructor. A function for a <emphasis role="bold"><code>TF1</code></emphasis> constructor needs to have this exact signature:</para>

<programlisting language="c++">
Double_t fitf(Double_t *x,Double_t *par)
</programlisting>

<para>The two parameters are:</para>
<itemizedlist>
<listitem><para><code>x </code>         a pointer to the dimension array. Each element contains a dimension. For a 1D histogram only <code>x[0]</code> is used, for a 2D histogram <code>x[0]</code> and <code>x[1]</code> is used, and for a 3D histogram <code>x[0]</code>, <code>x[1]</code>, and <code>x[2]</code> are used. For histograms, only 3 dimensions apply, but this method is also used to fit other objects, for example an ntuple could have 10 dimensions.</para></listitem>
<listitem><para><code>par</code> a pointer to the parameters array. This array contains the current values of parameters when it is called by the fitting function. </para></listitem>
</itemizedlist>
<para>The following script <code>$ROOTSYS/tutorials/fit/myfit.C</code> illustrates how to fit a 1D histogram with a user-defined function. First we declare the function. </para>

<programlisting language="c++">
<emphasis role="italic"><code>// define a function with 3 parameters</code></emphasis>
Double_t fitf(Double_t *x,Double_t *par)
{
Double_t arg = 0;
if (par[2] != 0) arg = (x[0] - par[1])/par[2];
Double_t fitval = par[0]*TMath::Exp(-0.5*arg*arg);
return fitval;
}
</programlisting>

<para>Now we use the function:</para>

<programlisting language="c++">
<emphasis role="italic"><code>// this function used fitf to fit a histogram</code></emphasis>
void fitexample() {

<emphasis role="italic"><code>  // open a file and get a histogram</code></emphasis>
TFile *f = new TFile("hsimple.root");
TH1F *hpx = (TH1F*)f-&gt;Get(*hpx);

<emphasis role="italic"><code>  // Create a TF1 object using the function defined above. The last three</code></emphasis>
<emphasis role="italic"><code>  //  parameters specify the number of parameters for the function.</code></emphasis>
TF1 *func = new TF1("fit",fitf,-3,3,3);
<emphasis role="italic"><code>  // set the parameters to the mean and RMS of the histogram</code></emphasis>
func-&gt;SetParameters(500,hpx-&gt;GetMean(),hpx-&gt;GetRMS());

<emphasis role="italic"><code>  // give the parameters meaningful names</code></emphasis>
func-&gt;SetParNames ("Constant","Mean_value","Sigma");

<emphasis role="italic"><code>  // call TH1::Fit with the name of the TF1 object </code></emphasis>
hpx-&gt;Fit("fit");
}
</programlisting>

</sect2>
</sect1>

<sect1>
<title>Fixing and Setting Parameters’ Bounds</title>
<para>Parameters must be initialized before invoking the <code>Fit</code> method. The setting of the parameter initial values is automatic for the predefined functions: <code>poln</code>, <code>exp</code>, <code>gaus</code>, and <code>landau</code>. You can fix one or more parameters by specifying the "B" option when calling the <code>Fit</code> method. When a function is not predefined, the fit parameters must be initialized to some value as close as possible to the expected values before calling the fit function. </para>
<para>To set bounds for one parameter, use <emphasis role="bold"><code>TF1</code></emphasis><code>::SetParLimits</code>: </para>

<programlisting language="c++">
<code>func-&gt;SetParLimits(0,-1,1);</code>
</programlisting>

<para>When the lower and upper limits are equal, the parameter is fixed. Next two statements fix parameter 4 at 10.</para>

<programlisting language="c++">
func-&gt;SetParameter(4,10);
func-&gt;SetParLimits(4,10,10);
</programlisting>

<para>However, to fix a parameter to 0, one must call the <code>FixParameter</code> function:</para>

<programlisting language="c++">
func-&gt;SetParameter(4,0);
func-&gt;FixParameter(4,0);
</programlisting>

<para>Note that you are not forced to set the limits for all parameters. For example, if you fit a function with 6 parameters, you can:</para>

<programlisting language="c++">
func-&gt;SetParameters(0,3.1,1.e-6,-1.5,0,100);
func-&gt;SetParLimits(3,-10,4);
func-&gt;FixParameter(4,0);
</programlisting>

<para>With this setup, parameters 0<code>-&gt;</code>2 can vary freely, parameter 3 has boundaries [-10, 4] with initial value –1.5, and parameter 4 is fixed to 0.</para>
</sect1>

<sect1>
<title>Fitting Sub Ranges</title>
<para>By default, <emphasis role="bold"><code>TH1</code></emphasis><code>::Fit</code>         will fit the function on the defined histogram range. You can specify the option "<code>R</code>" in the second parameter of <emphasis role="bold"><code>TH1</code></emphasis><code>::Fit</code> to restrict the fit to the range specified in the <emphasis role="bold"><code>TF1</code></emphasis> constructor. In this example, the fit will be limited to –3 to 3, the range specified in the <emphasis role="bold"><code>TF1</code></emphasis> constructor.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TF1 *f1 = new TF1("f1","[0]*x*sin([1]*x)",-3,3);</code></emphasis>
root[] <emphasis role="bold"><code>hist-&gt;Fit("f1","R");</code></emphasis>
</programlisting>

<para>You can also specify a range in the call to <emphasis role="bold"><code>TH1</code></emphasis><code>::Fit</code>:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>hist-&gt;Fit("f1","","",-2,2)</code></emphasis>
</programlisting>

<para>See macros <code>$ROOTSYS/tutorials/fit/myfit.C</code> and <code>multifit.C </code>as more completed examples.</para>
</sect1>

<sect1>
<title>The Fit Panel</title>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000061.png" width="209.45pt" depth="363.65pt"/></imageobject></inlinemediaobject>To display the Fit Panel right click on a histogram to pop up the context menu, and then select the menu entry Fit Panel.</para>
<para>The new Fit Panel GUI is available in ROOT v5.14. Its goal is to replace the old Fit Panel and to provide more user friendly way for performing, exploring and comparing fits. </para>
<para>By design, this user interface is planned to contain two tabs: “General” and “Minimization”. Currently, the “General” tab provides user interface elements for setting the fit function, fit method and different fit, draw, print options. </para>
<para>The new fit panel is a modeless dialog, i.e. when opened, it does not prevent users from interacting with other windows. Its first prototype is a singleton application. When the Fit Panel is activated, users can select an object for fitting in the usual way, i.e. by left-mouse click on it. If the selected object is suitable for fitting, the fit panel is connected with this object and users can perform fits by setting different parameters and options.</para>

<sect2>
<title>Function Choice and Settings</title>
<para><emphasis role="italic">‘Predefined’ combo box</emphasis> - contains a list of predefined functions in ROOT. You have a choice of several polynomials, a Gaussian, a Landau, and an Exponential function. The default one is Gaussian. </para>
<para><emphasis role="italic">‘Operation’ radio button group</emphasis> defines the selected operational mode between functions: </para>
<para><emphasis role="italic">Nop</emphasis> - no operation (default); </para>
<para><emphasis role="italic">Add</emphasis> – addition; </para>
<para><emphasis role="italic">Conv</emphasis> - convolution (will be implemented in the future). </para>
<para>Users can enter the function expression into the text entry field below the ‘Predefined’ combo box. The entered string is checked after the Enter key was pressed and an error message shows up, if the function string is not accepted. </para>
<para>‘<emphasis role="italic">Set Parameters</emphasis>’ button opens a dialog for parameters settings, which will be explaned later.</para>
</sect2>

<sect2>
<title>Fitter Settings</title>
<para><emphasis role="italic">‘Method’ combo box</emphasis> currently provides only two fit model choices: Chi-square and Binned Likelihood. The default one is Chi-square. The Binned Likelihood is recomended for bins with low statistics.</para>
<para><emphasis role="italic">‘Linear Fit’ check button</emphasis> sets the use of Linear fitter when is selected. Otherwise the minimization is done by Minuit, i.e. fit option "<code>F</code>" is applied. The Linear fitter can be selected only for functions linears in parameters (for example - <code>polN)</code>. </para>
<para><emphasis role="italic">‘Robust’ number entry</emphasis> sets the robust value when fitting graphs. </para>
<para><emphasis role="italic">‘No Chi-square’ check button</emphasis> switch On/Off the fit option “<code>C</code>” - do not calculate Chi-square (for Linear fitter). </para>
<para><emphasis role="italic">‘Integral’ check button</emphasis> switch On/Off the option “<code>I</code>” - use integral of function instead of value in bin center. </para>
<para><emphasis role="italic">‘Best Errors’</emphasis> sets On/Off the option “<code>E</code>” - better errors estimation by using Minos technique. </para>
<para><emphasis role="italic">‘All weights = 1’</emphasis> sets On/Off the option “<code>W</code>”- all weights set to 1 excluding empty bins; error bars ignored. </para>
<para><emphasis role="italic">‘Empty bins, weights=1’</emphasis> sets On/Off the option "<code>WW</code>" - all weights equal to 1 including empty bins; error bars ignored. </para>
<para><emphasis role="italic">‘Use range’</emphasis> sets On/Off the option “<code>R</code>” - fit only data within the specified function range. Sliders settings are used if this option is set to On. Users can change the function range values by pressing the left mouse button near to the left/right slider edges. It is possible to change both values simultaneously by pressing the left mouse button near to the slider center and moving it to a new position.</para>
<para><emphasis role="italic">‘Improve fit results’</emphasis> sets On/Off the option “<code>M</code>”- after minimum is found, search for a new one. </para>
<para><emphasis role="italic">‘Add to list’</emphasis> sets On/Off the option “<code>+</code>”- add function to the list without deleting the previous one. When fitting a histogram, the function is attached to the histogram's list of functions. By default, the previously fitted function is deleted and replaced with the most recent one, so the list only contains one function. Setting this option to On will add the newly fitted function to the existing list of functions for the histogram. Note that the fitted functions are saved with the histogram when it is written to a ROOT file. By default, the function is drawn on the pad displaying the histogram.</para>
</sect2>

<sect2>
<title>Draw Options</title>
<para><emphasis role="italic">‘SAME’</emphasis> sets On/Off function drawing on the same pad. When a fit is executed, the image of the function is drawn on the current pad.</para>
<para><emphasis role="italic">‘No drawing’</emphasis> sets On/Off the option “<code>0</code>”- do not draw the fit results. </para>
<para><emphasis role="italic">‘Do not store/draw’</emphasis> sets On/Off option “<code>N</code>”- do not store the function and do not draw it. </para>
</sect2>

<sect2>
<title>Print Options</title>
<para>This set of options specifies the amount of feedback printed on the root command line after performed  fits.</para>
<para><emphasis role="italic">‘Verbose’</emphasis> - prints fit results after each iteration. </para>
<para><emphasis role="italic">‘Quiet’</emphasis>  - no fit information is printed. </para>
<para><emphasis role="italic">‘Default’</emphasis>  - between Verbose and Quiet. </para>
</sect2>

<sect2>
<title>Command Buttons</title>
<para><emphasis role="italic">Fit button</emphasis> - performs a fit taking different option settings via the Fit Panel interface. </para>
<para><emphasis role="italic">Reset</emphasis> - sets the GUI elements and related fit settings to the default ones. </para>
<para><emphasis role="italic">Close</emphasis> - closes the Fit panel window.</para>
</sect2>
</sect1>

<sect1>
<title>Fitting Multiple Sub Ranges</title>
<para>The script for this example is <code>$ROOTSYS/tutorials/fit/multifit.C</code>. It shows how to use several Gaussian functions with different parameters on separate sub ranges of the same histogram. To use a Gaussian, or any other ROOT built in function, on a sub range you need to define a new <emphasis role="bold"><code>TF1</code></emphasis>. Each is 'derived' from the canned function <code>gaus</code>.</para>

<figure><title>Fitting a histogram with several Gaussian functions</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/03000062.png" width="205.45pt" depth="148.95pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>First, four TF1 objects are created – one for each sub-range:</para>

<programlisting language="c++">
g1 = new TF1("m1","gaus",85,95);
g2 = new TF1("m2","gaus",98,108);
g3 = new TF1("m3","gaus",110,121);
<emphasis role="italic"><code>// The total is the sum of the three, each has 3 parameters</code></emphasis>
total = new TF1("mstotal","gaus(0)+gaus(3)+gaus(6)",85,125);
</programlisting>

<para>Next, we fill a histogram with bins defined in the array x.</para>

<programlisting language="c++">
<emphasis role="italic"><code>// Create a histogram and set it's contents</code></emphasis>
<code>h = new TH1F("g1","Example of several fits in subranges",np,85,134);</code>
<code>h-&gt;SetMaximum(7);</code>
<code>for (int i=0; i&lt;np; i++) {</code>
<code>   h-&gt;SetBinContent(i+1,x[i]);</code>
<code>}</code>
<emphasis role="italic"><code>// Define the parameter array for the total function</code></emphasis>
<code>Double_t par[9];</code>
</programlisting>

<para>When fitting simple functions, such as a Gaussian, the initial values of the parameters are automatically computed by ROOT. In the more complicated case of the sum of 3 Gaussian functions, the initial values of parameters must be set. In this particular case, the initial values are taken from the result of the individual fits. The use of the "+" sign is explained below:</para>

<programlisting language="c++">
<emphasis role="italic"><code>// Fit each function and add it to the list of functions</code></emphasis>
<code>h-&gt;Fit(g1,"R");</code>
<code>h-&gt;Fit(g2,"R+");</code>
<code>h-&gt;Fit(g3,"R+");</code>

<emphasis role="italic"><code>// Get the parameters from the fit</code></emphasis>
<code>g1-&gt;GetParameters(&amp;par[0]);</code>
<code>g2-&gt;GetParameters(&amp;par[3]);</code>
<code>g3-&gt;GetParameters(&amp;par[6]);</code>

<emphasis role="italic"><code>// Use the parameters on the sum</code></emphasis>
<code>total-&gt;SetParameters(par);</code>
<code>h-&gt;Fit(total,"R+");</code>
</programlisting>

</sect1>

<sect1>
<title>Adding Functions to the List</title>
<para>The example <code>$ROOTSYS/tutorials/fit/multifit.C</code> also illustrates how to fit several functions on the same histogram. By default a Fit command deletes the previously fitted function in the histogram object. You can specify the option "+" in the second parameter to add the newly fitted function to the existing list of functions for the histogram. </para>

<programlisting language="c++">
root[]<emphasis role="bold"><code> hist-&gt;Fit("f1","+","",-2,2)</code></emphasis>
</programlisting>

<para>Note that the fitted function(s) are saved with the histogram when it is written to a ROOT file.</para>
</sect1>

<sect1>
<title>Combining Functions</title>
<para>You can combine functions to fit a histogram with their sum as it is illustrated in the macro <code>FitDemo.C</code> (<code>$ROOTSYS/tutorials/fit/FittingDemo.C)</code>. We have a function that is the combination of a background and Lorentzian peak. Each function contributes 3 parameters:</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000063.png" width="153.95pt" depth="53.4pt"/></imageobject></inlinemediaobject>
</para>
<para>BackgroundLorentzian Peak</para>
<para><code>par[0]</code> = <inlinemediaobject><imageobject><imagedata fileref="pictures/08000064.png" width="13.05pt" depth="16.75pt"/></imageobject></inlinemediaobject><code>par[0]</code> = <inlinemediaobject><imageobject><imagedata fileref="pictures/08000065.png" width="16.15pt" depth="16.75pt"/></imageobject></inlinemediaobject></para>
<para><code>par[1]</code> = <inlinemediaobject><imageobject><imagedata fileref="pictures/08000066.png" width="13.65pt" depth="16.75pt"/></imageobject></inlinemediaobject><code>par[1]</code> = <inlinemediaobject><imageobject><imagedata fileref="pictures/08000067.png" width="13.05pt" depth="13.65pt"/></imageobject></inlinemediaobject></para>
<para><code>par[2]</code> = <inlinemediaobject><imageobject><imagedata fileref="pictures/08000068.png" width="13.05pt" depth="18pt"/></imageobject></inlinemediaobject><code>par[2]</code> = <inlinemediaobject><imageobject><imagedata fileref="pictures/08000069.png" width="13.05pt" depth="13.05pt"/></imageobject></inlinemediaobject></para>
<para>The combination function (<code>fitFunction</code>) has six parameters:</para>
<para>
<code>fitFunction = background(x,par) + LorentzianPeak(x,&amp;par[3])</code></para>
<para><code>par[0]=</code><inlinemediaobject><imageobject><imagedata fileref="pictures/0800006A.png" width="13.05pt" depth="16.75pt"/></imageobject></inlinemediaobject>   <code>par[1]=</code><inlinemediaobject><imageobject><imagedata fileref="pictures/0800006B.png" width="13.65pt" depth="16.75pt"/></imageobject></inlinemediaobject>   <code>par[2]=</code><inlinemediaobject><imageobject><imagedata fileref="pictures/0800006C.png" width="13.05pt" depth="18pt"/></imageobject></inlinemediaobject>   <code>par[3]=</code><inlinemediaobject><imageobject><imagedata fileref="pictures/0800006D.png" width="16.15pt" depth="16.75pt"/></imageobject></inlinemediaobject>   <code>par[4]=</code><inlinemediaobject><imageobject><imagedata fileref="pictures/0800006E.png" width="13.05pt" depth="13.65pt"/></imageobject></inlinemediaobject> <code> par[5]=</code><inlinemediaobject><imageobject><imagedata fileref="pictures/0800006F.png" width="12.4pt" depth="12.4pt"/></imageobject></inlinemediaobject></para>
<para>This script creates a histogram and fits it with the combination of two functions. First we define the two functions and the combination function:</para>

<programlisting language="c++">
<emphasis role="italic"><code>// Quadratic background function</code></emphasis>
Double_t background(Double_t *x, Double_t *par) {
return par[0] + par[1]*x[0] + par[2]*x[0]*x[0];
}
<emphasis role="italic"><code>// </code></emphasis><emphasis role="italic"><code>Lorentzian</code></emphasis><emphasis role="italic"><code> Peak function</code></emphasis>
Double_t lorentzianPeak(Double_t *x, Double_t *par) {
return (0.5*par[0]*par[1]/TMath::Pi()) / TMath::Max(1.e-10,
(x[0]-par[2])*(x[0]-par[2])+ .25*par[1]*par[1]);
}

<emphasis role="italic"><code>// Sum of background and peak function</code></emphasis>
Double_t fitFunction(Double_t *x, Double_t *par) {
return background(x,par) + lorentzianPeak(x,&amp;par[3]);
}
void FittingDemo() {
<emphasis role="italic"><code>// bevington exercise by P. Malzacher, modified by R. Brun</code></emphasis>
const int nBins = 60;
Stat_t data[nBins] = {  6, 1,10,12, 6,13,23,22,15,21,
23,26,36,25,27,35,40,44,66,81,
75,57,48,45,46,41,35,36,53,32,
40,37,38,31,36,44,42,37,32,32,
43,44,35,33,33,39,29,41,32,44,
26,39,29,35,32,21,21,15,25,15};
TH1F *histo = new TH1F("example_9_1",
"Lorentzian Peak on Quadratic Background",60,0,3);

for(int i=0; i &lt; nBins;  i++) {
<emphasis role="italic"><code>// we use these methods to explicitly set the content</code></emphasis>
<emphasis role="italic"><code>      // and error instead of using the fill method. </code></emphasis>
histo-&gt;SetBinContent(i+1,data[i]);
histo-&gt;SetBinError(i+1,TMath::Sqrt(data[i]));
}
<emphasis role="italic"><code>   // create a TF1 with the range from 0 to 3 and 6 parameters</code></emphasis>
TF1 *fitFcn = new TF1("fitFcn",fitFunction,0,3,6);

<emphasis role="italic"><code>   // first try without starting values for the parameters</code></emphasis>
<emphasis role="italic"><code>   // this defaults to 1 for each param. </code></emphasis>
histo-&gt;Fit("fitFcn");
<emphasis role="italic"><code>   // this results in an ok fit for the polynomial function however</code></emphasis>
<emphasis role="italic"><code>   // the non-linear part (</code></emphasis><emphasis role="italic"><code>Lorentzian</code></emphasis><emphasis role="italic"><code>) does not respond well  </code></emphasis>
<emphasis role="italic"><code>   // second try: set start values for some parameters</code></emphasis>
fitFcn-&gt;SetParameter(4,0.2);   // width
fitFcn-&gt;SetParameter(5,1);     // peak
histo-&gt;Fit("fitFcn","V+");

<emphasis role="italic"><code>   // improve the picture:</code></emphasis>
TF1 *backFcn = new TF1("backFcn",background,0,3,3);
backFcn-&gt;SetLineColor(3);
TF1 *signalFcn = new TF1("signalFcn",lorentzianPeak,0,3,3);
signalFcn-&gt;SetLineColor(4);
Double_t par[6];

<emphasis role="italic"><code>// writes the fit results into the par array</code></emphasis>
fitFcn-&gt;GetParameters(par);
backFcn-&gt;SetParameters(par);
backFcn-&gt;Draw("same");
signalFcn-&gt;SetParameters(&amp;par[3]);
signalFcn-&gt;Draw("same");
}
</programlisting>

<para>For another example see:  <uri xmlns:xlink="http://root.cern.ch/root/html/examples/backsig.C.html">http://root.cern.ch/root/html/examples/backsig.C.html</uri></para>

<figure><title>The output of the FittingDemo() example</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/03000070.png" width="260.05pt" depth="222.2pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect1>

<sect1>
<title>Associated Function</title>
<para>One or more objects (typically a <emphasis role="bold"><code>TF1</code></emphasis>*) can be added to the list of functions (<code>fFunctions</code>) associated to each histogram. A call to <emphasis role="bold"><code>TH1</code></emphasis><code>::Fit</code> adds the fitted function to this list. Given a histogram <code>h</code>, one can retrieve the associated function with:</para>

<programlisting language="c++">
TF1 *myfunc = h-&gt;GetFunction("myfunc");
</programlisting>

</sect1>

<sect1>
<title>Access to the Fit Parameters and Results</title>
<para>If the histogram (or graph) is made persistent, the list of associated functions is also persistent. Retrieve a pointer to the function with the <emphasis role="bold"><code>TH1</code></emphasis><code>::GetFunction()</code> method. Then you can retrieve the fit parameters from the function (<emphasis role="bold"><code>TF1</code></emphasis>) with calls such as:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TF1 *fit = hist-&gt;GetFunction(function_name);</code></emphasis>
root[]<emphasis role="bold"><code> Double_t chi2 = fit-&gt;GetChisquare();</code></emphasis>
<emphasis role="italic"><code>// value of the first parameter</code></emphasis>
root[] <emphasis role="bold"><code>Double_t p1 = fit-&gt;GetParameter(0);</code></emphasis>
<emphasis role="italic"><code>// error of the first parameter</code></emphasis>
root[] <emphasis role="bold"><code>Double_t e1 = fit-&gt;GetParError(0);</code></emphasis>
</programlisting>

</sect1>

<sect1>
<title>Associated Errors</title>
<para>By default, for each bin, the sum of weights is computed at fill time. One can also call <emphasis role="bold"><code>TH1</code></emphasis><code>::Sumw2</code> to force the storage and computation of the sum of the square of weights per bin. If Sumw2 has been called, the error per bin is computed as the <code>sqrt</code> <code>(</code>sum of squares of weights<code>)</code>; otherwise, the error is set equal to the <code>sqrt</code> <code>(bin content</code>). To return the error for a given bin number, do:</para>

<programlisting language="c++">
Double_t error = h-&gt;GetBinError(bin);
</programlisting>

<para>Empty bins are excluded in the fit when using the Chi-square fit method. When fitting the histogram with the low statistics, it is recommended to use the Log-Likelihood method (option ‘<code>L</code>’ or “<code>LL</code>”).</para>
</sect1>

<sect1>
<title>Fit Statistics</title>
<para>You can change the statistics box to display the fit parameters with the <emphasis role="bold"><code>TStyle</code></emphasis><code>::SetOptFit(mode)</code> method. This parameter has four digits:  <code>mode = pcev</code> (<code>default = 0111</code>)</para>
<itemizedlist>
<listitem><para><code>p</code>= 1print probability         </para></listitem>
<listitem><para><code>c</code> = 1print Chi-square/number of degrees of freedom</para></listitem>
<listitem><para><code>e</code>= 1print errors (if <code>e=1</code>, <code>v</code> must be 1)</para></listitem>
<listitem><para><code>v</code>= 1print name/values of parameters</para></listitem>
</itemizedlist>
<para>For example, to print the fit probability, parameter names/values, and errors, use:</para>

<programlisting language="c++">
gStyle-&gt;SetOptFit(1011);
</programlisting>

</sect1>

<sect1>
<title>The Minimization Package</title>
<para>This package was originally written in FORTRAN by Fred James and part of <code>PACKLIB</code> (patch D506). It has been converted to a C++ class by Rene Brun. The current implementation in C++ is a straightforward conversion of the original FORTRAN version. The main changes are:  </para>
<itemizedlist>
<listitem><para>The variables in the various <code>Minuit</code> labeled common blocks have been changed to the <emphasis role="bold"><code>TMinuit</code></emphasis> class data members</para></listitem>
<listitem><para>The internal arrays with a maximum dimension depending on the maximum number of parameters are now data members’ arrays with a dynamic dimension such that one can fit very large problems by simply initializing the <emphasis role="bold"><code>TMinuit</code></emphasis> constructor with the maximum number of parameters</para></listitem>
<listitem><para>The include file <code>Minuit.h</code> has been commented as much as possible using existing comments in the code or the printed documentation</para></listitem>
<listitem><para>The original <code>Minuit</code> subroutines are now member functions</para></listitem>
<listitem><para>Constructors and destructor have been added</para></listitem>
<listitem><para>Instead of passing the <code>FCN</code> function in the argument list, the addresses of this function is stored as pointer in the data members of the class. This is by far more elegant and flexible in an interactive environment. The member function <code>SetFCN</code> can be used to define this pointer</para></listitem>
<listitem><para>The ROOT static function <code>Printf</code> is provided to replace all format statements and to print on currently defined output file</para></listitem>
<listitem><para>The derived class <emphasis role="bold"><code>TMinuitOld</code></emphasis> contains obsolete routines from the FORTRAN based version</para></listitem>
<listitem><para>The functions <code>SetObjectFit/GetObjectFit</code>         can be used inside the <code>FCN</code> function to set/get a referenced object instead of using global variables</para></listitem>
<listitem><para>By default <code>fGraphicsMode</code> is true. When calling the <code>Minuit</code> functions such as <code>mncont</code>, <code>mnscan</code>, or any <code>Minuit</code> command invoking <code>mnplot</code>, <emphasis role="bold"><code>TMinuit</code></emphasis><code>::mnplot()</code> produces a <emphasis role="bold"><code>TGraph</code></emphasis> object pointed by <code>fPlot</code>. One can retrieve this object with <emphasis role="bold"><code>TMinuit</code></emphasis><code>::GetPlot().</code> For example: </para></listitem>
</itemizedlist>
<programlisting language="c++">
h-&gt;Fit("gaus");
gMinuit-&gt;Command("SCAn 1");
TGraph *gr = (TGraph*)gMinuit-&gt;GetPlot();
gr-&gt;SetMarkerStyle(21);
gr-&gt;Draw("alp");
</programlisting>
<itemizedlist>
<listitem><para>To set <code>Minuit</code> in no graphics mode, call </para></listitem>
</itemizedlist>
<programlisting language="c++">
gMinuit-&gt;SetGraphicsMode(kFALSE);
</programlisting>

<sect2>
<title>Basic Concepts of Minuit</title>
<para>The <code>Minuit</code> package acts on a multi parameter FORTRAN function to which one must give the generic name <code>FCN</code>. In the ROOT implementation, the function <code>FCN</code> is defined via the <code>Minuit</code> <code>SetFCN</code> member function when a <code>HistogramFit</code> command is invoked. The value of <code>FCN</code> will in general depend on one or more variable parameters. </para>
<para>To take a simple example, in case of ROOT histograms (classes <emphasis role="bold"><code>TH1C</code></emphasis>, <emphasis role="bold"><code>TH1S</code></emphasis>, <emphasis role="bold"><code>TH1F</code></emphasis>, <emphasis role="bold"><code>TH1D</code></emphasis>) the <code>Fit</code> function defines the <code>Minuit</code> fitting function as being <code>H1FitChisquare</code> or <code>H1FitLikelihood</code> depending on the options selected. <code>H1FitChisquare</code> calculates the chi-square between the user fitting function (Gaussian, polynomial, user defined, etc) and the data for given values of the parameters. It is the task of <code>Minuit</code> to find those values of the parameters which give the lowest value of chi-square. </para>
</sect2>

<sect2>
<title>The Transformation of Limited Parameters</title>
<para>For variable parameters with limits, <code>Minuit</code> uses the following transformation: </para>
<para>
<code>Pint = arcsin(2((Pext-a)/(b-a))-1) </code></para>
<para>
<code>Pext = a+((b-a)/(2))(sinPint+1)</code></para>
<para>so that the internal value <code>Pint</code> can take on any value, while the external value Pext can take on values only between the lower limit a and the ext upper limit b. Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the FCN value. The effects of non-linearity and numerical round off both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if he puts limits of (0, 1010) on a parameter, then the values 0.0 and 1. 0 will be indistinguishable to the accuracy of most machines. </para>
<para>The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the ''parabolic'' parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where partial <code>Pext/</code>partial<code> Pint≠0</code>. Therefore, it is recommended that: </para>
<itemizedlist>
<listitem><para>Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values </para></listitem>
<listitem><para>When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits </para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>How to Get the Right Answer from Minuit</title>
<para><code>Minuit</code> offers the user a choice of several minimization algorithms. The <code>MIGRAD</code> algorithm is in general the best minimized for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. Its main weakness is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate. </para>
<para>If parameter limits are needed, in spite of the side effects, then the user should be aware of the following techniques to alleviate problems caused by limits: </para>

<sect3>
<title>Getting the Right Minimum with Limits</title>
<para>If MIGRAD converges normally to a point where no parameter is near one of its limits, then the existence of limits has probably not prevented <code>Minuit</code> from finding the right minimum. On the other hand, if one or more parameters is near its limit at the minimum, this may be because the true minimum is indeed at a limit, or it may be because the minimized has become ''blocked'' at a limit. This may normally happen only if the parameter is so close to a limit (internal value at an odd multiple of <code>#((pi)/(2))</code>         that <code>Minuit</code> prints a warning to this effect when it prints the parameter values. The minimized can become blocked at a limit, because at a limit the derivative seen by the minimized <code>partial F/partial Pint</code> is zero no matter what the real derivative <code>partial F/partial Pext</code> is. </para>
<para>
<code>((partial F)/(partial Pint)) = </code></para>
<para>
<code>((partial F)/(partial Pext))((partial Pext)/(partial Pint)) =</code></para>
<para>
<code>                               ((partial F)/(partial Pext)) = 0 </code></para>
</sect3>

<sect3>
<title>Getting the Right Parameter Errors with Limits</title>
<para>In the best case, where the minimum is far from any limits, <code>Minuit</code> will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you would not need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. </para>
</sect3>

<sect3>
<title>Interpretation of Parameter Errors</title>
<para>There are two kinds of problems that can arise: the reliability of <code>Minuit</code>’s error estimates, and their statistical interpretation, assuming they are accurate. </para>
</sect3>

<sect3>
<title>Statistical Interpretation</title>
<para>For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:</para>
<itemizedlist>
<listitem><para>F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981</para></listitem>
<listitem><para>W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. <emphasis role="italic">Statistical Methods in Experimental Physics. North-Holland, 1971</emphasis></para></listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2>
<title>Reliability of Minuit Error Estimates</title>
<para><code>Minuit</code> always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a <code>HESSE</code> step, the errors are usually quite accurate, unless there has been a problem. <code>Minuit</code>, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked <code>CURRENT GUESS ERROR</code> are only working values not to be believed, and <code>APPROXIMATE ERROR</code> means that they have been calculated but there is reason to believe that they may not be accurate. </para>
<para>If no mitigating adjective is given, then at least <code>Minuit</code> believes the errors are accurate, although there is always a small chance that <code>Minuit</code> has been fooled. Some visible signs that <code>Minuit</code> may have been fooled: </para>
<itemizedlist>
<listitem><para>Warning messages produced during the minimization or error analysis </para></listitem>
<listitem><para>Failure to find new minimum </para></listitem>
<listitem><para>Value of EDM too big (estimated Distance to Minimum)</para></listitem>
<listitem><para>Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others</para></listitem>
<listitem><para>Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated</para></listitem>
<listitem><para>Parameter at limit. This condition, signaled by a <code>Minuit</code> warning message, may make both the function minimum and parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits'</para></listitem>
</itemizedlist>
<para>The best way to be absolutely sure of the errors is to use ''independent'' calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for a ''physical'' function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if <code>MIGRAD</code> reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following: </para>

<sect3>
<title>A Non-physical Region</title>
<para>On its way to the minimum, <code>MIGRAD</code> may have traversed a region that has unphysical behavior, which is of course not a serious problem as long as it recovers and leaves such a region. </para>
</sect3>

<sect3>
<title>An Underdetermined Problem</title>
<para>If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well defined, for example that there are more unknowns than there are data points, or that the parameterization of the fit contains a linear dependence. If this is the case, then <code>Minuit</code> (or any other program) cannot solve your problem uniquely. The error matrix will necessarily be largely meaningless, so the user must remove the under determinedness by reformulating the parameterization. <code>Minuit</code> cannot do this itself. </para>
</sect3>

<sect3>
<title>Numerical Inaccuracies</title>
<para>It is possible that the apparent lack of positive-definiteness is due to excessive round off errors in numerical calculations (in the user function), or not enough precision. This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are large. In any case, whether the non-positive-definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious. </para>
</sect3>

<sect3>
<title>An Ill-posed Problem</title>
<para>For questions of parameter dependence, see the discussion above on positive-definiteness. Possible other mathematical problems are the following:    </para>
<itemizedlist>
<listitem><para>Excessive numerical round off - be especially careful of exponential and factorial functions which get big very quickly and lose accuracy. </para></listitem>
<listitem><para>Starting too far from the solution - the function may have unphysical local minima, especially at infinity in some variables. </para></listitem>
</itemizedlist>
</sect3>
</sect2>
</sect1>

<sect1>
<title>FUMILI Minimization Package</title>
<para>FUMILI is used to minimize Chi-square function or to search maximum of likelihood function. Experimentally measured values<inlinemediaobject><imageobject><imagedata fileref="pictures/08000071.png" width="13.05pt" depth="14.9pt"/></imageobject></inlinemediaobject> are fitted with theoretical functions<inlinemediaobject><imageobject><imagedata fileref="pictures/08000072.png" width="44.7pt" depth="16.75pt"/></imageobject></inlinemediaobject>, where <inlinemediaobject><imageobject><imagedata fileref="pictures/08000073.png" width="12.4pt" depth="14.9pt"/></imageobject></inlinemediaobject> are coordinates, and <inlinemediaobject><imageobject><imagedata fileref="pictures/08000074.png" width="11.15pt" depth="14.3pt"/></imageobject></inlinemediaobject> - vector of parameters. For better convergence Chi-square function has to be the following form</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000075.png" width="134.05pt" depth="40.95pt"/></imageobject></inlinemediaobject>
</para>
<para>where <inlinemediaobject><imageobject><imagedata fileref="pictures/08000076.png" width="14.3pt" depth="14.9pt"/></imageobject></inlinemediaobject> are errors of the measured function. The minimum condition is: </para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000077.png" width="227.8pt" depth="37.25pt"/></imageobject></inlinemediaobject>
</para>
<para>where <code>m </code>is the quantity of parameters. Expanding left part of this equation over parameter increments and retaining only linear terms one gets</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000078.png" width="209.15pt" depth="39.1pt"/></imageobject></inlinemediaobject>
</para>
<para>here <inlinemediaobject><imageobject><imagedata fileref="pictures/08000079.png" width="14.3pt" depth="16.75pt"/></imageobject></inlinemediaobject> is some initial value of parameters. In general case: </para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0800007A.png" width="225.95pt" depth="37.85pt"/></imageobject></inlinemediaobject>
</para>
<para>In FUMILI algorithm for second derivatives of Chi-square approximate expression is used when last term in previous equation is discarded. It is often done, not always wittingly, and sometimes causes troubles, for example, if user wants to limit parameters with positive values by writing down <inlinemediaobject><imageobject><imagedata fileref="pictures/0800007B.png" width="14.9pt" depth="16.15pt"/></imageobject></inlinemediaobject> instead of <inlinemediaobject><imageobject><imagedata fileref="pictures/0800007C.png" width="12.4pt" depth="14.9pt"/></imageobject></inlinemediaobject>.  FUMILI will fail if one tries minimize <inlinemediaobject><imageobject><imagedata fileref="pictures/0800007D.png" width="58.35pt" depth="16.15pt"/></imageobject></inlinemediaobject> where <inlinemediaobject><imageobject><imagedata fileref="pictures/0800007E.png" width="11.15pt" depth="10.55pt"/></imageobject></inlinemediaobject>an arbitrary function is. Approximate value is: </para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0800007F.png" width="135.95pt" depth="35.4pt"/></imageobject></inlinemediaobject>
</para>
<para>Then the equations for parameter increments are:</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000080.png" width="214.75pt" depth="39.1pt"/></imageobject></inlinemediaobject>
</para>
<para>Remarkable feature of algorithm is the technique for step restriction. For an initial value of parameter <inlinemediaobject><imageobject><imagedata fileref="pictures/08000081.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject> a parallelepiped <inlinemediaobject><imageobject><imagedata fileref="pictures/08000082.png" width="13.05pt" depth="14.9pt"/></imageobject></inlinemediaobject>is built with the center at <inlinemediaobject><imageobject><imagedata fileref="pictures/08000083.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject> and axes parallel to coordinate axes <inlinemediaobject><imageobject><imagedata fileref="pictures/08000084.png" width="12.4pt" depth="14.9pt"/></imageobject></inlinemediaobject>. The lengths of parallelepiped sides along  <inlinemediaobject><imageobject><imagedata fileref="pictures/08000085.png" width="6.85pt" depth="10.55pt"/></imageobject></inlinemediaobject>-axis is <inlinemediaobject><imageobject><imagedata fileref="pictures/08000086.png" width="17.4pt" depth="14.9pt"/></imageobject></inlinemediaobject>, where <inlinemediaobject><imageobject><imagedata fileref="pictures/08000087.png" width="11.15pt" depth="14.9pt"/></imageobject></inlinemediaobject> is such a value that the functions <inlinemediaobject><imageobject><imagedata fileref="pictures/08000088.png" width="31.05pt" depth="17.4pt"/></imageobject></inlinemediaobject> are quasi-linear all over the parallelepiped. FUMILI takes into account simple linear inequalities in the form: <inlinemediaobject><imageobject><imagedata fileref="pictures/08000089.png" width="71.4pt" depth="17.4pt"/></imageobject></inlinemediaobject></para>
<para>They form parallelepiped <inlinemediaobject><imageobject><imagedata fileref="pictures/0800008A.png" width="12.4pt" depth="10.55pt"/></imageobject></inlinemediaobject> (<inlinemediaobject><imageobject><imagedata fileref="pictures/0800008B.png" width="13.05pt" depth="14.9pt"/></imageobject></inlinemediaobject> may be deformed by <inlinemediaobject><imageobject><imagedata fileref="pictures/0800008C.png" width="12.4pt" depth="10.55pt"/></imageobject></inlinemediaobject>). Very similar step formulae are used in FUMILI for negative logarithm of the likelihood function with the same idea - linearization of functional argument.</para>
</sect1>

<sect1>
<title>Neural Networks</title>

<sect2>
<title>Introduction</title>
<para>Neural Networks are used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are image analysis, financial movements’ predictions and analysis, or sales forecast and product shipping optimization. In particles physics neural networks are mainly used for classification tasks (signal over background discrimination). A vast majority of commonly used neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the <code>MLPfit</code> package, which remains one of the fastest tools for neural networks studies.</para>
</sect2>

<sect2>
<title>The MLP</title>
<para>The multilayer perceptron is a simple feed-forward network with the following structure showed on the left.<inlinemediaobject><imageobject><imagedata fileref="pictures/0300008D.png" width="108pt" depth="115.5pt"/></imageobject></inlinemediaobject></para>
<para>It is made of neurons characterized by a bias and weighted links in between  - let's call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers. </para>
<para>Such a structure is very useful because of two theorems:</para>
<para>1. A linear combination of <code>sigmoids</code> can approximate any continuous function.</para>
<para>2. Trained with <code>output=1</code> for the signal and 0 for the background, the approximated function of inputs <code>X</code> is the probability of signal, knowing <code>X</code>.</para>
</sect2>

<sect2>
<title>Learning Methods</title>
<para>The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrate, divided by two, of the error on each individual output neuron. In all methods implemented in this library, one needs to compute the first derivative of that error with respect to the weights. Exploiting the well-known properties of the derivative, one can express this derivative as the product of the local partial derivative by the weighted sum of the outputs derivatives (for a neuron) or as the product of the input value with the local partial derivative of the output neuron (for a synapse). This computation is called "back-propagation of the errors". Six learning methods are implemented.</para>

<sect3>
<title>Stochastic Minimization</title>
<para>This is the most trivial learning method. The Robbins-Monro stochastic approximation is applied to multilayer perceptrons. The weights are updated after each example according to the formula:</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0300008E.png" width="135.95pt" depth="26.7pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0300008F.png" width="198.6pt" depth="24.2pt"/></imageobject></inlinemediaobject>
</para>
<para>The parameters for this method are <code>Eta</code>, <code>EtaDecay</code>, <code>Delta</code> and <code>Epsilon</code>.</para>
</sect3>

<sect3>
<title>Steepest Descent With Fixed Step Size (Batch Learning)</title>
<para>It is the same as the stochastic minimization, but the weights are updated after considering all the examples, with the total derivative <code>dEdw</code>. The parameters for this method are <code>Eta</code>, <code>EtaDecay</code>, <code>Delta</code> and <code>Epsilon</code>.</para>
</sect3>

<sect3>
<title>Steepest Descent Algorithm</title>
<para>Weights are set to the minimum along the line defined by the gradient. The only parameter for this method is <code>Tau</code>. Lower <code>Tau</code> = higher precision = slower search. A value <code>Tau=3</code> seems reasonable.</para>
</sect3>

<sect3>
<title>Conjugate Gradients With the Polak-Ribiere Updating Formula</title>
<para>Weights are set to the minimum along the line defined by the conjugate gradient. Parameters are <code>Tau</code> and <code>Reset</code>, which defines the epochs where the direction is reset to the steepest descent (estimated by using the Polak-Ribiere formula).</para>
</sect3>

<sect3>
<title>Conjugate Gradients With the Fletcher-Reeves Updating Formula</title>
<para>Weights are set to the minimum along the line defined by the conjugate gradient. Parameters are <code>Tau</code> and <code>Reset</code>, which defines the epochs where the direction is reset to the steepest descent (estimated by using the Fletcher-Reeves formula).</para>
</sect3>

<sect3>
<title>The Broyden, Fletcher, Goldfarb, Shanno (BFGS) Method</title>
<para>It implies the computation of a <code>NxN</code> matrix, but seems more powerful at least for less than 300 weights. Parameters are <code>Tau</code> and <code>Reset</code>, which defines the epochs where the direction is reset to the steepest descent.</para>
</sect3>
</sect2>

<sect2>
<title>Using the Network</title>
<para>Neural network are build from a set of "samples". A sample is a set of values defining the inputs and the corresponding output that the network should ideally provide. In ROOT this is a <emphasis role="bold"><code>TTree</code></emphasis> entry.  The first thing to be decided is the network layout. This layout is described in a string where the layers are separated by semicolons. The input/output layers are defined by giving the expression for each neuron, separated by comas. Hidden layers are just described by the number of neurons. </para>
<para>In addition, input and output layer formulas can be preceded by '@' (e.g. "@out") if one wants to normalize the corresponding value. Also, if the string ends with '<code>!</code>', output neurons are set up for classification, i.e. with a sigmoid (1 neuron) or softmax (more neurons) activation function.</para>
<para>Many questions on the good usage of neural network, including rules of dumb to determine the best network topology are addressed at  <uri xmlns:xlink="ftp://ftp.sas.com/pub/neural/FAQ.html">ftp://ftp.sas.com/pub/neural/FAQ.html</uri></para>

<programlisting language="c++">
<emphasis role="italic"><code>// a simple network: 2 inputs, 10</code></emphasis><emphasis role="italic"><code> hidden and 1 normalized output neuron</code></emphasis>
TMultiLayerPerceptron network("r,z:10:@Br",tree);
</programlisting>

<para>Expressions are evaluated as for <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw()</code>. Input and outputs are taken from the <emphasis role="bold"><code>TTree</code></emphasis> associated with the network. This <emphasis role="bold"><code>TTree</code></emphasis> can be given as argument of the constructor or defined later with <emphasis role="bold"><code>TMultiLayerPerceptron</code></emphasis><code>::SetData()</code>. Events can also be weighted. The weight expression can be given in the constructor or set later with the method <code>SetWeight()</code> of the class <emphasis role="bold"><code>TMultiLayerPerceptron</code></emphasis>. Two datasets must be defined before learning the network: a training dataset that is used when minimizing the error, and a test dataset that will avoid bias. Those two datasets can be build aside and then given to the network, or can be build from a standard expression. By default, half of the events are put in both datasets.</para>

<programlisting language="c++">
<emphasis role="italic"><code>// a more complex 4:8</code></emphasis><emphasis role="italic"><code>:1 network </code></emphasis>
<emphasis role="italic"><code>// the ptsumf branch is used as weigh; default event lists are explicit</code></emphasis>
TMultiLayerPerceptron  network("m,pt,acol,acopl:8:type","pt",tree,
"Entry$%2","Entry$/2");
</programlisting>

<para>The method <emphasis role="bold"><code>TMultiLayerPerceptron</code></emphasis><code>::SetLearningMethod()</code> defines the learning method. Learning methods are:</para>

<programlisting language="c++">
TMultiLayerPerceptron::kStochastic,
TMultiLayerPerceptron::kBatch,
TMultiLayerPerceptron::kSteepestDescent,
TMultiLayerPerceptron::kRibierePolak,
TMultiLayerPerceptron::kFletcherReeves,
TMultiLayerPerceptron::kBFGS      <emphasis role="italic"><code>// default</code></emphasis>
</programlisting>

<para>The training can start with <emphasis role="bold"><code>TMultiLayerPerceptron</code></emphasis><code>::Train(Int_t nepoch,Option_t* options).</code> The first argument is the number of epochs while option is a string that can contain "<code>text</code>" (simple text output), "<code>graph</code>" (evaluating graphical training curves), "<code>update</code> <code>=</code> <code>X</code>" (step for the text/graph output update) or "<code>+</code>" (will skip the randomization and start from the previous values). All combinations are available.</para>

<programlisting language="c++">
network.Train(1000,"text,graph,update=10"); <emphasis role="italic"><code>//full output every 10 epochs</code></emphasis>
network.Train(100,"text,+");                <emphasis role="italic"><code>//100 more epochs </code></emphasis>
<emphasis role="italic"><code> //starts with existing weights</code></emphasis>
</programlisting>

<para>The weights can be saved to a file (<code>DumpWeights</code>) and then reloaded (<code>LoadWeights</code>) to a new compatible network. The output can also be evaluated (<code>Evaluate</code>) for a given output neuron and an array of double input parameters or the network can be exported (<code>Export</code>) as a standalone code. Up to now, this is only as a C++ or PYTHON class, but other languages could be implemented. </para>
</sect2>

<sect2>
<title>Examples</title>
<para>An example of how to use <emphasis role="bold"><code>TMultiLayerPerceptron</code></emphasis> is the macro <code>mlpHiggs.C</code> in $ROOTSYS/tutorials. Using some standard simulated information that could have been obtained at <code>LEP</code>, a neural network is build, which can make the difference between <code>WW</code> events and events containing a Higgs boson. Starting with a <emphasis role="bold"><code>TFile</code></emphasis> containing two <emphasis role="bold"><code>TTree</code></emphasis>s: one for the signal, the other for the background, a simple script is used:</para>

<programlisting language="c++">
void mlpHiggs(Int_t ntrain=100)
{ if (!gROOT-&gt;GetClass("TMultiLayerPerceptron"))
gSystem-&gt;Load("libMLP");
<emphasis role="italic"><code>   // prepare inputs - the 2 trees are merged into one, and a "type"</code></emphasis>
<emphasis role="italic"><code>   // branch, equal to 1 for the signal and 0 for the background is added</code></emphasis>
TFile input("mlpHiggs.root");
TTree *signal = (TTree *)input.Get("sig_filtered");
TTree *background = (TTree *)input.Get("bg_filtered");
TTree *simu = new TTree("MonteCarlo","Filtered Monte Carlo Events");
...
</programlisting>

<para>Since the input is a <emphasis role="bold"><code>TTree</code></emphasis> and we are starting from two different <emphasis role="bold"><code>TTree</code></emphasis>s (with different names), they are first merged into one, and a "<code>type</code>" branch is added, that says whether there is a signal or a background event. Those irrelevant details are skipped here.</para>

<programlisting language="c++">
...
TMultiLayerPerceptron *mlp = new TMultiLayerPerceptron("msumf,ptsumf, acolin,
acopl:8:type","ptsumf",simu,"Entry$%2","Entry$/2");
mlp-&gt;Train(ntrain, "text,graph,update=10");
</programlisting>

<para>The neural network is instantiated and trained. "<code>ptsumf</code>" is used as a weight, and the standard event lists are explicit. The network that is then build has four input neurons, eight additional ones in the only hidden layer and one single output neuron.</para>

<programlisting language="c++">
<emphasis role="italic"><code>   // Use the NN to plot the results for each sample</code></emphasis>
TH1F *bg = new TH1F("bgh","NN output",50,-.5,1.5);
TH1F *sig = new TH1F("sigh","NN output",50,-.5,1.5);
bg-&gt;SetDirectory(0);
sig-&gt;SetDirectory(0);
Double_t params[4];
for (i = 0; i &lt; background-&gt;GetEntries(); i++) {
background-&gt;GetEntry(i);
params[0] = msumf;    params[1] = ptsumf;
params[2] = acolin;   params[3] = acopl;
bg-&gt;Fill(mlp-&gt;Evaluate(0,params));
}
for (i = 0; i &lt; signal-&gt;GetEntries(); i++) {
signal-&gt;GetEntry(i);
params[0] = msumf;
params[1] = ptsumf;
params[2] = acolin;
params[3] = acopl;
sig-&gt;Fill(mlp-&gt;Evaluate(0,params));
}
TCanvas *cv = new TCanvas("NNout_cv","Neural net output");
bg-&gt;SetFillStyle(3008);
bg-&gt;SetFillColor(kBlue);
sig-&gt;SetFillStyle(3003);
sig-&gt;SetFillColor(kRed);
bg-&gt;SetStats(0);
sig-&gt;SetStats(0);
bg-&gt;Draw();
sig-&gt;Draw("same");
TLegend *legend = new TLegend(.75,.80,.95,.95);
legend-&gt;AddEntry(bg,"Background(WW)");
legend-&gt;AddEntry(sig,"Signal(Higgs)");
legend-&gt;Draw();
</programlisting>

<para>The neural net output is then used to display the final difference between background and signal events. The next figure shows this plot. </para>

<figure><title>The neural net output</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/image144.jpg" width="274.95pt" depth="180pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>As it can be seen, this is a quite efficient technique. As mentioned earlier, neural networks are also used for fitting function. For some application with a cylindrical symmetry, a magnetic field simulation gives as output the angular component of the potential vector <code>A</code>, as well as the radial and <code>z</code> components of the <code>B</code> field. </para>
<para>One wants to fit those distributions with a function in order to plug them into the <code>Geant</code> simulation code. Polynomial fits could be tried, but it seems difficult to reach the desired precision over the full range. One could also use a <code>spline</code> interpolation between known points. In all cases, the resulting field would not be <code>C</code>-infinite.</para>
<para>An example of output (for Br) is shown. First the initial function can be seen as the target. Then, the resulting (normalized) neural net output. In order to ease the learning, the "normalize output" was used here. The initial amplitude can be recovered by multiplying by the original RMS and then shifting by the original mean.</para>

<figure><title>The original and the neural net for Br</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/image145.jpg" width="289.25pt" depth="162.6pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect2>
</sect1>
</chapter>



