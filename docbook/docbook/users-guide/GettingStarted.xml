<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0">
<title>Getting Started</title>
<para>We begin by showing you how to use ROOT interactively. There are two examples to click through and learn how to use the GUI. We continue by using the command line, and explaining the coding conventions, global variables and the environment setup. If you have not installed ROOT, you can do so by following the instructions in the appendix, or on the ROOT web site:  <uri xmlns:xlink="http://root.cern.ch/root/Availability.html">http://root.cern.ch/root/Availability.html</uri></para>

<sect1>
<title>Setting the Environment Variables</title>
<para>Before you can run ROOT you need to set the environment variable <code>ROOTSYS</code> and change your path to include <code>root/bin</code> and library path variables to include <code>root/lib</code>. Please note: the syntax is for <code>bash</code>, if you are running <code>tcsh</code> you will have to use <code>setenv</code> instead of <code>export</code>. </para>
<para>1. Define the variable $ROOTSYS to the directory where you unpacked the ROOT:</para>

<programlisting language="c++">
<emphasis role="bold"><code>$ export ROOTSYS=$HOME/root</code></emphasis>
</programlisting>

<para>2. Add ROOTSYS/bin to your PATH: </para>

<programlisting language="c++">
<emphasis role="bold"><code>$ export PATH=$PATH:$ROOTSYS/bin</code></emphasis>
</programlisting>

<para>3. Setting the Library Path</para>
<para>On HP-UX, before executing the interactive module, you must set the library path:</para>

<programlisting language="c++">
<emphasis role="bold"><code>$ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib</code></emphasis>
</programlisting>

<para>On AIX, before executing the interactive module, you must set the library path:</para>

<programlisting language="c++">
<emphasis role="bold"><code>$ [ -z "$LIBPATH" ] &amp;&amp; export LIBPATH=/lib:/usr/lib</code></emphasis>
<emphasis role="bold"><code>$ export LIBPATH=$LIBPATH:$ROOTSYS/lib </code></emphasis>
</programlisting>

<para>On Linux, Solaris, Alpha OSF and SGI, before executing the interactive module, you must set the library path:</para>

<programlisting language="c++">
<emphasis role="bold"><code>$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib</code></emphasis>
</programlisting>

<para>On Solaris, in case your LD_LIBRARY_PATH is empty, you should set it:</para>

<programlisting language="c++">
<emphasis role="bold"><code>$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib</code></emphasis>
</programlisting>

<para>If you use the <code>afs</code> version you should set (<emphasis role="bold-italic">vers</emphasis> = version number, <emphasis role="bold-italic">arch</emphasis> = architecture): </para>

<programlisting language="c++">
<emphasis role="bold"><code>$ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/</code></emphasis>
<emphasis role="italic"><emphasis role="bold"><code>vers</code></emphasis></emphasis>
<emphasis role="bold"><code>/</code></emphasis>
<emphasis role="italic"><emphasis role="bold"><code>arch</code></emphasis></emphasis>
<emphasis role="bold"><code>/root</code></emphasis> 
</programlisting>

<para>If ROOT was installed in <code>$HOME/myroot</code> directory on a local machine, one can do:</para>

<programlisting language="c++">
cd $HOME/myroot
. bin/thisroot.sh       // or source bin/thisroot.sh
</programlisting>

<para>The new <code>$ROOTSYS/bin/thisroot.[c]sh</code> scripts will set correctly the <code>ROOTSYS</code>, <code>LD_LIBRARY_PATH</code> or
other paths depending on the platform and the <code>MANPATH</code>. To run the program just type: <code>root</code>.</para>
</sect1>

<sect1>
<title>Start and Quit a ROOT Session</title>

<programlisting language="c++">
% <emphasis role="bold"><code>root</code></emphasis>
*******************************************
*                                         *
*        W E L C O M E  to  R O O T       *
*                                         *
*   Version   5.20/00      24 June 2007   *
*                                         *
*  You are welcome to visit our Web site  *
*          http://root.cern.ch            *
*                                         *
*******************************************

ROOT 5.20/00 (trunk@24525, Jun 25 2008, 12:52:00 on linux)

CINT/ROOT C/C++ Interpreter version 5.16.29, June 08, 2008
Type ? for help. Commands must be C++ statements.
Enclose multiple statements between { }.
root [0]
</programlisting>

<para>To start ROOT you can type <code>root</code> at the system prompt.  This starts up CINT, the ROOT command line C/C++ interpreter, and it gives you the ROOT prompt
(<code>root[0])</code></para>
<para>It is possible to launch ROOT with some command line options, as shown below:</para>

<programlisting language="c++">
<code>% </code> <emphasis role="bold"><code>root -/?</code></emphasis>
<code>Usage: root [-l] [-b] [-n] [-q] [file1.C ... fileN.C]</code>
<code> Options:</code>
<code>   -b : run in batch mode without graphics</code>
<code>   -n : do not execute logon and logoff macros as</code>
<code>        specified in .rootrc</code>
<code>   -q : exit after processing command line script files</code>
<code>   -l : do not show the image logo (splash screen)</code>
</programlisting>
<itemizedlist>
<listitem><para>–bROOT session runs in batch mode, without graphics display. This mode is useful in case one does not want to set the DISPLAY or cannot do it for some reason.</para></listitem>
<listitem><para>–nusually, launching a ROOT session will execute a logon script and quitting will execute a logoff script. This option prevents the execution of these two scripts.</para></listitem>
<listitem><para>       it is also possible to execute a script without entering a ROOT session. One simply adds the name of the script(s) after the ROOT command. Be warned: after finishing the execution of the script, ROOT will normally enter a new session.</para></listitem>
<listitem><para>–qprocess command line script files and exit.</para></listitem>
</itemizedlist>
<para>For example if you would like to run a script <code>myMacro.C</code> in the background, redirect the output into a file <code>myMacro.log</code>,
and exit after the script execution, use the following syntax:</para>

<programlisting language="c++">
root -b -q myMacro.C &gt; myMacro.log
</programlisting>

<para>If you need to pass a parameter to the script use:</para>

<programlisting language="c++">
root -b -q ’myMacro.C(3)’ &gt; myMacro.log
</programlisting>

<para>Be mindful of the quotes, i.e. if you need to pass a string as a parameter, the syntax is:</para>

<programlisting language="c++">
root -b -q ’myMacro.C("text")’ &gt; myMacro.log
</programlisting>

<para>You can build a shared library with ACLiC and then use this shared library on the command line for a quicker execution (i.e. the compiled speed rather than the interpreted speed). See also “CINT the C++ Interpreter”.</para>

<programlisting language="c++">
root -b -q myMacro.so &gt; myMacro.log
</programlisting>

<para>ROOT has a powerful C/C++ interpreter giving you access to all available ROOT classes, global variables, and functions via the command line. By typing C++ statements at the prompt, you can create objects, call functions, execute scripts, etc. For example:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>1+sqrt(9)</code></emphasis>
(const double)4.00000000000000000e+00
root[] <emphasis role="bold"><code>for (int i = 0; i&lt;4; i++) cout &lt;&lt; "Hello" &lt;&lt; i &lt;&lt; endl</code></emphasis>
Hello 0
Hello 1
Hello 2
Hello 3
root[] <emphasis role="bold"><code>.q</code></emphasis>
</programlisting>

<para>To exit the ROOT session, type <code>.q</code>.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>.q</code></emphasis>
</programlisting>

</sect1>

<sect1>
<title>Using the GUI</title>
<para>The basic whiteboard on which an object is drawn in ROOT is called a canvas (defined by the class <emphasis role="bold"><code>TCanvas</code></emphasis>). Every object in the canvas is a graphical object in the sense that you can grab it, resize it, and change some characteristics using the mouse. The canvas area can be divided in several sub areas, so-called pads (the class <emphasis role="bold"><code>TPad</code></emphasis>). A pad is a canvas sub area that can contain other pads or graphical objects. At any one time, just one pad is the so-called active pad. Any object at the moment of drawing will be drawn in the active pad. The obvious question is: what is the relation between a canvas and a pad? In fact, a canvas is a pad that spans through an entire window. This is nothing else than the notion of inheritance. The <emphasis role="bold"><code>TPad</code></emphasis> class is the parent of the <emphasis role="bold"><code>TCanvas</code></emphasis> class. In ROOT, most objects derive from a base class <emphasis role="bold"><code>TObject</code></emphasis>. This class has a virtual method <code>Draw()</code> such as all objects are supposed to be able to be "drawn". If several canvases are defined, there is only one active at a time. One draws an object in the active canvas by using the statement:</para>

<programlisting language="c++">
object.Draw()
</programlisting>

<para>This instructs the object "<code>object</code>" to draw itself. If no canvas is opened, a default one (named "<code>c1</code>") is created. In the next example, the first statement defines a function and the second one draws it. A default canvas is created since there was no opened one. You should see the picture as shown in the next figure.</para>
<para/>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TF1 f1("func1","sin(x)/x",0,10)</code></emphasis>
root[] <emphasis role="bold"><code>f1.Draw()</code></emphasis>
&lt;TCanvas::MakeDefCanvas&gt;: created default TCanvas with name c1
</programlisting>

<figure><title>A canvas with drawing</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0300000A.png" width="380.5pt" depth="224.05pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>The following components comprise the canvas window:</para>
<itemizedlist>
<listitem><para>Menu bar – contains main menus for global operations with files, print, clear canvas, inspect, etc.</para></listitem>
<listitem><para>Tool bar – has buttons for global and drawing operations; such as arrow, ellipse, latex, pad, etc.</para></listitem>
<listitem><para>Canvas – an area to draw objects.</para></listitem>
<listitem><para>Status bar – displays descriptive messages about the selected object.</para></listitem>
<listitem><para>Editor frame - responds dynamically and presents the user interface according to the selected object in the canvas.</para></listitem>
</itemizedlist>
<sect2>
<title>Main Menus and Toolbar</title>
<para>At the top of the canvas window are File, Edit, View, Options, Inspect, Classes and Help menus.</para>

<sect3>
<title>File Menu</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0300000B.png" width="69.3pt" depth="90.75pt"/></imageobject></inlinemediaobject>
</para>
<itemizedlist>
<listitem><para><emphasis role="italic">New Canvas</emphasis>: creates a new canvas window in the current ROOT session.</para></listitem>
<listitem><para><emphasis role="italic">Open…</emphasis>: popup a dialog to open a file.</para></listitem>
<listitem><para><emphasis role="italic">Close Canvas</emphasis>: close the canvas window.</para></listitem>
<listitem><para><emphasis role="italic">Save</emphasis>: save the drawing of the current canvas in a format selectable from the submenu. The current canvas name is used as a file name for various formats such as PostScript, GIF, JPEG, C macro file, root file.</para></listitem>
<listitem><para><emphasis role="italic">Save As…</emphasis>: popup a dialog for saving the current canvas drawing in a new filename.</para></listitem>
<listitem><para><emphasis role="italic">Print</emphasis>: popup a dialog to print the current canvas drawing</para></listitem>
<listitem><para><emphasis role="italic">Quit ROOT</emphasis>: exit the ROOT session</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Edit Menu</title>
<para>There is only one active menu entry in the Edit menu. The others menu entries will be implemented and will become active in the near future.</para>
<itemizedlist>
<listitem><para><inlinemediaobject><imageobject><imagedata fileref="pictures/0300000C.png" width="66.7pt" depth="99.2pt"/></imageobject></inlinemediaobject><emphasis role="italic">Clear</emphasis><emphasis role="italic">:</emphasis> delete all objects in the canvas or in the selected pad according to the selected entry in the submenu.</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>View Menu</title>
<itemizedlist>
<listitem><para><emphasis role="italic">Editor</emphasis>: toggles the view of the editor. If it is selected activates and shows up the editor on the left side of the canvas window. According to the selected object, the editor loads the corresponding user interface for easy change of the object’s attributes.</para></listitem>
<listitem><para><emphasis role="italic">Toolbar</emphasis>: toggles the view of the toolbar. If it is selected activates and shows up the toolbar. It contains buttons for easy and fast access to most frequently used commands and for graphics primitive drawing. Tool tips are provided for helping users. </para></listitem>
<listitem><para><emphasis role="italic">Status Bar</emphasis>: toggles the view of the status bar. If it is selected, the status bar below the canvas window shows up. There the identification of the objects is displayed when moving the mouse (such as the object’s name, the object’s type, its coordinates, etc.).</para></listitem>
<listitem><para><emphasis role="italic">Colors</emphasis>: creates a new canvas showing the color palette.</para></listitem>
<listitem><para><emphasis role="italic">Markers</emphasis>: creates a new canvas showing the various marker styles.</para></listitem>
<listitem><para><emphasis role="italic">Iconify</emphasis>: create the canvas window icon, does not close the canvas</para></listitem>
<listitem><para><emphasis role="italic">View With...</emphasis>: If the last selected pad contains a 3-d structure, a new canvas is created with a 3-D picture according to the selection made from the cascaded menu: X3D or OpenGL. The 3-D image can be interactively rotated, zoomed in wire-frame, solid, hidden line or stereo mode.</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Options Menu</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0300000D.png" width="96.75pt" depth="138.4pt"/></imageobject></inlinemediaobject>
</para>
<itemizedlist>
<listitem><para><emphasis role="italic">Auto Resize Canvas</emphasis>:  turns auto-resize of the canvas on/off:</para></listitem>
<listitem><para>ON – the canvas fits to the window when changing the window size; </para></listitem>
<listitem><para>OFF – the canvas stays fixed when changing the window size.</para></listitem>
<listitem><para><emphasis role="italic">Resize Canvas</emphasis>: resizes and fits the canvas to the window size.</para></listitem>
<listitem><para><emphasis role="italic">Move Opaque</emphasis>: if selected, graphics objects are moved in opaque mode; otherwise, only the outline of objects is drawn when moving them. The option opaque produces the best effect but it requires a reasonably fast workstation or response time.</para></listitem>
<listitem><para><emphasis role="italic">Resize Opaque</emphasis>: if selected, graphics objects are resized in opaque mode; otherwise, only the outline of objects is drawn when resizing them.</para></listitem>
<listitem><para><emphasis role="italic">Interrupt</emphasis>: interrupts the current drawing process.</para></listitem>
<listitem><para><emphasis role="italic">Refresh</emphasis>: redraws the canvas contents.</para></listitem>
<listitem><para><emphasis role="italic">Pad Auto Exec</emphasis>: executes the list of <emphasis role="bold"><code>TExecs</code></emphasis> in the current pad.</para></listitem>
<listitem><para><emphasis role="italic">Statistics</emphasis>: toggles the display of the histogram statistics box.</para></listitem>
<listitem><para><emphasis role="italic">Histogram Title</emphasis>: toggles the display of the histogram title.</para></listitem>
<listitem><para><emphasis role="italic">Fit Parameters</emphasis>: toggles the display of the histogram or graph fit parameters.</para></listitem>
<listitem><para><emphasis role="italic">Can Edit Histogram</emphasis>: enables/disables the possibility to edit histogram bin contents.</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Inspect Menu</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0300000E.png" width="77.85pt" depth="40.5pt"/></imageobject></inlinemediaobject>
</para>
<itemizedlist>
<listitem><para><emphasis role="italic">ROOT</emphasis>: inspects the top-level <emphasis role="italic"><emphasis role="bold"><code>gROOT</code></emphasis></emphasis> object (in a new canvas).</para></listitem>
<listitem><para><emphasis role="italic">Start Browser</emphasis>: starts a new object browser (in a separate window).</para></listitem>
<listitem><para><emphasis role="italic">GUI Builder</emphasis>: starts the GUI builder application (in a separate window).</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Classes Menu</title>
<itemizedlist>
<listitem><para><emphasis role="italic">Classes</emphasis>: starts the ClassTree viewer that draws inheritance tree for a list of classes.</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Help Menu</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0300000F.png" width="88.1pt" depth="110.5pt"/></imageobject></inlinemediaobject>
</para>
<itemizedlist>
<listitem><para><emphasis role="italic">Canvas</emphasis><emphasis role="italic">: </emphasis> help on canvas as a whiteboard area for drawing.</para></listitem>
<listitem><para><emphasis role="italic">Menus</emphasis>: help on canvas menus.</para></listitem>
<listitem><para><emphasis role="italic">Graphics Editor</emphasis>: help on primitives’ drawing and objects’ editor.</para></listitem>
<listitem><para><emphasis role="italic">Browser</emphasis>: help on the ROOT objects’ and files’ browser.</para></listitem>
<listitem><para><emphasis role="italic">Objects</emphasis>: help on DrawClass, Inspect and Dump context menu items.</para></listitem>
<listitem><para><emphasis role="italic">PostScript</emphasis>: help on how to print a canvas to a PostScript file format.</para></listitem>
<listitem><para><emphasis role="italic">About ROOT</emphasis>: pops up the ROOT Logo with the version number.</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Toolbar</title>
<para>The following menu shortcuts and utilities are available from the toolbar: </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000010.png" width="16.15pt" depth="14.9pt"/></imageobject></inlinemediaobject>  Create a new canvas window.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000011.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject>  Popup the Open File dialog.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000012.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject>  Popup the Save As… dialog.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000013.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject>  Popup the Print dialog.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000014.png" width="14.9pt" depth="13.65pt"/></imageobject></inlinemediaobject>  Interrupts the current drawing process.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000015.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject>  Redraw the canvas.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000016.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject>  Inspect the <emphasis role="italic"><emphasis role="bold"><code>gROOT</code></emphasis></emphasis> object.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000017.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject>  Create a new objects’ browser.</para>
<para>You can create the following graphical objects using the toolbar buttons for primitive drawing. Tool tips are provided for helping your choice.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000018.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> An Arc or circle</emphasis>: Click on the center of the arc, and then move the mouse. A rubber band circle is shown. Click again with the left button to freeze the arc. </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000019.png" width="14.3pt" depth="14.3pt"/></imageobject></inlinemediaobject> <emphasis role="bold">A Line</emphasis>: Click with the left button at the point where you want to start the line, then move the mouse and click again with the left button to freeze the line. </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/0300001A.png" width="14.3pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> An Arrow: </emphasis>Click with the left button at the point where you want to start the arrow, then move the mouse and click again with the left button to freeze the arrow.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/0300001B.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> A Diamond</emphasis>: Click with the left button and freeze again with the left button. The editor draws a rubber band box to suggest the outline of the diamond. </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/0300001C.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> An Ellipse</emphasis>: Proceed like for an arc. You can grow/shrink the ellipse by pointing to the sensitive points. They are highlighted. You can move the ellipse by clicking on the ellipse, but not on the sensitive points. If, with the ellipse context menu, you have selected a fill area color, you can move a filled-ellipse by pointing inside the ellipse and dragging it to its new position. </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/0300001D.png" width="14.3pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> A Pad</emphasis>: Click with the left button and freeze again with the left button. The editor draws a rubber band box to suggest the outline of the pad. </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/0300001E.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> A PaveLabel</emphasis>: Proceed like for a pad. Type the text of label and finish with a carriage return. The text will appear in the box. </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/0300001F.png" width="14.3pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> A Pave Text</emphasis>: Proceed like for a pad. You can then click on the <emphasis role="bold"><code>TPaveText</code></emphasis> object with the right mouse button and select the option <code>InsertText</code>.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000020.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> Paves Text</emphasis>: Proceed like for a <emphasis role="bold"><code>TPaveText</code></emphasis>. </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000021.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> A Poly Line</emphasis>: Click with the left button for the first point, move the moose, click again with the left button for a new point. Close the poly-line with a double click. To edit one vertex point, pick it with the left button and drag to the new point position. </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000022.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> A Curly Line</emphasis>: Proceed as for the arrow or line. Once done, click with the third button to change the characteristics of the curly line, like transform it to wave, change the wavelength, etc.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000023.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> A Curly Arc</emphasis>: Proceed like for an ellipse. The first click is located at the position of the center, the second click at the position of the arc beginning. Once done, one obtains a curly ellipse, for which one can click with the third button to change the characteristics, like transform it to wavy, change the wavelength, set the minimum and maximum angle to make an arc that is not closed, etc.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000024.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> A Text/Latex string</emphasis>: Click with the left button where you want to draw the text and then type in the text terminated by carriage return. All <emphasis role="bold"><code>TLatex</code></emphasis> expressions are valid. To move the text or formula, point on it keeping the left mouse button pressed and drag the text to its new position. You can grow/shrink the text if you position the mouse to the first top-third part of the string, then move the mouse up or down to grow or shrink the text respectively. If you position the mouse near the bottom-end of the text, you can rotate it. </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000025.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> A Marker</emphasis>: Click with the left button where to place the marker. The marker can be modified by using the method <code>SetMarkerStyle()</code> of <emphasis role="bold"><code>TSystem</code></emphasis>.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/03000026.png" width="14.9pt" depth="14.3pt"/></imageobject></inlinemediaobject><emphasis role="bold"> A Graphical Cut</emphasis>: Click with the left button on each point of a polygon delimiting the selected area. Close the cut by double clicking on the last point. A <emphasis role="bold"><code>TCutG</code></emphasis> object is created. It can be used as a selection for a <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code>. You can get a pointer to this object with: </para>

<programlisting language="c++">
<code>TCutG cut = (TCutG*)gPad-&gt;GetPrimitive("CUTG")</code>
</programlisting>

<para>Once you are happy with your picture, you can select the <code>Save as canvas.C</code> item in the canvas File menu. This will automatically generate a script with the C++ statements corresponding to the picture. This facility also works if you have other objects not drawn with the graphics editor (histograms for example).</para>
</sect3>
</sect2>

<sect2>
<title>The Editor Frame</title>
<para>The ROOT graphics editor loads the corresponding object editor <code>objEditor</code> according to the selected object <code>obj</code> in the canvas respecting the class inheritance. An object in the canvas is selected after the left mouse click on it. For example, if the selected object is <emphasis role="bold"><code>TAxis</code></emphasis>, the <emphasis role="bold"><code>TAxisEditor</code></emphasis> will shows up in the editor frame giving the possibility for changing different axis attributes. The graphics editor can be:</para>
<para>Embedded – connected only with the canvas in the application window that appears on the left of the canvas window after been activated via View menu / Editor. It appears on the left side if the canvas window allowing users to edit the attributes of the selected object via provided user interface.  The name of the selected object is displayed on the top of the editor frame in red color. If the user interface needs more space then the height of the canvas window, a vertical scroll bar appears for easer navigation.</para>
<para> <inlinemediaobject><imageobject><imagedata fileref="pictures/03000027.png" width="338.3pt" depth="234.15pt"/></imageobject></inlinemediaobject></para>
<para>Global – has own application window and can be connected to any created canvas in a ROOT session. It can be activated via the context menu entries for setting line, fill, text and marker attributes for backward compatibility, but there will be a unique entry in the near future.</para>
<para> <inlinemediaobject><imageobject><imagedata fileref="pictures/03000028.png" width="73.75pt" depth="187.45pt"/></imageobject></inlinemediaobject>   <inlinemediaobject><imageobject><imagedata fileref="pictures/03000029.png" width="257.05pt" depth="187pt"/></imageobject></inlinemediaobject></para>
<para>The user interface for the following classes is available since ROOT v.4.04: <emphasis role="bold"><code>TAttLine</code></emphasis>, <emphasis role="bold"><code>TAttFill</code></emphasis>, <emphasis role="bold"><code>TAttMarker</code></emphasis>, <emphasis role="bold"><code>TAttText</code></emphasis>, <emphasis role="bold"><code>TArrow</code></emphasis>, <emphasis role="bold"><code>TAxis</code></emphasis>, <emphasis role="bold"><code>TCurlyArc</code></emphasis>, <emphasis role="bold"><code>TCurlyLine</code></emphasis>, <emphasis role="bold"><code>TFrame</code></emphasis>, <emphasis role="bold"><code>TH1</code></emphasis>, <emphasis role="bold"><code>TH2</code></emphasis>, <emphasis role="bold"><code>TGraph</code></emphasis>, <emphasis role="bold"><code>TPad</code></emphasis>, <emphasis role="bold"><code>TCanvas</code></emphasis>, <emphasis role="bold"><code>TPaveStats</code></emphasis>. For more details, see “The Graphics Editor”, “The User Interface for Histograms”, “The User Interface for Graphs”.</para>
</sect2>

<sect2>
<title>Classes, Methods and Constructors</title>
<para>Object oriented programming introduces objects, which have data members and methods. The next line creates an object named
<code>f1</code> of the class <emphasis role="bold"><code>TF1</code></emphasis> that is a one-dimensional function. The type of an object is called a class. The object itself is called an instance of a class. When a method builds an object, it is called a constructor. </para>

<programlisting language="c++">
TF1 f1("func1","sin(x)/x",0,10)
</programlisting>

<para>In our constructor the function sin(x)/x is defined for use, and 0 and 10 are the limits. The first parameter, <code>func1</code> is
the name of the object <code>f1</code>. Most objects in ROOT have a name. ROOT maintains a list of objects that can be searched to find any object
by its given name (in our example <code>func1</code>).</para>
<para>The syntax to call an object's method, or if one prefers, to make an object to do something is:</para>

<programlisting language="c++">
object.method_name(parameters)
</programlisting>

<para>The dot can be replaced by “<code>-&gt;</code>" if <code>object</code> is a pointer. In compiled code, the dot MUST be replaced by a "<code>-&gt;</code>" if object is a pointer.</para>

<programlisting language="c++">
object_ptr-&gt;method_name(parameters)
</programlisting>

<para>So now, we understand the two lines of code that allowed us to draw our function. <code>f1.Draw()</code> stands for “call the method <code>Draw()</code>
associated with the object <code>f1</code> of the class <emphasis role="bold"><code>TF1</code></emphasis>”. Other methods can be applied to the object <code>f1</code>
of the class <emphasis role="bold"><code>TF1</code></emphasis>. For example, the evaluating and calculating the derivative and the integral are what one would expect from a function.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>f1.Eval(3)</code></emphasis>
(Double_t)4.70400026866224020e-02
root[] <emphasis role="bold"><code>f1.Derivative(3)</code></emphasis>
(Double_t)(-3.45675056671992330e-01)
root[] <emphasis role="bold"><code>f1.Integral(0,3)</code></emphasis>
(Double_t)1.84865252799946810e+00
root[] <emphasis role="bold"><code>f1.Draw()</code></emphasis>
</programlisting>

<para>By default the method <emphasis role="bold"><code>TF1</code></emphasis><code>::Paint()</code>, that draws the function, computes 100 equidistant
points to draw it. The number of points can be set to a higher value with:</para>

<programlisting language="c++">
<code>root[] </code><emphasis role="bold"><code>f1.SetNpx(2000);</code></emphasis>
</programlisting>

<para>Note that while the ROOT framework is an object-oriented framework, this does not prevent the user from calling plain functions. </para>
</sect2>

<sect2>
<title>User Interaction</title>
<para>Now we will look at some interactive capabilities. Try to draw the function <code>sin(x)/x</code> again. Every object in a window (which is called a canvas) is, in fact, a graphical object in the sense that you can grab it, resize it, and change its characteristics with a mouse click. For example, bring the cursor over the x-axis. The cursor changes to a hand with a pointing finger when it is over the axis. Now, left click and drag the mouse along the axis to the right. You have a very simple zoom.</para>
<para>When you move the mouse over any object, you can get access to selected methods by pressing the right mouse button and obtaining a context menu. If you try this on the function <emphasis role="bold"><code>TF1</code></emphasis>, you will get a menu showing available methods. The other objects on this canvas are the title, a <emphasis role="bold"><code>TPaveText</code></emphasis> object<code>;</code> the x and y-axis, <emphasis role="bold"><code>TAxis</code></emphasis> objects, the frame, a <emphasis role="bold"><code>TFrame</code></emphasis> object, and the canvas a <emphasis role="bold"><code>TCanvas </code></emphasis>object. Try clicking on these and observe the context menu with their methods.</para>

<figure><title>A context menu</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0300002A.png" width="263.15pt" depth="202.35pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>For example try selecting the <code>SetRange()</code> method and putting <code>-10</code>, <code>10</code> in the dialog box fields. This is equivalent to executing <code>f1.SetRange(-10,10)</code> from the command line, followed by <code>f1.Draw()</code>. Here are some other options you can try. </para>
<para>Once the picture suits your wishes, you may want to see the code you should put in a script to obtain the same result. To do that, choose Save / <code>canvas.C</code> entry of the File menu. This will generate a script showing the options set in the current canvas. Notice that you can also save the picture into various file formats such as PostScript, GIF, etc. Another interesting possibility is to save your canvas into the native ROOT format (<code>.root </code>file). This will enable you to open it again and to change whatever you like. All objects associated to the canvas (histograms, graphs) are saved at the same time.</para>
</sect2>

<sect2>
<title>Building a Multi-pad Canvas</title>
<para>Let us now try to build a canvas with several pads. </para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TCanvas *MyC = new TCanvas("MyC","Test canvas",1)</code></emphasis>
root[] <emphasis role="bold"><code>MyC-&gt;Divide(2,2)</code></emphasis>
</programlisting>

<para>Once again, we call the constructor of a class, this time the class <emphasis role="bold"><code>TCanvas</code></emphasis>.
The difference between this and the previous constructor call (<emphasis role="bold"><code>TF1</code></emphasis>) is that here we are
creating a pointer to an object. Next, we call the method <code>Divide()</code> of the <emphasis role="bold"><code>TCanvas</code></emphasis> class
(that is <emphasis role="bold"><code>TCanvas</code></emphasis><code>::Divide())</code>, which divides the canvas into four zones and sets up a
pad in each of them. We set the first pad as the active one and than draw the function<code> f1 </code>there.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>MyC-&gt;cd(1)</code></emphasis>
root[] <emphasis role="bold"><code>f1-&gt;Draw()</code></emphasis>
</programlisting>

<para>All objects will be drawn in that pad because it is the active one. The ways for changing the active pad are:</para>
<itemizedlist>
<listitem><para>Click the middle mouse button on a pad will set this pad as the active one.</para></listitem>
<listitem><para>Use the method <emphasis role="bold"><code>TCanvas</code></emphasis><code>::cd()</code> with the pad number, as was done in the example above:</para></listitem>
</itemizedlist>
<programlisting language="c++">
root[] <emphasis role="bold"><code>MyC-&gt;cd(3)</code></emphasis>
</programlisting>

<para>Pads are numbered from left to right and from top to bottom. Each new pad created by <emphasis role="bold"><code>TCanvas</code></emphasis><code>::Divide()</code>
has a name, which is the name of the canvas followed by _1, _2, etc. To apply the method <code>cd()</code> to the third pad, you would write:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>MyC_3-&gt;cd()</code></emphasis>
</programlisting>
<itemizedlist>
<listitem><para>Third pad will be selected since you called <emphasis role="bold"><code>TPad</code></emphasis><code>::cd()</code> for  the object <code>MyC_3</code>. ROOT will find the pad that was named<code> MyC_3 </code>when you typed it on the command line (see ROOT/CINT Extensions to C++). </para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>Saving the Canvas</title>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/0300002B.png" width="98pt" depth="92.8pt"/></imageobject></inlinemediaobject></para>
<para>Using the File menu / Save cascade menu users can save the canvas as one of the files from the list. Please note that saving the canvas this way will overwrite the file with the same name without a warning. </para>
<para>All supported file types can be saved via File menu / SaveAs… This dialog gives a choice to show or suppress the confirmation message for overwriting an existing file. </para>

<figure><title>The SaveAs... dialog</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0300002C.png" width="235.25pt" depth="140.3pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>If the Ovewrite check box is not selected, a message dialog appears asking the user to overwrite the file (Yes/No). The user choice is saved for the next time the Save As… dialog shows up.</para>
</sect2>

<sect2>
<title>Printing the Canvas</title>
<para>The Print command in the canvas File menu pops-up a print dialog where the user can specify a preferred print command and the printer name.</para>
<para> <inlinemediaobject><imageobject><imagedata fileref="pictures/0300002D.png" width="196.15pt" depth="51.5pt"/></imageobject></inlinemediaobject></para>
<para>Both print parameters can be set via the new Print.Command and Print.Printer rootrc resources as follows:</para>

<programlisting language="c++">
# Printer settings.
WinNT.*.Print.Command:    AcroRd32.exe
Unix.*.Print.Command:     xprint -P%p %f
Print.Printer:            32-rb205-hp
Print.Directory:          .
</programlisting>

<para>If the <code>%p</code> and <code>%f</code> are specified as a part of the print command, they will be replaced by the specified printer name and the file name. All other parameters will be kept as they are written. A print button is available in the canvas toolbar (activated via View menu/Toolbar).</para>
</sect2>
</sect1>

<sect1>
<title>The ROOT Command Line</title>
<para>We have briefly touched on how to use the command line. There are different types of commands.</para>
<para>1. CINT commands start with “<code>.</code>”</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>.?</code></emphasis>                   <emphasis role="italic"><code>//this command will list all the CINT commands</code></emphasis><emphasis>         </emphasis>
root[] .<emphasis role="bold"><code>L &lt;filename&gt;</code></emphasis>   <emphasis role="italic"><code>//load [filename]</code></emphasis>
root[] <emphasis role="bold"><code>.x &lt;filename&gt; </code></emphasis>           <emphasis role="italic"><code>//load and execute [filename]</code></emphasis>
</programlisting>

<para>2. SHELL commands start with “<code>.!</code>” for example:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>.! ls</code></emphasis>
</programlisting>

<para>3. C++ commands follow C++ syntax (almost)</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TBrowser</code></emphasis><emphasis role="bold"><code> *b = new TBrowser()</code></emphasis>
</programlisting>

<sect2>
<title>Multi-line Commands</title>
<para>You can use the command line to execute multi-line commands. To begin a multi-line command you must type a single left curly bracket <code>{</code>, and to end it you must type a single right curly
bracket <code>}</code>. For example:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>{</code></emphasis>
end with '}'&gt; <emphasis role="bold"><code>Int_t j = 0;</code></emphasis>
end with '}'&gt; <emphasis role="bold"><code>for (Int_t i = 0; i &lt; 3; i++)</code></emphasis>
end with '}'&gt; <emphasis role="bold"><code>{</code></emphasis>
end with '}'&gt; <emphasis role="bold"><code>j= j + i;</code></emphasis>
end with '}'&gt; <emphasis role="bold"><code>cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; ", j = " &lt;&lt; j &lt;&lt; endl;</code></emphasis>
end with '}'&gt;<emphasis role="bold"><code> }</code></emphasis>
end with '}'&gt;<emphasis role="bold"><code> }</code></emphasis>
i = 0, j = 0
i = 1, j = 1
i = 2, j = 3
</programlisting>

<para>It is more convenient to edit a script than the command line, and if your multi line commands are getting unmanageable, you may want to start with a script instead.</para>
</sect2>

<sect2>
<title>CINT Extensions</title>
<para>We should say that some things are not standard C++. The CINT interpreter has several extensions. See “ROOT/CINT Extensions to C++”.</para>
</sect2>

<sect2>
<title>Helpful Hints for Command Line Typing</title>
<para>The interpreter knows all the classes, functions, variables, and user defined types. This enables ROOT to help users to complete the command line. For example, if we do not know anything about the <emphasis role="bold"><code>TLine</code></emphasis> class, the Tab feature helps us to get a list of all classes starting with <emphasis role="bold"><code>TL</code></emphasis>(where <code>&lt;TAB&gt;</code> means type the Tab key).</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>l = new TLi&lt;TAB&gt;</code></emphasis>
TList
TListIter
TLink
TLine
TLimitDataSource
TLimit
</programlisting>

<para>To list the different constructors and parameters for <emphasis role="bold"><code>TLine</code></emphasis> use the <code>&lt;TAB&gt;</code> key as follows: </para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>l = new TLine(&lt;TAB&gt;</code></emphasis>
TLine TLine()
TLine TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2)
TLine TLine(const TLine&amp; line)
</programlisting>

</sect2>

<sect2>
<title>Regular Expression</title>
<para>The meta-characters below can be used in a regular expression:</para>
<itemizedlist>
<listitem><para>'<code>^</code>' start-of-line anchor</para></listitem>
<listitem><para>'<code>$</code>' end-of-line anchor </para></listitem>
<listitem><para>'<code>.</code>' matches any character </para></listitem>
<listitem><para>'<code>[</code>' start a character class </para></listitem>
<listitem><para>'<code>]</code>’end a character class </para></listitem>
<listitem><para>'<code>^</code>’negates character class if first character </para></listitem>
<listitem><para>'<code>*</code>’<code>Kleene</code> closure (matches 0 or more) </para></listitem>
<listitem><para>'<code>+</code>’Positive closure (1 or more) </para></listitem>
<listitem><para>'<code>?</code>’    Optional closure (0 or 1)</para></listitem>
</itemizedlist>
<para>When using wildcards the regular expression is assumed to be preceded by a '<code>^</code>' (BOL) and terminated by '<code>$</code>' (EOL). All '<code>*</code>' (closures) are assumed to be preceded by a '<code>.</code>', i.e. any character, except slash _<code>/_</code>. Its special treatment allows the easy matching of pathnames. For example, <code>_*.root_</code> will match <code>_aap.root_</code>, but not <code>_pipo/aap.root_</code>.</para>
<para>The escape characters are:</para>
<itemizedlist>
<listitem><para> <code>\</code>backslash</para></listitem>
<listitem><para> <code>b</code>backspace </para></listitem>
<listitem><para> <code>f</code>form feed </para></listitem>
<listitem><para> <code>n</code>new line </para></listitem>
<listitem><para> <code>r</code>carriage return </para></listitem>
<listitem><para> <code>s</code>space </para></listitem>
<listitem><para> <code>t</code>tab </para></listitem>
<listitem><para> <code>e</code>ASCII ESC character ('033') </para></listitem>
<listitem><para> <code>DDD</code>number formed of 1-3 octal digits </para></listitem>
<listitem><para> <code>xDD</code>number formed of 1-2 hex digits </para></listitem>
<listitem><para> <code>^C</code>C = any letter. Control code</para></listitem>
</itemizedlist>
<para>The class <emphasis role="bold"><code>TRegexp</code></emphasis> can be used to create a regular expression from an input string. If <code>wildcard</code> is true then the input string contains a wildcard expression.</para>

<programlisting language="c++">
TRegexp(const char *re, Bool_t wildcard)
</programlisting>

<para>Regular expression and wildcards can be easily used in methods like:    </para>

<programlisting language="c++">
Ssiz_t Index(const TString&amp; string,Ssiz_t* len,Ssiz_t i) const
</programlisting>

<para>The method finds the first occurrence of the regular expression in the <code>string</code> and returns its position.</para>
</sect2>
</sect1>

<sect1>
<title>Conventions</title>
<para>In this paragraph, we will explain some of the conventions used in ROOT source and examples.</para>

<sect2>
<title>Coding Conventions</title>
<para>From the first days of ROOT development, it was decided to use a set of coding conventions. This allows a consistency throughout the source code. Learning these will help you identify what type of information you are dealing with and enable you to understand the code better and quicker. Of course, you can use whatever convention you want but if you are going to submit some code for inclusion into the ROOT sources, you will need to use these. </para>
<para>These are the coding conventions: </para>
<itemizedlist>
<listitem><para>Classes begin with <emphasis role="bold"><code>T</code></emphasis>: <emphasis role="bold"><code>TLine</code></emphasis><code>, </code><emphasis role="bold"><code>TTree</code></emphasis></para></listitem>
<listitem><para>Non-class types end with <emphasis role="bold"><code>_t</code></emphasis>: <code>Int_t</code> </para></listitem>
<listitem><para>Data members begin with<emphasis role="bold"><code> f</code></emphasis>: <code>fTree </code></para></listitem>
<listitem><para>Member functions begin with a capital: <code>Loop()</code> </para></listitem>
<listitem><para>Constants begin with <emphasis role="bold"><code>k</code></emphasis>: <code>kInitialSize</code>, <code>kRed </code></para></listitem>
<listitem><para>Global variables begin with<emphasis role="bold"><code> g</code></emphasis>: <emphasis role="italic"><emphasis role="bold"><code>gEnv</code></emphasis></emphasis></para></listitem>
<listitem><para>Static data members begin with<emphasis role="bold"><code> fg</code></emphasis>: <code>fgTokenClient </code></para></listitem>
<listitem><para>Enumeration types begin with <emphasis role="bold"><code>E</code></emphasis>:<code>EColorLevel</code> </para></listitem>
<listitem><para>Locals and parameters begin with a lower case:  <code>nbytes</code> </para></listitem>
<listitem><para>Getters and setters begin with <emphasis role="bold"><code>Get</code></emphasis> and <emphasis role="bold"><code>Set</code></emphasis>:<code>SetLast</code>(), <code>GetFirst</code>()</para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>Machine Independent Types</title>
<para>Different machines may have different lengths for the same type. The most famous example is the <code>int</code> type. It may be 16 bits on some old machines and 32 bits on some newer ones. To ensure the size of your variables, use these pre defined types in ROOT:</para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>Char_t</code></emphasis> Signed Character 1 byte</para></listitem>
<listitem><para><emphasis role="bold"><code>UC</code></emphasis><emphasis role="bold"><code>har_t</code></emphasis> Unsigned Character 1 byte</para></listitem>
<listitem><para><emphasis role="bold"><code>Short_t</code></emphasis> Signed Short integer 2 bytes</para></listitem>
<listitem><para><emphasis role="bold"><code>UShort_t</code></emphasis> Unsigned Short integer 2 bytes</para></listitem>
<listitem><para><emphasis role="bold"><code>Int_t</code></emphasis>          Signed integer 4 bytes</para></listitem>
<listitem><para><emphasis role="bold"><code>UInt_t </code></emphasis>Unsigned integer 4 bytes</para></listitem>
<listitem><para><emphasis role="bold"><code>Long64_t</code></emphasis> Portable signed long integer 8 bytes</para></listitem>
<listitem><para>    <emphasis role="bold"><code>ULong64_t </code></emphasis>    Portable unsigned long integer 8 bytes</para></listitem>
<listitem><para><emphasis role="bold"><code>Float_t</code></emphasis>         Float 4 bytes</para></listitem>
<listitem><para><emphasis role="bold"><code>Double_t </code></emphasis>Float 8 bytes</para></listitem>
<listitem><para><emphasis role="bold"><code>Double32_t</code></emphasis> Double 8 bytes in memory, written as a Float 4 bytes</para></listitem>
<listitem><para><emphasis role="bold"><code>Bool_t </code></emphasis> Boolean (0=false, 1=true)</para></listitem>
</itemizedlist>
<para>If you do not want to save a variable on disk, you can use <code>int</code> or <code>Int_t</code>, the result will be the same and the interpreter or the compiler will treat them in exactly the same way.</para>
</sect2>

<sect2>
<title>TObject</title>
<para>In ROOT, almost all classes inherit from a common base class called <emphasis role="bold"><code>TObject</code></emphasis>. This kind of architecture is also used in the Java language. The <emphasis role="bold"><code>TObject</code></emphasis> class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See "The Role of TObject".</para>
<para><emphasis role="bold"><code>TObject</code></emphasis> provides protocol, i.e. (abstract) member functions, for:</para>
<itemizedlist>
<listitem><para>Object I/O (<code>Read()</code>, <code>Write())</code></para></listitem>
<listitem><para>Error handling (<code>Warning()</code>, <code>Error()</code>, <code>SysError()</code>, <code>Fatal())</code></para></listitem>
<listitem><para>Sorting (<code>IsSortable()</code>, <code>Compare()</code>, <code>IsEqual()</code>, <code>Hash())</code></para></listitem>
<listitem><para>Inspection (<code>Dump()</code>, <code>Inspect()</code>)</para></listitem>
<listitem><para>Printing (<code>Print())</code></para></listitem>
<listitem><para>Drawing (<code>Draw()</code>, <code>Paint()</code>, <code>ExecuteEvent())</code></para></listitem>
<listitem><para>Bit handling (<code>SetBit()</code>, <code>TestBit()</code>)</para></listitem>
<listitem><para>Memory allocation (operator<code> new and delete</code>, <code>IsOnHeap())</code></para></listitem>
<listitem><para>Access to meta information (<code>IsA()</code>, <code>InheritsFrom())</code></para></listitem>
<listitem><para>Object browsing (<code>Browse()</code>, <code>IsFolder())</code></para></listitem>
</itemizedlist>
</sect2>
</sect1>

<sect1>
<title>Global Variables</title>
<para>ROOT has a set of global variables that apply to the session. For example, <emphasis role="italic"><emphasis role="bold"><code>gDirectory</code></emphasis></emphasis> always holds the current directory, and <emphasis role="italic"><emphasis role="bold"><code>gStyle</code></emphasis></emphasis> holds the current style. All global variables begin with “<emphasis role="italic">g</emphasis>” followed by a capital letter.</para>

<sect2>
<title>gROOT</title>
<para>The single instance of <emphasis role="bold"><code>TROOT</code></emphasis> is accessible via the global <emphasis role="italic"><emphasis role="bold"><code>gROOT</code></emphasis></emphasis> and holds information relative to the current session. By using the <emphasis role="italic"><emphasis role="bold"><code>gROOT</code></emphasis></emphasis> pointer, you get the access to every object created in a ROOT program. The <emphasis role="bold"><code>TROOT</code></emphasis> object has several lists pointing to the main ROOT objects. During a ROOT session, the <emphasis role="italic"><emphasis role="bold"><code>gROOT</code></emphasis></emphasis> keeps a series of collections to manage objects. They can be accessed via <emphasis role="italic"><emphasis role="bold"><code>gROOT</code></emphasis></emphasis><code>::GetListOf…</code>         methods.</para>

<programlisting language="c++">
<code>gROOT-&gt;GetListOfClasses()</code>
<code>gROOT-&gt;GetListOfColors()</code>
<code>gROOT-&gt;GetListOfTypes()</code>
<code>gROOT-&gt;GetListOfGlobals()</code>
<code>gROOT-&gt;GetListOfGlobalFunctions()</code>
<code>gROOT-&gt;GetListOfFiles()</code>
<code>gROOT-&gt;GetListOfMappedFiles()</code>
<code>gROOT-&gt;GetListOfSockets()</code>
<code>gROOT-&gt;GetListOfCanvases()</code>
<code>gROOT-&gt;GetListOfStyles()</code>
<code>gROOT-&gt;GetListOfFunctions()</code>
<code>gROOT-&gt;GetListOfSpecials() </code>
<code>gROOT-&gt;GetListOfGeometries()</code>
<code>gROOT-&gt;GetListOfBrowsers()</code>
<code>gROOT-&gt;GetListOfMessageHandlers()</code>
</programlisting>

<para>These methods return a <emphasis role="bold"><code>TSeqCollection</code></emphasis>, meaning a collection of objects, and they can be used to do list operations such as finding an object, or traversing the list and calling a method for each of the members. See the <emphasis role="bold"><code>TCollection</code></emphasis>         class description for the full set of methods supported for a collection. For example, to find a canvas called <code>c1 </code>you can do<code>:</code></para>

<programlisting language="c++">
<code>root[]</code><emphasis role="bold"><code>gROOT-&gt;GetListOfCanvases()-&gt;FindObject("c1")</code></emphasis>
</programlisting>

<para>This returns a pointer to a <emphasis role="bold"><code>TObject</code></emphasis>, and before you can use it as a canvas you need to cast it to a <emphasis role="bold"><code>TCanvas</code></emphasis><code>*</code>.</para>
</sect2>

<sect2>
<title>gFile</title>
<para><emphasis role="italic"><emphasis role="bold"><code>gFile</code></emphasis></emphasis> is the pointer to the current opened file in the ROOT session.</para>
</sect2>

<sect2>
<title>gDirectory</title>
<para><emphasis role="italic"><emphasis role="bold"><code>gDirectory</code></emphasis></emphasis> is a pointer to the current directory. The concept and role of a directory is explained in the chapter “Input/Output”. </para>
</sect2>

<sect2>
<title>gPad</title>
<para>A graphic object is always drawn on the active pad. It is convenient to access the active pad, no matter what it is. For that, we have <emphasis role="italic"><emphasis role="bold"><code>gPad</code></emphasis></emphasis> that is always pointing to the active pad. For example, if you want to change the fill color of the active pad to blue, but you do not know its name, you can use <emphasis role="italic"><emphasis role="bold"><code>gPad</code></emphasis></emphasis>.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>gPad-&gt;SetFillColor(38)</code></emphasis>
</programlisting>

<para>To get the list of colors, if you have an open canvas, click in the "View" menu, selecting the "Colors" entry. </para>
</sect2>

<sect2>
<title>gRandom</title>
<para><emphasis role="italic"><emphasis role="bold"><code>gRandom</code></emphasis></emphasis>         is a pointer to the current random number generator. By default, it points to a <emphasis role="bold"><code>TRandom</code></emphasis><emphasis role="bold"><code>3</code></emphasis> object, based on the "Mersenne-Twister" generator. This generator is very fast and has very good random proprieties (a very long period of 10600). Setting the seed to 0 implies that the seed will be uniquely generated using the <emphasis role="bold"><code>T</code></emphasis><emphasis role="bold"><code>UUID</code></emphasis>. Any other value will be used as a constant. The following basic random distributions are provided:         <code>Rndm()</code> or <code>Uniform(min,max)</code>, <code>Gaus(mean,sigma)</code>, <code>Exp(tau)</code>,         <code>BreitWigner(mean,sigma)</code>, <code>Landau(mean,sigma)</code>, <code>Poisson(mean)</code>, <code>Binomial(ntot,prob)</code>. You can customize your ROOT session by replacing the random number generator. You can delete <emphasis role="italic"><emphasis role="bold"><code>gRandom </code></emphasis></emphasis>and recreate it with your own. For example:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>delete gRandom;</code></emphasis>
root[] <emphasis role="bold"><code>gRandom = new TRandom2(0);</code></emphasis> <emphasis role="italic"><code>//seed=0</code></emphasis>
</programlisting>

<para><emphasis role="bold"><code>TRandom</code></emphasis><emphasis role="bold"><code>2</code></emphasis> is another generator, which is also very fast and uses only three words for its state.</para>
</sect2>

<sect2>
<title>gEnv</title>
<para><emphasis role="bold"><code>gEnv</code></emphasis> is the global variable (of type <emphasis role="bold"><code>TEnv</code></emphasis>) with all the environment settings for the current session. This variable is set by reading the contents of a <code>.rootrc</code> file (or <code>$ROOTSYS/etc/system.rootrc</code>) at the beginning of the root session. See Environment Setup below for more information.</para>
</sect2>
</sect1>

<sect1>
<title>Environment Setup</title>
<para>The behavior of a ROOT session can be tailored with the options in the .<code>rootrc</code> file. At start-up, ROOT looks for a .<code>rootrc</code> file in the following order:</para>
<itemizedlist>
<listitem><para>    <code>./.rootrc</code>    <emphasis><code>//local directory</code></emphasis></para></listitem>
<listitem><para>    <code>$HOME/.rootrc </code>    <emphasis><code>//user directory</code></emphasis></para></listitem>
<listitem><para>    <code>$ROOTSYS/etc/system.rootrc </code>    <emphasis><code>//global ROOT directory</code></emphasis></para></listitem>
</itemizedlist>
<para>If more than one <code>.rootrc</code> files are found in the search paths above, the options are merged, with precedence local, user, global. While in a session, to see current settings, you can do:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>gEnv</code></emphasis><emphasis role="bold"><code>-&gt;Print()</code></emphasis>
</programlisting>

<para>The <code>rootrc</code> file typically looks like:</para>

<programlisting language="c++">
# Path used by dynamic loader to find shared libraries
Unix.*.Root.DynamicPath:  .:~/rootlibs:$(ROOTSYS)/lib
Unix.*.Root.MacroPath:    .:~/rootmacros:$(ROOTSYS)/macros

# Path where to look for TrueType fonts
Unix.*.Root.UseTTFonts:     true
Unix.*.Root.TTFontPath:
…
# Activate memory statistics
Rint.Root.MemStat:       1
Rint.Load:               rootalias.C
Rint.Logon:              rootlogon.C
Rint.Logoff:             rootlogoff.C
…
Rint.Canvas.MoveOpaque:  false
Rint.Canvas.HighLightColor: 5
</programlisting>

<para>The various options are explained in <code>$ROOTSYS/etc/system.rootrc</code>. The <code>.rootrc</code> file contents are combined. For example, if the flag to use true type fonts is set to true in the <code>system.rootrc</code> file, you have to set explicitly it false in your local <code>.rootrc</code> file if you do not want to use true type fonts. Removing the <code>UseTTFonts </code>statement in the local <code>.rootrc</code> file will not disable true fonts. The value of the environment variable <code>ROOTDEBUG</code> overrides the value in the <code>.rootrc</code> file at startup. Its value is used to set <emphasis role="italic"><emphasis role="bold"><code>gDebug</code></emphasis></emphasis>         and helps for quick turn on debug mode in <emphasis role="bold"><code>TROOT</code></emphasis> startup.</para>
<para>ROOT looks for scripts in the path specified in the <code>.rootrc</code> file in the <code>Root.Macro.Path </code>
variable. You can expand this path to hold your own directories.</para>

<sect2>
<title>Logon and Logoff Scripts</title>
<para>The <code>rootlogon.C</code> and <code>rootlogoff.C</code> files are scripts loaded and executed at start-up and shutdown. The <code>rootalias.C</code> file is loaded but not executed. It typically contains small utility functions. For example, the <code>rootalias.C</code> script that comes with the ROOT distributions (located in <code>$ROOTSYS/tutorials)</code> defines the function <code>edit(char *file)</code>. This allows the user to call the editor from the command line. This particular function will start the VI editor if the environment variable <code>EDITOR</code> is not set.</para>

<programlisting language="c++">
root[0] <emphasis role="bold"><code>edit("c1.C")</code></emphasis>
</programlisting>

<para>For more details, see <code>$ROOTSYS/tutorials/rootalias.C</code>. </para>
</sect2>

<sect2>
<title>History File</title>
<para>You can use the up and down arrow at the command line, to access the previous and next command. The commands are recorded in the history file
<code>$HOME/.root_hist</code>. It is a text file, and you can edit, cut, and paste from it. You can specify the history file in the
<code>system.rootrc</code> file, by setting the <code>Rint.History </code>option. You can also turn off the command logging in the <code>system.rootrc</code> file with the option: <code>Rint.History: -</code></para>
<para>The number of history lines to be kept can be set also in .rootrc by:</para>

<programlisting language="c++">
Rint.HistSize:         500
Rint.HistSave:         400
</programlisting>

<para>The first value defines the maximum of lines kept; once it is reached all, the last <code>HistSave</code> lines will be removed. One can set <code>HistSize</code> to 0 to disable history line management. There is also implemented an environment variable called <code>ROOT_HIST</code>. By setting <code>ROOT_HIST=300:200</code> the above values can be overriden - the first value corresponds to <code>HistSize</code>, the (optional) second one to <code>HistSave</code>. You can set <code>ROOT_HIST=0</code> to disable the history.</para>
</sect2>

<sect2>
<title>Tracking Memory Leaks</title>
<para>You can track memory usage and detect leaks by monitoring the number of objects that are created and deleted (see <emphasis role="bold"><code>TObjectTable</code></emphasis>). To use this facility, edit the file <code>$ROOTSYS/etc/system.rootrc</code> or <code>.rootrc</code> if you have this file and add the two following lines:</para>

<programlisting language="c++">
<code>Root.MemStat:            1</code>
<code>Root.ObjectStat:         1</code>
</programlisting>

<para>In your code or on the command line you can type the line:</para>

<programlisting language="c++">
<code>gObjectTable-&gt;Print();</code>
</programlisting>

<para>This line will print the list of all active classes and the number of instances for each class. By comparing consecutive print outs, you can see objects that you forgot to delete. Note that this method cannot show leaks coming from the allocation of non-objects or classes unknown to ROOT.</para>
</sect2>

<sect2>
<title>Memory Checker</title>
<para>A memory checking system was developed by D.Bertini and M.Ivanov and added in ROOT version 3.02.07. To activate the memory checker you can set the resource <code>Root.MemCheck</code> to 1 (e.g.: <code>Root.MemCheck: 1</code> in the <code>.rootrc</code> file). You also have to link with <code>libNew.so</code> (e.g. use <code>root-config --new --libs</code>) or to use <code>rootn.exe</code>. When these settings are in place, you will find a file "<code>memcheck.out</code>" in the directory where you started your ROOT program after the completion of the program execution. You can also set the resource <code>Root.MemCheckFile</code> to the name of a file. The memory information will be written to that file. The contents of this <code>memcheck.out</code> can be analyzed and transformed into printable text via the <code>memprobe</code> program (in <code>$ROOTSYS/bin</code>).</para>
</sect2>
</sect1>

<sect1>
<title>Converting from PAW to ROOT</title>
<para>The web page at:  <uri xmlns:xlink="http://root.cern.ch/root/HowtoConvertFromPAW.html">http://root.cern.ch/root/HowtoConvertFromPAW.html#TABLE</uri>
gives the "translation" table of some commonly used PAW commands into ROOT. If you move the mouse cursor over the picture at:
<uri xmlns:xlink="http://root.cern.ch/root/HowtoConvertFromPAW.html">http://root.cern.ch/root/HowtoConvertFromPAW.html#SET</uri>,
you will get the corresponding ROOT commands as tooltips.</para>

<sect2>
<title>Converting HBOOK/PAW Files</title>
<para>ROOT has a utility called <code>h2root</code> that you can use to convert your HBOOK/PAW histograms or ntuple files into ROOT files. To use this program, you type the shell script command: </para>

<programlisting language="c++">
h2root  &lt;hbookfile&gt;  &lt;rootfile&gt;
</programlisting>

<para>If you do not specify the second parameter, a file name is automatically generated for you. If <code>hbookfile</code> is of the form <code>file.hbook</code>, then the ROOT file will be called <code>file.root</code>. This utility converts HBOOK histograms into ROOT histograms of the class <emphasis role="bold"><code>TH1F</code></emphasis>. HBOOK profile histograms are converted into ROOT profile histograms (see class <emphasis role="bold"><code>TProfile</code></emphasis>). HBOOK row-wise and column-wise ntuples are automatically converted to ROOT Trees. See “Trees”. Some HBOOK column-wise ntuples may not be fully converted if the columns are an array of fixed dimension (e.g. <code>var[6]</code>) or if they are a multi-dimensional array. </para>
<para>HBOOK integer identifiers are converted into ROOT named objects by prefixing the integer identifier with the letter "<code>h</code>" if the identifier is a positive integer and by <code>"h_"</code> if it is a negative integer identifier. In case of row-wise or column-wise ntuples, each column is converted to a branch of a tree. Note that <code>h2root</code> is able to convert HBOOK files containing several levels of sub-directories. Once you have converted your file, you can look at it and draw histograms or process ntuples using the ROOT command line. An example of session is shown below: </para>

<programlisting language="c++">
<code>// this connects the file hbookconverted.root</code>
root[] <emphasis role="bold"><code>TFile f("hbookconverted.root"); </code></emphasis>

<emphasis><code>//display histogram named h10 (was HBOOK id 10)</code></emphasis>
root[] <emphasis role="bold"><code>h10.Draw();</code></emphasis>

<code>//display column "var" from ntuple h30</code>
root[] <emphasis role="bold"><code>h30.Draw("var");</code></emphasis>
</programlisting>

<para>You can also use the ROOT browser (see <emphasis role="bold"><code>TBrowser</code></emphasis>) to inspect this file. </para>
<para>The chapter on trees explains how to read a tree. ROOT includes a function <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeClass</code> to generate automatically the code for a skeleton analysis function. See “Example Analysis”. </para>
<para>In case one of the ntuple columns has a variable length (e.g. <code>px(ntrack)</code>), <code>h.Draw("px")</code> will histogram the <code>px </code>column for all tracks in the same histogram. Use the script quoted above to generate the skeleton function and create/fill the relevant histogram yourself. </para>
</sect2>
</sect1>
</chapter>



