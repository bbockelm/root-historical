<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0">
<title>Python and Ruby Interfaces</title>
<para>Python is a popular, open-source, dynamic programming language with an interactive interpreter. Its interoperability with other programming languages, both for extending Python as well as embedding it, is excellent and many existing third-party applications and libraries have therefore so-called "Python bindings." PyROOT provides Python bindings for ROOT: it enables cross-calls from ROOT/CINT into Python and vice versa, the intermingling of the two interpreters, and the transport of user-level objects from one interpreter to the other. PyROOT enables access from ROOT to any application or library that itself has Python bindings, and it makes all ROOT functionality directly available from the python interpreter.</para>

<sect1>
<title>PyROOT Overview</title>
<para>The Python scripting language is widely used for scientific programming, including high performance and distributed parallel code (see  <uri xmlns:xlink="http://www.scipy.org">http://www.scipy.org</uri>). It is the second most popular scripting language (after Perl) and enjoys a wide-spread use as a "glue language": practically every library and application these days comes with Python bindings (and if not, they can be easily written or generated). </para>
<para><code>PyROOT</code>, a Python extension module, provides the bindings for the ROOT class library in a generic way using the CINT dictionary. This way, it allows the use of any ROOT classes from the Python interpreter, and thus the "glue-ing" of ROOT libraries with any non-ROOT library or applications that provide Python bindings. Further, <code>PyROOT</code> can be loaded into the CINT interpreter to allow (as of now still rudimentary) access to Python classes. The best way to understand the benefits of <code>PyROOT</code> is through a few examples.</para>

<sect2>
<title>Glue-ing Applications</title>
<para>The <code>PyQt</code> library, see  <uri xmlns:xlink="http://www.riverbankcomputing.co.uk/pyqt">http://www.riverbankcomputing.co.uk/pyqt</uri>, provides Python bindings for the Qt cross-platform GUI framework ( <uri xmlns:xlink="http://www.trolltech.com">http://www.trolltech.com</uri>). With <code>PyROOT</code> and <code>PyQt</code>, adding ROOT application layer code to a Qt GUI, becomes children play. The following example shows how a Python class can be used to have ROOT code respond to a click on a Qt widget.</para>

<programlisting language="c++">
<code># Glue-ing Qt and ROOT through Python  </code>
import sys, ROOT
from qt import *

theApp = QApplication( sys.argv)
box = QVBox()
box.resize(QSize(40,10).expandedTo(box.minimumSizeHint()))

class myButton(QPushButton):
def __init__( self,label,master):
QPushButton.__init__(self,label,master)
self.setFont( QFont('Times',18,QFont.Bold))

def browse(self):
self.b = ROOT.TBrowser()

bb = myButton('browser',box)
QObject.connect( bb,SIGNAL('clicked()'),bb.browse)

theApp.setMainWidget(box)
box.show()
theApp.exec_loop()
</programlisting>

<para>When the example is run, a Qt button is displayed, and when the button is clicked, a <emphasis role="bold"><code>TBrowser</code></emphasis> instance is created and will appear on the screen. <code>PyROOT</code> takes care of feeding system events to ROOT widgets, so the <emphasis role="bold"><code>TBrowser</code></emphasis> instance and the button behave properly when users interact with them.</para>
</sect2>

<sect2>
<title>Access to ROOT from Python</title>
<para>There are several tools for scientific analysis that come with bindings that allow the use of these tools from the Python interpreter. <code>PyROOT</code> provides this for users who want to do analysis in Python with ROOT classes. The following example shows how to fill and display a ROOT histogram while working in Python. Of course, any actual analysis code may come from somewhere else through other bindings, e.g. from a C++ program. </para>
<para>When run, the next example will display a 1-dimensional histogram showing a Gaussian distribution. More examples like the one above are distributed with ROOT under the <code>$ROOTSYS/tutorials</code> directory.</para>

<programlisting language="c++">
<emphasis role="italic"><code># Example: displaying a ROOT histogram from Python </code></emphasis>
from ROOT import gRandom,TCanvas,TH1F

c1 = TCanvas('c1','Example',200,10,700,500)
hpx = TH1F('hpx','px',100,-4,4)

for i in xrange(25000):
px = gRandom.Gaus()
hpx.Fill(px)

hpx.Draw()
c1.Update()
</programlisting>

</sect2>

<sect2>
<title>Access to Python from ROOT</title>
<para>Access to Python objects from CINT is not completely fleshed out. Currently, ROOT objects and built-in types can cross the boundary between the two interpreters, but other objects are much more restricted. For example, for a Python object to cross, it has to be a class instance, and its class has to be known to CINT first (i.e. the class has to cross first, before the instance can). All other cross-coding is based on strings that are run on the Python interpreter and vise-versa. </para>
<para>With the ROOT v4.00/06 and later, the <emphasis role="bold"><code>TPython</code></emphasis> class will be loaded automatically on use, for older editions, the <code>libPyROOT.so</code> needs to be loaded first before use. It is possible to switch between interpreters by calling <emphasis role="bold"><code>TPython</code></emphasis><code>::Prompt()</code> on the ROOT side, while returning with <code>^D</code> (<code>EOF</code>). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.</para>
<para/>

<programlisting language="c++">
<code>// Example: accessing the Python interpreter from ROOT </code>
<emphasis role="italic"><code>// either load PyROOT explicitly or rely on auto-loading</code></emphasis>
root[] <emphasis role="bold"><code>gSystem-&gt;Load( "libPyROOT" );</code></emphasis>
root[] <emphasis role="bold"><code>TP</code></emphasis><emphasis role="bold"><code>ython::Exec("print1+1");</code></emphasis>
2

<code>// create a TBrowser on the Python side, and transfer it back and forth</code>
root[] <emphasis role="bold"><code>TBrowser* b = (</code></emphasis><emphasis role="bold"><code>void</code></emphasis><emphasis role="bold"><code>*)</code></emphasis><emphasis role="bold"><code>T</code></emphasis><emphasis role="bold"><code>Python::Eval("ROOT.TBrowser()");</code></emphasis>
(class TObject*)0x8d1daa0
root[] <emphasis role="bold"><code>TPython::Bind(b,"b");</code></emphasis>

<code>// builtin variables can cross-over (after the call i==2)</code>
root[] <emphasis role="bold"><code>int i = TPython::Eval( “1+1” );</code></emphasis>
root[] <emphasis role="bold">i</emphasis>
(int)2
</programlisting>

</sect2>

<sect2>
<title>Installation</title>
<para>There are several ways of obtaining <code>PyROOT</code>, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on <code>afs</code>. Otherwise, you will want to build from source, as <code>PyROOT</code> is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from  <uri xmlns:xlink="http://www.python.org/">http://www.python.org/</uri> against which they were built.</para>

<sect3>
<title>Environment Settings</title>
<para>ROOT installations with the build of <code>PyROOT</code> enabled are available from the CERN <code>afs</code> cell <code>/afs/cern.ch/sw/root/&lt;version&gt;/&lt;platform&gt;</code>. To use them, simply modify your shell environment accordingly. For Unix:</para>
<para>
<code>export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH</code></para>
<para>
<code>export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH</code></para>
<para>
<code>export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH</code></para>
<para>For Windows:</para>
<para>
<code>set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%</code></para>
<para>
<code>set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%</code></para>
<para>where <code>$ROOTSYS</code> should be set to <code>/afs/cern.ch/sw/root/&lt;version&gt;/&lt;platform&gt;</code>, and <code>PYTHONDIR</code> to <code>/afs/cern.ch/sw/lcg/external/Python/2.3.4/&lt;platform&gt;</code> with <code>&lt;version&gt;</code> and <code>&lt;platform&gt;</code> as appropriate. Note that the latest version of Python is 2.4.1.</para>
</sect3>

<sect3>
<title>Building from Source</title>
<para>The standard installation instructions for building ROOT from source apply, with the addition that the build of <code>PyROOT</code> needs to be enabled at the configuration step. First, follow the instructions for obtaining and unpacking the source, and setting up the build environment.</para>
<para>Then, use the following command to configure the build process (of course, feel free to add any additional flags you may need):</para>
<para>
<code>$ ./configure &lt;arch&gt; [--with-python-incdir=&lt;dir&gt;][--with-python-libdir=&gt;dir&gt;]</code></para>
<para>For details on <code>&lt;arch&gt;</code> see the official build pages, the Python include directory should point to the directory that contains <code>Python.h</code> and the library directory should point to the directory containing <code>libpythonx.y.so</code>, where '<code>x</code>' and '<code>y</code>' are the major and minor version number, respectively. If you do not specify include and library directories explicitly, the configuration process will try the <code>PYTHONDIR</code> environment variable or, alternatively, the standard locations.</para>
<para>A recent distribution of Python is required: version 2.4.3 is preferred, but the older 2.2.x and 2.3.x versions suffice and are supported as well. Versions older than 2.2 are not supported and will not work. Note that one problem with 2.2 is that the shared library of the <code>Python</code> interpreter core is not build by default and the '--enable-shared' flag should thus be used when building <code>Python</code> from source. If the <code>Python</code> interpreter that is installed on your system is too old, please obtain a new version from  <uri xmlns:xlink="http://www.python.org">http://www.python.org</uri>.</para>
<para>Once configured, you continue the build process the normal way: </para>
<para>
<code>$ make</code></para>
<para>
<code>$ make cintdlls</code></para>
<para>
<code>$ make install</code></para>
<para>After some time, a library called <code>libPyROOT.so</code> (or <code>libPyROOT.dll</code>, on Windows) will be created in the <code>$ROOTSYS/lib </code>(<code>$ROOTSYS/bin on Windows</code>) directory and a top Python module, <code>ROOT.py</code>, will be copied into the same place. The final step is to setup the shell environment, which is similar to what is described in the chapter ‘Environment Settings’. Note that the <code>$ROOTSYS</code> entries are probably already there if you followed the standard instructions, and that the <code>PYTHONDIR</code> entries should be replaced as appropriate by your choice at configuration time, or be left out if you had the configuration script pick up them up from a default location.</para>
</sect3>
</sect2>

<sect2>
<title>Using PyROOT</title>
<para>Since it is an extension module, the usage of <code>PyROOT</code> probably comes naturally if you're used to Python. In general, <code>PyROOT</code> attempts to allow working in both Python and ROOT style, and although it is succeeding, it isn't perfect: there are edges. The following sections explain in some detail what you can expect, and what you need to watch out for.</para>

<sect3>
<title>Access to ROOT Classes</title>
<para>Before a ROOT class can be used from Python, its dictionary needs to be loaded into the current process. Starting with ROOT version 4.00/06, this happens automatically for all classes that are declared to the auto-loading mechanism through so-called <code>rootmap</code> files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example: </para>

<programlisting language="c++">
from ROOT import TCanvas          <emphasis role="italic"><code># available at startup</code></emphasis>
c = TCanvas()

from ROOT import TLorentzVector   <emphasis role="italic"><code># triggers auto-load of libPhysics</code></emphasis>
l = TLorentzVector()
</programlisting>

<para>Although it is not recommended, a simple way of working with <code>PyROOT</code> is doing a global import: </para>

<programlisting language="c++">
from ROOT import *

c = TCanvas()
l = TLorentzVector()
</programlisting>

<para>Keeping the ROOT namespace ("<code>import ROOT</code>"), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer: </para>

<programlisting language="c++">
import ROOT

c = ROOT.TCanvas()
l = ROOT.TLorentzVector()
</programlisting>

<para>Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will not actually result in copying all ROOT classes into the current namespace. Instead, classes will still be bound (and possibly loaded) on an as-needed basis. Note carefully how this is different from other Python (extension) modules, and what to expect if you use the normal inspection tools (such as e.g. '<code>dir()</code>'). This feature prevents the inspection tools from being swamped by an enormous amount of classes, but they can no longer be used to explore unknown parts of the system (e.g. to find out which classes are available). Furthermore, because of this approach, &lt;<code>tab</code>&gt;-completion will usually not be available until after the first use (and hence creation) of a class. </para>
<para>Access to class static functions, public data members, enums, etc. is as expected. Many more example uses of ROOT classes from Python can be found in the tutorials directory in the ROOT distribution. The recipes section contains a description on working with your own classes (see  “Using Your Own Classes”). </para>
</sect3>

<sect3>
<title>Access to STL Classes</title>
<para>Before STL classes can be used, you have to make sure that the CINT extension dlls are build (the "<code>cintdlls</code>" make target). Note that they do not compile on as many platforms as ROOT itself. Further, if you want to use template instantiations of STL classes with any of your own classes, make sure that a dictionary is available, e.g. by using ACLiC. </para>
<para>The STL classes live in the ROOT.std namespace (or, if you prefer to get them from there, in the ROOT module directly, but doing so makes the code less clear, of course). Be careful in their use, because Python already has types called "<code>string</code>" and "<code>list</code>." </para>
<para>In order to understand how to get access to a templated class, think of the general template as a meta class. By instantiating the meta class with the proper parameters, you get an actual class, which can then be used to create object instances. An example usage: </para>

<programlisting language="c++">
&gt;&gt;&gt; from ROOT import std
&gt;&gt;&gt; v = std.vector(int)()
&gt;&gt;&gt; for i in range(0,10):
...    v.push_back(i)
...
&gt;&gt;&gt; for i in v:
...     print i,
1 2 3 4 5 6 7 8 9
&gt;&gt;&gt;
&gt;&gt;&gt; list(v)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt;
</programlisting>

<para>The parameters to the template instantiation can either be an actual type or value (as is used here, "int"), or a string representation of the parameters (e.g. "'double'"), or a mixture of both (e.g. "'TCanvas, 0'" or "'double', 0" ). The "std::vector&lt;int&gt;" class is one of the classes builtin by default into the CINT extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn't exist. </para>
</sect3>

<sect3>
<title>Access to ROOT Globals</title>
<para>Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably <emphasis role="bold"><code>gMinuit</code></emphasis>, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanims). An example session should make this clear: </para>

<programlisting language="c++">
&gt;&gt;&gt; from ROOT import *
&gt;&gt;&gt; gROOT                              <emphasis role="italic"># directly available</emphasis>
&lt;ROOT.TROOT object at 0x399c30&gt;
&gt;&gt;&gt; gMinuit                            # library not yet loaded: not available
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in ?
NameError: name 'gMinuit' is not defined
&gt;&gt;&gt; TMinuit                            # use of TMinuit class forces auto-loading
&lt;class '__main__.TMinuit'&gt;
&gt;&gt;&gt; gMinuit                            <emphasis role="italic"># now gMinuit is available</emphasis>
&lt;__main__.TMinuit object at 0x1458c70&gt;
&gt;&gt;&gt; not not gMinuit                    # but it is the null pointer, until set
False
&gt;&gt;&gt; g = TMinuit()
&gt;&gt;&gt; not not gMinuit
True
</programlisting>

<para>It is also possible to create globals interactively, either by executing a CINT macro, or by a call to <code>gROOT.ProcessLine()</code>. These globals are made available in the same way: either use them directly after creation in 'from ROOT import *' more, or get them from the ROOT namespace after an 'import ROOT'.</para>
<para>As of 5.08, the behaviour of ROOT globals is the same as python globals, which is sometimes counterintuitive: since they are references, they can be changed only if done so directly through their containing module. The following session shows that in detail:</para>

<programlisting language="c++">
&gt;&gt;&gt; from ROOT import *
&gt;&gt;&gt; print gDebug
0
&gt;&gt;&gt; gROOT.ProcessLine( 'gDebug = 7;' )
&gt;&gt;&gt; print gDebug
0                                 <emphasis role="italic"><code># local gDebug is unchanged</code></emphasis>
&gt;&gt;&gt; gDebug = 5                    <emphasis role="italic"><code># changes _local_ reference only</code></emphasis>
&gt;&gt;&gt; print gDebug
5                                 <emphasis role="italic"><code># locally correct, but ...</code></emphasis>
&gt;&gt;&gt; gROOT.ProcessLine( 'cout &lt;&lt; gDebug &lt;&lt; endl;' )
7                                 <emphasis role="italic"><code># ... ROOT global unchanged</code></emphasis>
&gt;&gt;&gt; import ROOT
&gt;&gt;&gt; print ROOT.gDebug
7                                 <emphasis role="italic"><code># still the old value (not '5')</code></emphasis>
&gt;&gt;&gt; ROOT.gDebug = 3               <emphasis role="italic"><code># changes ROOT module reference</code></emphasis>
&gt;&gt;&gt; gROOT.ProcessLine( 'cout &lt;&lt; gDebug &lt;&lt; endl;' )
3                                 <emphasis role="italic"><code># ROOT global properly changed</code></emphasis>
&gt;&gt;&gt;
</programlisting>

<para>The above is another good reason to prefer 'import ROOT' over 'from ROOT import *'.</para>
</sect3>

<sect3>
<title>Access to Python</title>
<para>The access to Python from CINT goes through the <emphasis role="bold"><code>TPython</code></emphasis> class, or directly if a Python object or class has crossed the border. The <emphasis role="bold"><code>TPython</code></emphasis> class, which looks approximately like this: </para>

<programlisting language="c++">
class TPython {

public:
<emphasis role="italic"><code>   // load a Python script as if it were a macro</code></emphasis>
static void LoadMacro(const char* name);

<emphasis role="italic"><code>   // execute a Python statement (e.g. "import ROOT")</code></emphasis>
static void Exec(const char* cmd);

<emphasis role="italic"><code>   // evaluate a Python expression (e.g. "1+1")</code></emphasis>
static const TPyReturn&amp; Eval(const char* expr);

<emphasis role="italic"><code>   // bind a ROOT object with, at the Python side, the name "label"</code></emphasis>
static bool Bind(TObject* obj,const char* label);

<emphasis role="italic"><code>   // enter an interactive Python session (exit with ^D)</code></emphasis>
static void Prompt();
};
</programlisting>

<para><code>LoadMacro(const char* name)</code> - the argument is a name of a Python file that is to be executed (<code>'execfile'</code>), after which any new classes are automatically made available to CINT. Since it is non-selective, use with care.  </para>
<para><code>ExecScript(const char* name,int argc=0,const char** argv=0)</code> - the argument is a name of a python file that is to be executed ('execfile') in a private namespace to minimize side-effects. Optionally, you can add CLI-style arguments which are handed to the script through 'sys.argv' in the normal way. </para>
<para><code>Exec(const char* cmd) </code>- the argument is a string of Python code that is executed as a statement. There is no return value, but an error message will be printed if there are problems such as syntax errors.</para>
<para><code>Eval(const char* expr) </code>- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and <code>const char*</code> are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.</para>
<para><code>Bind(TObject* obj,const char* label)</code> - transfer a ROOT object from the CINT to the Python interpreter, where it will be referenced with a variable called "<code>label</code>".</para>
<para><code>Prompt()</code> – Transfer the interactive prompt to Python.</para>
<para>With the ROOT v4.00/06 and later, the <emphasis role="bold"><code>TPython</code></emphasis> class will be loaded automatically on use, for older editions, the <code>libPyROOT.so</code> needs to be loaded first with <code>gSystem-&gt;Load()</code> before use. Refer back to the other example of the use of <emphasis role="bold"><code>TPython</code></emphasis> that was given in “Access to Python from ROOT”. </para>
<para>To show in detail how Python access can be used, an example Python module is needed, as follows:</para>

<programlisting language="c++">
print 'creating class MyPyClass ... '
class MyPyClass:
def __init__(self):
print 'in MyPyClass.__init__'
self._browser = None
def gime(self,what):
return what
</programlisting>

<para>This module can now be loaded into a CINT session, the class used to instantiate objects, and their member functions called for showing how different types can cross: </para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TPython::LoadMacro("MyPyClass.py");</code></emphasis>
creating class MyPyClass ...
root[] <emphasis role="bold"><code>MyPyClass m;</code></emphasis>
in MyPyClass.__init__
root[] <emphasis role="bold"><code>char* s = m.gime("aap")</code></emphasis>;
root[] <emphasis role="bold"><code>s</code></emphasis>
(char* 0x41ee7754)"aap"
</programlisting>

<para>Note that the <code>LoadMacro()</code> call makes the class automatically available, such that it can be used directly. Otherwise, a <code>gROOT-&gt;GetClass()</code>         call is required first. </para>
</sect3>

<sect3>
<title>Callbacks</title>
<para>The simplest way of setting a callback to Python from CINT, e.g. for a button, is by providing the execution string. See for example <code>tutorials/pyroot/demo.py</code> that comes with the ROOT installation: </para>

<programlisting language="c++">
# [..]
bar = ROOT.TControlBar('vertical','Demos')
bar.AddButton('Help on Demos',r'TPython::Exec("execfile('demoshelp.py')");','Click Here For Help on Running the Demos')
bar.AddButton('browser',r'TPython::Exec("b = Tbrowser()");','Start the ROOT browser')
# [..]
</programlisting>

<para>Here, the callback is a string that will be interpreted by CINT to call <emphasis role="bold"><code>TPython</code></emphasis><code>::Exec()</code>, which will, in turn, interpret and execute the string given to it. Note the use of raw strings (the '<code>r</code>' in front of the second argument string), in order to remove the need of escaping the backslashes.</para>
</sect3>

<sect3>
<title>CINT Commands</title>
<para>In interactive mode, the Python exception hook is used to mimic some of the CINT commands available. These are: <code>.q</code>, <emphasis role="bold"><code>.!</code></emphasis>, <emphasis role="bold"><code>.x</code></emphasis>, <emphasis role="bold"><code>.L</code></emphasis>, <emphasis role="bold"><code>.cd</code></emphasis>, <emphasis role="bold"><code>.ls</code></emphasis>, <emphasis role="bold"><code>.pwd</code></emphasis>, <emphasis role="bold"><code>.?</code></emphasis> and <emphasis role="bold"><code>.</code></emphasis><emphasis role="bold"><code>help</code></emphasis>. Note that <emphasis role="bold"><code>.x</code></emphasis> translates to Python '<code>execfile()</code>' and thus accepts only Python files, not CINT macros. </para>
</sect3>
</sect2>

<sect2>
<title>Memory Handling</title>
<para>The Python interpreter handles memory for the user by employing reference counting and a garbage collector (for new-style objects, which includes <code>PyROOT</code> objects). In C++, however, memory handling is done either by hand, or by an application specific, customized mechanism (as is done in ROOT). Although <code>PyROOT</code> is made aware of ROOT memory management, there are still a few boundary conditions that need to be dealt with by hand. Also, the heuristics that <code>PyROOT</code> employs to deal with memory management are not infallible. An understanding in some detail of the choices that are made is thus important. </para>

<sect3>
<title>Automatic Memory Management</title>
<para>There are two global policies that can be set: heuristics and strict. By default, the heuristic policy is used, in which the following rules are observed: </para>
<itemizedlist>
<listitem><para>A ROOT object created on the Python interpreter side is owned by Python and will be deleted once the last Python reference to it goes away. If, however, such an object is passed by non-const address as a parameter to a C++ function (with the exception of the use as "self" to a member function), ownership is relinquished. </para></listitem>
<listitem><para>A ROOT object coming from a ROOT call is not owned, but before it passes to the Python interpreter, its "must cleanup" bit is set if its type is a class derived from <emphasis role="bold"><code>TObject</code></emphasis>. When the object goes out of scope on the C++ side, the Python object will change type into an object that largely behaves like None.</para></listitem>
</itemizedlist>
<para>The strict policy differs in that it will never relinquish ownership when passing an object as a parameter to a function. It is then up to the developer to prevent double deletes. Choosing one or the other policy is done by:</para>

<programlisting language="c++">
ROOT.SetMemoryPolicy( ROOT.kMemoryStrict )
</programlisting>

<para>for the strict policy, or for the heuristic policy:</para>

<programlisting language="c++">
ROOT.SetMemoryPolicy( ROOT.kMemoryHeuristics )
</programlisting>

<para>Care must be taken in the case of graphic objects: when drawn on the current pad, a reference to the graphics is kept that <code>PyROOT</code> isn't currently aware of, and it is up to the developer to keep at lease one Python reference alive. See <code>$ROOTSYS/tutorials/pyroot/zdemo.py</code> (available in the latest release) for an example. Alternatively, one can tell python to give up ownership for individual instances:</para>

<programlisting language="c++">
o = ROOT.TObject()
ROOT.SetOwnership( o, False )      # True to own, False to release
</programlisting>

</sect3>

<sect3>
<title>Memory Management by Hand</title>
<para>If needed, you can explicitly destroy a ROOT object that you own through its associated <emphasis role="bold"><code>TClass</code></emphasis>: </para>

<programlisting language="c++">
<code>myobject.IsA().Destructor(myobject)</code>
</programlisting>

<para>which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it's reference count it non-zero), and free the memory. </para>
</sect3>
</sect2>

<sect2>
<title>Performance</title>
<para>The performance of <code>PyROOT</code> when programming with ROOT in Python is similar to that of CINT. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from <code>PyROOT</code>, whereas loops are typically slower. </para>
<para>When programming in Python, the modus operandi is to consider performance generally "good enough" on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path. </para>
<para>Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use <emphasis role="bold"><code>TLorentzVector</code></emphasis> instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are.  Some performance, without cost in terms of programmer effort, may be gained by using <code>psyco</code>, see the next link:  <uri xmlns:xlink="http://psyco.sourceforge.net">http://psyco.sourceforge.net</uri>, a Python just in time compiler (JIT). Note, however, that <code>psyco</code> is limited to Intel i386 CPUs. Since <code>psyco</code> optimizes Python, not <code>PyROOT</code> calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot. </para>
<para>Every call to a Python member function results in a lookup of that member function and an association of this method with <code>'self'</code>. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example: </para>

<programlisting language="c++">
hpx = TH1F('hpx','px',100,-4,4)
hpxFill = hpx.Fill                <emphasis role="italic"><code># cache bound method</code></emphasis>
for i in xrange(25000):
px = gRandom.Gaus()
hpxFill(px)                    <emphasis role="italic"><code># use bound method: no lookup needed</code></emphasis>
del hpxFill                       <emphasis role="italic"><code># done with cached method</code></emphasis>
</programlisting>

<para>Note that if you do not discard the bound method, a reference to the histogram will remain outstanding, and it will not be deleted when it should be. It is therefore important to delete the method when you're done with it. </para>
</sect2>

<sect2>
<title>Use of Python Functions</title>
<para>It is possible to mix Python functions with ROOT and perform such operations as plotting and fitting of histograms with them. In all cases, the procedure consists of instantiating a ROOT <emphasis role="bold"><code>TF1</code></emphasis>, <emphasis role="bold"><code>TF2</code></emphasis>, or <emphasis role="bold"><code>TF3</code></emphasis> with the Python function and working with that ROOT object.  There are some memory issues, so it is for example not yet possible to delete a <emphasis role="bold"><code>TF1</code></emphasis> instance and then create another one with the same name. In addition, the Python function, once used for instantiating the <emphasis role="bold"><code>TF1</code></emphasis>, is never deleted. </para>
<para>Instead of a Python function, you can also use callable instances (e.g., an instance of a class that has implemented the <code>__call__</code> member function). The signature of the Python callable should provide for one or two arrays. The first array, which must always be present, shall contain the <code>x</code>, <code>y</code>, <code>z</code>, and t values for the call. The second array, which is optional and its size depends on the number given to the <emphasis role="bold"><code>TF1</code></emphasis> constructor, contains the values that parameterize the function. For more details, see the <emphasis role="bold"><code>TF1</code></emphasis> documentation and the examples below.</para>

<sect3>
<title>Plotting Python Function</title>
<para>This is an example of a parameter less Python function that is plotted on a default canvas: </para>

<programlisting language="c++">
from ROOT import TF1, TCanvas

def identity( x ):
return x[0]

<emphasis role="italic"><code># create an identity function</code></emphasis>
f = TF1('pyf1',identity,-1.,1.)

<emphasis role="italic"><code># plot the function</code></emphasis>
c = TCanvas()
f.Draw()
</programlisting>

<para>Because no number of parameters is given to the <emphasis role="bold"><code>TF1</code></emphasis> constructor, '<code>0</code>' (the default) is assumed. This way, the '<code>identity'</code> function need not handle a second argument, which would normally be used to pass the function parameters. Note that the argument '<code>x</code>' is an array of size 4. The following is an example of a parameterized Python callable instance that is plotted on a default canvas: </para>

<programlisting language="c++">
from ROOT import TF1, TCanvas

class Linear:
def __call__( self, x, par ):
return par[0] + x[0]*par[1]

<emphasis role="italic"><code># create a linear function with offset 5, and pitch 2</code></emphasis>
f = TF1('pyf2',Linear(),-1.,1.,2)
f.SetParameters(5.,2.)

<emphasis role="italic"><code># plot the function</code></emphasis>
c = TCanvas()
f.Draw()
</programlisting>

<para>Note that this time the constructor is told that there are two parameters, and note in particular how these parameters are set. It is, of course, also possible (and preferable if you only use the function for plotting) to keep the parameters as data members of the callable instance and use and set them directly from Python. </para>
</sect3>

<sect3>
<title>Fitting Histograms</title>
<para>Fitting a histogram with a Python function is no more difficult than plotting: instantiate a <emphasis role="bold"><code>TF1</code></emphasis> with the Python callable and supply that <emphasis role="bold"><code>TF1</code></emphasis> as a parameter to the <code>Fit()</code> member function of the histogram. After the fit, you can retrieve the fit parameters from the <emphasis role="bold"><code>TF1</code></emphasis> instance. For example: </para>

<programlisting language="c++">
from ROOT import TF1, TH1F, TCanvas

class Linear:
def __call__( self, x, par ):
return par[0] + x[0]*par[1]

<emphasis role="italic"><code># create a linear function for fitting</code></emphasis>
f = TF1('pyf3',Linear(),-1.,1.,2)

<emphasis role="italic"><code># create and fill a histogram</code></emphasis>
h = TH1F('h','test',100,-1.,1.)
f2 = TF1('cf2','6.+x*4.5',-1.,1.)
h.FillRandom('cf2',10000)

<emphasis role="italic"><code># fit the histo with the python 'linear' function</code></emphasis>
h.Fit(f)

<emphasis role="italic"><code># print results</code></emphasis>
par = f.GetParameters()
print 'fit results: const =',par[0],',pitch =',par[1]
</programlisting>

</sect3>
</sect2>

<sect2>
<title>Working with Trees</title>
<para>Next to making histograms, working with trees is probably the most common part of any analysis. The <emphasis role="bold"><code>TTree</code></emphasis> implementation uses pointers and dedicated buffers to reduce the memory usage and to speed up access. Consequently, mapping <emphasis role="bold"><code>TTree</code></emphasis> functionality to Python is not straightforward, and most of the following features are implemented in ROOT release 4.01/04 and later only, whereas you will need 5.02 if you require all of them. </para>

<sect3>
<title>Accessing an Existing Tree</title>
<para>Let us assume that you have a file containing <emphasis role="bold"><code>TTrees</code></emphasis>, <emphasis role="bold"><code>TChains</code></emphasis>, or <emphasis role="bold"><code>TNtuples</code></emphasis> and want to read the contents for use in your analysis code. This is commonly the case when you work with the result of the reconstruction software of your experiment (e.g. the combined ntuple in ATLAS). The following example code outlines the main steps (you can run it on the result of the <code>tree1.C</code> macro): </para>

<programlisting language="c++">
from ROOT import TFile
from ROOT import gDirectory

<emphasis role="italic"><code># open the file</code></emphasis>
myfile = TFile('tree1.root')

<emphasis role="italic"><code># retrieve the ntuple of interest</code></emphasis>
mychain = gDirectory.Get('t1')
entries = mychain.GetEntriesFast()

for jentry in xrange(entries):
<emphasis role="italic"><code># get the next tree in the chain and verify</code></emphasis>
ientry = mychain.LoadTree(jentry)
if ientry &lt; 0:
break

<emphasis role="italic"><code># copy next entry into memory and verify</code></emphasis>
nb = mychain.GetEntry(jentry)
if nb<code>&lt;=</code>0:
continue

<emphasis role="italic"><code># use the values directly from the tree</code></emphasis>
nEvent = int(mychain.ev)
if nEvent&lt;0:
continue

print mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py

</programlisting>

<para>Access to arrays works the same way as access to single value tree elements, where the size of the array is determined by the number of values actually read from the file. For example: </para>

<programlisting language="c++">
<emphasis role="italic"><code># loop over array tree element</code></emphasis>
for d in mychain.mydoubles:
print d

<emphasis role="italic"><code># direct access into an array tree element</code></emphasis>
i5 = mychain.myints[5]
</programlisting>

</sect3>

<sect3>
<title>Writing a Tree</title>
<para>Writing a ROOT <emphasis role="bold"><code>TTree</code></emphasis> in a Python session is a little convoluted, if only because you will need a C++ class to make sure that data members can be mapped, unless you are working with built-in types. Here is an example for working with the latter only: </para>

<programlisting language="c++">
from ROOT import TFile, TTree
from array import array

h = TH1F('h1','test',100,-10.,10.)
f = TFile('test.root','recreate')
t = TTree('t1','tree with histos')
maxn = 10
n = array('i',[0])
d = array('f',maxn*[0.])
t.Branch('mynum',n,'mynum/I')
t.Branch('myval',d,'myval[mynum]/F')

for i in range(25):
n[0] = min(i,maxn)
for j in range(n[0]):
d[j] = i*0.1+j
t.Fill()

f.Write()
f.Close()
</programlisting>

<para>The use of arrays is needed, because the pointer to the address of the object that is used for filling must be given to the <emphasis role="bold"><code>TTree</code></emphasis><code>::Branch()</code> call, even though the formal argument is declared a '<code>void*'</code>. In the case of ROOT objects, similar pointer manipulation is unnecessary, because the full type information is available, and <emphasis role="bold"><code>TTree</code></emphasis><code>::Branch()</code> has been Pythonized to take care of the call details. However, data members of such objects that are of built-in types, still require something extra since they are normally translated to Python primitive types on access and hence their address cannot be taken. For that purpose, there is the <code>AddressOf()</code> function. As an example: </para>

<programlisting language="c++">
from ROOT import TFile, TTree
from ROOT import gROOT, AddressOf

gROOT.ProcessLine(
"struct MyStruct {     Int_t     fMyInt1;     Int_t     fMyInt2;     Int_t     fMyInt3;     Char_t    fMyCode[4];  };" );

from ROOT import MyStruct
mystruct = MyStruct()
f = TFile('mytree.root','RECREATE')
tree = TTree('T','Just A Tree')
tree.Branch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3')
tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C')
for i in range(0,10):
mystruct.fMyInt1   = i
mystruct.fMyInt2   = i*i
mystruct.fMyInt3   = i*i*i
mystruct.fMyCode   = "%03d" % i     <emphasis role="italic"><code> # note string assignment</code></emphasis>

tree.Fill()
f.Write()
f.Close()
</programlisting>

<para>The C++ class is defined through the <code>gROOT.ProcessLine()</code> call, and note how the <code>AddressOf()</code> function is used for data members of built-in type. Most of the above is for ROOT version 5.02 and later only. For older releases, and without further support, here is an example as to how you can get hold of a pointer-to-pointer to a ROOT object: </para>

<programlisting language="c++">
h = TH1F()
addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)])
</programlisting>

</sect3>
</sect2>

<sect2>
<title>Using Your Own Classes</title>
<para>A user's own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC: </para>

<programlisting language="c++">
$ cat MyClass.C
class MyClass {
public:

MyClass(int value = 0) {
m_value = value;
}

void SetValue(int value) {
m_value = value;
}

int GetValue() {
return m_value;
}

private:
int m_value;
};

$ echo .L MyClass.C+ | root.exe -b
[...]
Info in &lt;TUnixSystem::ACLiC&gt;: creating shared library [..]/./MyClass_C.so
$
</programlisting>

<para>Then you can use it, for example, like so: </para>

<programlisting language="c++">
from ROOT import gSystem

<emphasis role="italic"><code># load library with MyClass dictionary</code></emphasis>
gSystem.Load('MyClass_C')

<emphasis role="italic"><code># get MyClass from ROOT</code></emphasis>
from ROOT import MyClass
<emphasis role="italic"><code># use MyClass</code></emphasis>
m = MyClass(42)
print m.GetValue()
</programlisting>

<para>You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example: </para>

<programlisting language="c++">
from ROOT import gROOT

<emphasis role="italic"><code># load MyClass definition macro (append '+' to use ACLiC)</code></emphasis>
gROOT.LoadMacro('MyClass.C')

<emphasis role="italic"><code># get MyClass from ROOT</code></emphasis>
from ROOT import MyClass

<emphasis role="italic"><code># use MyClass</code></emphasis>
m = MyClass()
m.SetValue(42)
print m.GetValue()
</programlisting>

</sect2>
</sect1>

<sect1>
<title>How to Use ROOT with Ruby</title>
<para>Ruby ROOT is a Ruby extension module that allows the user to interact with any ROOT class from the Ruby scripting language. The Ruby module resolves ROOT Classes and Methods at run-time using the CINT API, so there is no need for wrapping specific Classes to be used in Ruby. The Ruby module, also, contains a <emphasis role="bold"><code>TRuby</code></emphasis> class to execute Ruby statements via CINT and export C++ Objects to Ruby objects, interactively.</para>

<sect2>
<title>Building and Installing the Ruby Module</title>
<para>The Ruby extension module is not built by default when building ROOT from sources. The user should follow the standard installation instructions and enable the build of the Ruby module. Ruby version &gt;= 1.8 is required.</para>
<para>
<code>./configure &lt;arch&gt; --enable-ruby --enable-explicitlink</code></para>
<para>
<code>[--with-ruby-incdir=&lt;dir&gt;] [--with-ruby-libdir=&lt;dir&gt;]</code></para>
<para>
<code>gmake</code></para>
<para>If you do not specify include and library directories configure will use Ruby to grab the directories where Ruby's headers and library are located. A library called <code>libRuby.so [libRuby.dll]</code> will be created in the <code>$ROOTSYS/lib</code> <code>[$ROOTSYS/bin]</code>.</para>

<sect3>
<title>Setting up the Environment</title>
<para>For working with the Ruby module, the <code>LD_LIBRARY_PATH [PATH] </code>and <code>RUBYLIB,</code> need to be set in addition to the standard <code>$ROOTSYS</code>.</para>
<para>For UNIX Platforms:</para>
<para>
<code>export LD_LIBRARY_PATH=$ROOTSYS/lib:$LD_LIBRARY_PATH</code></para>
<para>
<code>export RUBYLIB=$ROOTSYS/lib:$RUBYLIB</code></para>
<para>For Windows:</para>
<para>
<code>set PATH=%ROOTSYS%/bin;%PATH%</code></para>
<para>
<code>set RUBYLIB=%ROOTSYS%/bin;%RUBYLIB%</code></para>
</sect3>

<sect3>
<title>Running ROOT scripts from Ruby</title>
<para>The user should make sure that the ruby command is the one of the installation that has been used to build the Ruby extension module. If the RUBYLIB environment variable is set correctly, the user can execute a Ruby script with ROOT functionality in the following way:</para>
<para>
<code>ruby -rlibRuby foo.rb</code></para>
<para>Another way is to start the Ruby script with the Ruby require command:</para>
<para>
<code>require 'libRuby'</code></para>
<para>An example is as follows:</para>

<programlisting language="c++">
require 'libRuby'
gROOT.Reset
c1 = TCanvas.new('c1','Example with Formula',200,10,700,500)
#
# Create a one dimensional function and draw it
#
fun1 = TF1.new('fun1','abs(sin(x)/x)',0,10)
c1.SetGridx
c1.SetGridy
fun1.Draw
c1.Update
</programlisting>

<para>The user can find a number of examples in the <code>$ROOTSYS/tutorials</code>. To run them you need to execute the command:</para>
<para>
<code>cd $ROOTSYS/tutorials</code></para>
<para>
<code>ruby demo.rb</code></para>
</sect3>

<sect3>
<title>Invoking the Ruby Module from CINT Interpreter</title>
<para>A ROOT user can run any Ruby command and eventually to run<code> IRB</code>, the Interactive Ruby Shell. The commands to execute are:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>TRuby::Exec</code></emphasis><emphasis role="bold"><code>("require '/usr/local/lib/root/libRuby'");</code></emphasis>
root[] <emphasis role="bold"><code>TRuby::Exec("c1 = TBrowser.new");</code></emphasis>
root[] <emphasis role="bold"><code>TRuby</code></emphasis><emphasis role="bold"><code>::Eval("c1.GetName");</code></emphasis>
root[] <emphasis role="bold"><code>TRuby::Eval("puts c1.GetName");</code></emphasis>
Browser
root[] <emphasis role="bold"><code>TCanvas *c2 = new TCanvas("ruby test", "test", 10, 10, 100, 100);</code></emphasis>
root[] <emphasis role="bold"><code>TRuby</code></emphasis><emphasis role="bold"><code>::Bind(c2, "$c");</code></emphasis>
root[] <emphasis role="bold"><code>TRuby::Eval("puts $c.GetTitle");</code></emphasis>
test
root[] <emphasis role="bold"><code>TRuby</code></emphasis><emphasis role="bold"><code>::Prompt();</code></emphasis>
root[] <emphasis role="bold"><code>TRuby::Prompt();</code></emphasis>
irb(main):001:0&gt; print 1
1=&gt; nil
irb(main):002:0&gt;

</programlisting>

<para>Notice that whenever you bind a ROOT Object in the Ruby side, you need to use a global Ruby variable, that is a variable with a leading "<code>$</code>".</para>
</sect3>
</sect2>
</sect1>
</chapter>



