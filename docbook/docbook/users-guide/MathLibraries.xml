<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0">
<title>Math Libraries in ROOT</title>
<para>The aim of Math libraries in ROOT is to provide and to support a coherent set of mathematical and statistical functions.
The latest developments have been concentrated in providing first versions of the <code>MathCore</code> and <code>MathMore</code> libraries, included in ROOT v5.08.
Other recent developments include the new version of <code>MINUIT</code>, which has been re-designed and re-implemented in the C++ language. It is integrated in ROOT.
In addition, an optimized package for describing small matrices and vector with fixed sizes and their operation has been developed (<code>SMatrix</code>). The structure is
shown in the following picture.</para>

<figure>
<title>Math libraries and packages</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/02000109.jpg" width="281.15pt" depth="214.75pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<sect1>
<title>TMath</title>
<para>In the namespace, <emphasis role="bold"><code>TMath</code></emphasis> a collection of free functions is provided for the following functionality: </para>
<itemizedlist>
<listitem><para>numerical constants (like <code>pi</code>, <code>e</code>, <code>h</code>, etc.);</para></listitem>
<listitem><para>elementary and trigonometric functions;</para></listitem>
<listitem><para>functions to find <code>min</code> and <code>max</code> of arrays;</para></listitem>
<listitem><para>statistic functions to find mean and <code>rms</code> of arrays of data;</para></listitem>
<listitem><para>algorithms for binary search/hashing sorting;</para></listitem>
<listitem><para>special mathematical functions like <code>Bessel</code>, <code>Erf</code>, <code>Gamma</code>, etc.;</para></listitem>
<listitem><para>statistical functions, like common probability and cumulative (quantile) distributions</para></listitem>
</itemizedlist>
<para>For more details, see the reference documentation of <emphasis role="bold"><code>TMath</code></emphasis> at  <uri xmlns:xlink="http://root.cern.ch/root/htmldoc/TMath.html">http://root.cern.ch/root/htmldoc/TMath.html</uri>.</para>
</sect1>

<sect1>
<title>Random Numbers</title>
<para>In ROOT pseudo-random numbers can be generated using the <emphasis role="bold"><code>TRandom</code></emphasis> classes. 4 different types exist: <emphasis role="bold"><code>TRandom</code></emphasis>, <emphasis role="bold"><code>TRandom1</code></emphasis>, <emphasis role="bold"><code>TRandom2</code></emphasis> and <emphasis role="bold"><code>TRandom3</code></emphasis>. All they implement a different type of random generators. <emphasis role="bold"><code>TRandom</code></emphasis> is the base class used by others. It implements methods for generating random numbers according to pre-defined distributions, such as Gaussian or Poisson. </para>

<sect2>
<title>TRandom</title>
<para>Pseudo-random numbers are generated using a linear congruential random generator. The multipliers used are the same of the BSD <code>rand()</code> random generator. Its sequence is: </para>
<para> <inlinemediaobject><imageobject><imagedata fileref="pictures/0600010A.png" width="104.9pt" depth="14.3pt"/></imageobject></inlinemediaobject> with <inlinemediaobject><imageobject><imagedata fileref="pictures/0600010B.png" width="9.95pt" depth="11.15pt"/></imageobject></inlinemediaobject><code>=1103515245</code>, <inlinemediaobject><imageobject><imagedata fileref="pictures/0600010C.png" width="9.3pt" depth="11.15pt"/></imageobject></inlinemediaobject>= 12345 and <inlinemediaobject><imageobject><imagedata fileref="pictures/0600010D.png" width="13.05pt" depth="11.15pt"/></imageobject></inlinemediaobject>=231. </para>
<para>This type of generator uses a state of only a 32 bit integer and it has a very short period, 231,about 109, which can be exhausted in just few seconds. The quality of this generator is therefore BAD and it is strongly recommended to NOT use for any statistical study. </para>
</sect2>

<sect2>
<title>TRandom1</title>
<para>This random number generator is based on the Ranlux engine, developed by M. Lüsher and implemented in Fortran by F. James. This engine has mathematically proven random proprieties and a long period of about 10171. Various luxury levels are provided <code>(1,2,3,4)</code> and can be specified by the user in the constructor. Higher the level, better random properties are obtained at a price of longer CPU time for generating a random number. The level 3 is the default, where any theoretical possible correlation has very small chance of being detected. This generator uses a state of 24 32-bits words. Its main disadvantage is that is much slower than the others (see timing table). For more information on the generator see the following article: </para>
<itemizedlist>
<listitem><para>F. James, “RANLUX: A Fortran implementation of the high quality pseudo-random number generator of Lüscher”, Computer Physics Communication, 79 (1994) 111. </para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>TRandom2</title>
<para>This generator is based on the maximally equidistributed combined Tausworthe generator by L'Ecuyer. It uses only 3 32-bits words for the state and it has a period of about 1026. It is fast and given its small states, it is recommended for applications, which require a very small random number size. For more information on the generator see the following article: </para>
<itemizedlist>
<listitem><para>P. L’Ecuyer, “Maximally Equidistributed Combined Tausworthe Generators”, Mathematics of Computation, 65, 213 (1996), 203-213. </para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>TRandom3</title>
<para>This is based on the Mersenne and Twister pseudo-random number generator, developed in 1997 by Makoto Matsumoto and Takuji Nishimura.  The newer implementation is used, referred in the literature as MT19937. It is a very fast and very high quality generator with a very long period of 106000. The disadvantage of this generator is that it uses a state of 624 words. For more information on the generator see the following article: </para>
<itemizedlist>
<listitem><para>M. M. Matsumoto and T. Nishimura, “Mersenne twister: A 623-dimensionally equidistributed uniform pseudorandom number generator”, ACM Trans. on Modeling and Computer Simulations, 8, 1, (1998), 3-20.</para></listitem>
</itemizedlist>
<para><emphasis role="bold"><code>TRandom3</code></emphasis><emphasis role="bold"><code> </code></emphasis>is the recommended random number generator, and it is used by default in ROOT using the global <emphasis role="italic"><emphasis role="bold"><code>gRandom</code></emphasis></emphasis> object (see chapter gRandom).</para>
</sect2>

<sect2>
<title>Seeding the Generators</title>
<para>The seeds for the generators can be set in the constructor or by using the <code>SetSeed</code> method. When no value is given the generator default seed is used, like 4357 for <emphasis role="bold"><code>TRandom3</code></emphasis>. In this case identical sequence will be generated every time the application is run. When the 0 value is used as seed, then a unique seed is generated using a <emphasis role="bold"><code>TUUID</code></emphasis>, for <emphasis role="bold"><code>TRandom1</code></emphasis>, <emphasis role="bold"><code>TRandom2</code></emphasis> and <emphasis role="bold"><code>TRandom3</code></emphasis>. For <emphasis role="bold"><code>TRandom</code></emphasis> the seed is generated using only the machine clock, which has a resolution of about 1 sec. Therefore identical sequences will be generated if the elapsed time is less than a second. </para>
</sect2>

<sect2>
<title>Examples of Using the Generators</title>
<para>The method <code>Rndm()</code> is used for generating a pseudo-random number distributed between 0 and 1 as shown in the following example:</para>

<programlisting language="c++">
<emphasis role="italic"><code>// use default seed (same random numbers will be generated each time)</code></emphasis>
TRandom3 r; <emphasis role="italic"><code>// generate a number in interval ]0,1] (0 is excluded)</code></emphasis>
r.Rndm();
double x[100];
r.RndmArray(100,x);     <emphasis role="italic"><code>// generate an array of random numbers in ]0,1]</code></emphasis>
TRandom3 rdm(111);      <emphasis role="italic"><code>// construct with a user-defined seed</code></emphasis>
// <emphasis role="italic"><code>use </code></emphasis><emphasis role="italic"><code>0</code></emphasis><emphasis role="italic"><code>: a unique seed will be automatically generated using TUUID</code></emphasis>
TRandom1 r1(0);
TRandom2 r2(0);
TRandom3 r3(0);
<emphasis role="italic"><code>// use a seed generated using machine clock (different every second)</code></emphasis>
TRandom r0(0);
</programlisting>

</sect2>

<sect2>
<title>Random Number Distributions</title>
<para>The <emphasis role="bold"><code>TRandom</code></emphasis> base class provides functions, which can be used by all the other derived classes for generating random variates according to predefined distributions. In the simplest cases, like in the case of the exponential distribution, the non-uniform random number is obtained by applying appropriate transformations. In the more complicated cases, random variates are obtained using acceptance-rejection methods, which require several random numbers. </para>

<programlisting language="c++">
TRandom3 r;
<emphasis role="italic"><code>// generate a gaussian distributed number with mu=0, sigma=1 (default values)</code></emphasis>
double x1 = r.Gaus();
double x2 = r.Gaus(10,3);    <emphasis role="italic"><code>// use mu = 10, sigma = 3;</code></emphasis>
</programlisting>

<para>The following table shows the various distributions that can be generated using methods of the <emphasis role="bold"><code>TRandom</code></emphasis> classes. More information is available in the reference documentation for <emphasis role="bold"><code>TRandom</code></emphasis>. In addition, random numbers distributed according to a user defined function, in a limited interval, or to a user defined histogram, can be generated in a very efficient way using <emphasis role="bold"><code>TF1::</code></emphasis>GetRandom() or <emphasis role="bold"><code>TH1::</code></emphasis>GetRandom(). </para>
<informaltable frame="all">
<tgroup cols="2">
<colspec colwidth="5103*" colname="column-1"/>
<colspec colwidth="3827*" colname="column-2"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Distributions</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Description</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Double_t Uniform(Double_t x1,Double_t x2)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Uniform random numbers between <code>x1,x2</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Double_t Gaus(Double_t mu,Double_t sigma)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Gaussian random numbers. </para>
<para>Default values: <code>mu=0</code>, <code>sigma=1</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Double_t Exp(Double_t tau)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Exponential random numbers with mean tau.</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Double_t Landau(Double_t mean,Double_t sigma)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Landau distributed random numbers. </para>
<para>Default values: <code>mean=0</code>, <code>sigma=1</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Double_t BreitWigner(Double_t mean,</code>
</para>
<para>
<code>                     Double_t gamma)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Breit-Wigner distributed random numbers.</para>
<para>Default values <code>mean=0</code>, <code>gamma=1</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Int_t Poisson(Double_t mean) </code>
</para>
<para>
<code>Double_t PoissonD(Double_t mean)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Poisson random numbers</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Int_t  Binomial(Int_t ntot,Double_t prob)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Binomial Random numbers</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Circle(Double_t &amp;x,Double_t &amp;y,Double_t r)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Generate a random 2D point <code>(x,y)</code> in </para>
<para>a circle of radius <code>r</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Sphere(Double_t &amp;x,Double_t &amp;y,</code>
</para>
<para>
<code>       Double_t &amp;z,Double_t r)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Generate a random 3D point <code>(x,y,z)</code> in </para>
<para>a sphere of radius <code>r</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Rannor(Double_t &amp;a,Double_t &amp;b)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Generate a pair of Gaussian random</para>
<para>numbers with <code>mu=0</code> and <code>sigma=1</code></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect2>

<sect2>
<title>UNURAN</title>
<para>An interface to a new package, UNU.RAN, (Universal Non Uniform Random number generator for generating non-uniform pseudo-random numbers) was introduced in ROOT v5.16. </para>
<para>UNU.RAN is an ANSI C library licensed under GPL. It contains universal (also called automatic or black-box) algorithms that can generate random numbers from large classes of continuous (in one or multi-dimensions), discrete distributions, empirical distributions (like histograms) and also from practically all standard distributions. An extensive online documentation is available at the UNU.RAN Web Site  <uri xmlns:xlink="http://statmath.wu-wien.ac.at/unuran/">http://statmath.wu-wien.ac.at/unuran/</uri></para>
<para>The ROOT class <emphasis role="bold"><code>TUnuran</code></emphasis> is used to interface the UNURAN package. It can be used as following: </para>
<itemizedlist>
<listitem><para>With the UNU.RAN native, string API for pre-defined distributions (see UNU.RAN documentation for the allowed string values at  <uri xmlns:xlink="http://statistik.wu-wien.ac.at/unuran/doc/unuran.html">http://statistik.wu-wien.ac.at/unuran/doc/unuran.html</uri> ):</para></listitem>
</itemizedlist>
<programlisting language="c++">
TUnuran unr;
<emphasis role="italic"><code>//initialize unuran to generate normal random numbers using a "arou" method</code></emphasis>
unr.Init("normal()","method=arou");
...
<emphasis role="italic"><code>// sample distributions N times (generate N random numbers)</code></emphasis>
for (int i = 0; i&lt;N; ++i)
double x = unr.Sample();
</programlisting>
<itemizedlist>
<listitem><para>For continous 1D distribution object via the class <emphasis role="bold"><code>TUnuranContDist</code></emphasis> that can be created for example from a <emphasis role="bold"><code>TF1</code></emphasis> function providing the pdf (probability density function) . The user can optionally provide additional information via <emphasis role="bold"><code>TUnuranContDist</code></emphasis><code>::SetDomain(min,max)</code>  like the <code>domain()</code> for generating numbers in a restricted region. </para></listitem>
</itemizedlist>
<programlisting language="c++">
//1D case: create a distribution from two TF1 object pointers pdfFunc
TUnuranContDist  dist( pdfFunc);
//initialize unuran passing the distribution and a string defining the method
unr.Init(dist, "method=hinv");
// sample distribution  N times (generate N random numbers)
for (int i = 0; i &lt; N; ++i)
double x = unr.Sample();
</programlisting>
<itemizedlist>
<listitem><para>For multi-dimensional distribution via the class <emphasis role="bold"><code>TUnuranMultiContDist</code></emphasis>, which can be created from a  the multi-dimensional pdf.</para></listitem>
</itemizedlist>
<programlisting language="c++">
// Multi- dimensional case from a TF1 (TF2 or TF3) objects
TUnuranMultiContDist  dist( pdfFuncMulti);
// the recommended method for multi-dimensional function is "hitro"
unr.Init(dist,"method=hitro");
// sample distribution  N times (generate N random numbers)
double x[NDIM];
for (int i = 0; i&lt;N; ++i)
unr.SampleMulti(x);
</programlisting>
<itemizedlist>
<listitem><para>For discrete distribution via the class <emphasis role="bold"><code>TUnuranDiscrDist</code></emphasis>, which can be initialized from a <emphasis role="bold"><code>TF1</code></emphasis> or from a vector of probabilities.</para></listitem>
</itemizedlist>
<programlisting language="c++">
// Create distribution from a vector of probabilities
double pv[NSize] = {0.1,0.2,...};
TUnuranDiscrDist dist(pv,pv+NSize);
// the recommended method for discrete distribution is
unr.Init(dist, "method=dgt");
// sample N times (generate N random numbers)
for (int i = 0; i &lt; N; ++i)
int k = unr.SampleDiscr();
</programlisting>
<itemizedlist>
<listitem><para>For empirical distribution via the class <emphasis role="bold"><code>TUnuranEmpDist</code></emphasis>. In this case one can generate random numbers from a set of un-bin or bin data. In the first case the parent distribution is estimated by UNU.RAN using a gaussian kernel smoothing algorithm. The <emphasis role="bold"><code>TUnuranEmpDist</code></emphasis> distribution class can be created from a vector of data or from <emphasis role="bold"><code>TH1</code></emphasis> (using the bins or from its buffer for un-binned data).</para></listitem>
</itemizedlist>
<programlisting language="c++">
// Create distribution from a set of data
// vdata is an std::vector containing the data
TUnuranEmpDist  dist(vdata.begin(),vdata.end());
unr.Init(dist);
// sample N times (generate N random numbers)
for (int i = 0; i&lt;N; ++i)
double x = unr.Sample();
</programlisting>
<itemizedlist>
<listitem><para>For some predefined distributions, like <code>Poisson</code> and <code>Binomial</code>, one can use directly a function in the <emphasis role="bold"><code>TUnuran</code></emphasis> class. This is more convenient in passing distribution parameters than using directly the string interface.</para></listitem>
</itemizedlist>
<programlisting language="c++">
TUnuran unr;
// Initialize unuran to generate normal random numbers from the Poisson
// distribution with parameter mu
unr.InitPoisson(mu);
...
// Sample distributions N times (generate N random numbers)
for (int i = 0; i&lt;N; ++i)
int k = unr.SampleDiscr();
</programlisting>

<para>Functionality is also provided via the C++ classes for using a different random number generator by passing a TRandom pointer when constructing the <emphasis role="bold"><code>TUnuran</code></emphasis> class (by default the ROOT <emphasis role="italic"><emphasis role="bold"><code>gRandom</code></emphasis></emphasis> is passed to UNURAN).</para>
</sect2>

<sect2>
<title>Performances of Random Numbers</title>
<para>Here are the CPU times obtained using the four random classes on an lxplus machine with an Intel 64 bit architecture and compiled using gcc 3.4:</para>
<informaltable frame="all">
<tgroup cols="5">
<colspec colwidth="2269*" colname="column-1"/>
<colspec colwidth="1646*" colname="column-2"/>
<colspec colwidth="1682*" colname="column-3"/>
<colspec colwidth="1662*" colname="column-4"/>
<colspec colwidth="1672*" colname="column-5"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
</entry>
<entry rowsep="1" colsep="1">
<para><emphasis role="bold"><code>TRandom</code></emphasis>  (ns/call)</para>
</entry>
<entry rowsep="1" colsep="1">
<para><emphasis role="bold"><code>T</code></emphasis><emphasis role="bold"><code>R</code></emphasis><emphasis role="bold"><code>andom1</code></emphasis>  (ns/call)</para>
</entry>
<entry rowsep="1" colsep="1">
<para><emphasis role="bold"><code>TRandom2</code></emphasis>  (ns/call)</para>
</entry>
<entry rowsep="1" colsep="1">
<para><emphasis role="bold"><code>TRandom3</code></emphasis> (ns/call)</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Rndm()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>-</para>
</entry>
<entry rowsep="1" colsep="1">
<para>-</para>
</entry>
<entry rowsep="1" colsep="1">
<para>6</para>
</entry>
<entry rowsep="1" colsep="1">
<para>9</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Gaus</code>
<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>31</para>
</entry>
<entry rowsep="1" colsep="1">
<para>161</para>
</entry>
<entry rowsep="1" colsep="1">
<para>35</para>
</entry>
<entry rowsep="1" colsep="1">
<para>42</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>R</code>
<code>annor</code>
<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>116</para>
</entry>
<entry rowsep="1" colsep="1">
<para>216</para>
</entry>
<entry rowsep="1" colsep="1">
<para>126</para>
</entry>
<entry rowsep="1" colsep="1">
<para>130</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Poisson</code>
<code>(</code>
<code>m=10</code>
<code>)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>147</para>
</entry>
<entry rowsep="1" colsep="1">
<para>1161</para>
</entry>
<entry rowsep="1" colsep="1">
<para>162</para>
</entry>
<entry rowsep="1" colsep="1">
<para>239</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Poisson</code>
<code>(</code>
<code>m=10</code>
<code>)</code>
<code>UNURAN</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>80</para>
</entry>
<entry rowsep="1" colsep="1">
<para>294</para>
</entry>
<entry rowsep="1" colsep="1">
<para>89</para>
</entry>
<entry rowsep="1" colsep="1">
<para>99</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect2>
</sect1>

<sect1>
<title>MathCore Library</title>
<para><code>MathCore</code> provides a collection of functions and C++ classes for numerical computing. This library includes only the basic mathematical functions and algorithms and not all the functionality required by the physics community. A more advanced mathematical functionality is provided by the <code>MathMore</code> library. The current set included classes are: </para>
<itemizedlist>
<listitem><para>Basic special functions like the gamma, beta and error function. </para></listitem>
<listitem><para>Mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf's).</para></listitem>
<listitem><para><code>GenVector</code>: physics and geometry vectors for 3 and 4 dimensions with their transformations (rotations and boost).</para></listitem>
<listitem><para>Generic (<emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::IFunction)</code> and parametric (<emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::IParamFunction</code>) function interfaces for one and multi dimensions.</para></listitem>
</itemizedlist>
<para>A detailed description for all <code>MathCore</code> classes is available in the  <uri xmlns:xlink="http://seal.web.cern.ch/seal/MathLibs/MathCore/html/index.html">online reference documentation</uri>. The         <code>MathCore</code> library presented in the ROOT distribution contains the CINT dictionary for I/O and interactive usage. For the template classes, the dictionary is provided for some of the possible types, such as those based on double and Double32_t. For the I/O or interactive use of other types, the dictionary must be first generated. An example on how to generate the required dictionary is provided in the tutorial <code>mathcoreVectorFloatIO.C</code> (in <code>$ROOTSYS/tutorials/math</code>). <code>MathCore</code> can also be built as an independent package using <code>configure/make</code>. In this case the library will not contain the dictionary information and cannot be used interactively in ROOT. </para>
</sect1>

<sect1>
<title>Generic Vectors for 2, 3 and 4 Dimensions (GenVector)</title>
<para><code>GenVector</code> is a package intended to represent vectors and their operations and transformations, such as rotations and Lorentz transformations, in 3 and 4 dimensions. The 3D space is used to describe the geometry vectors and points, while the 4D space-time is used for physics vectors representing relativistic particles. These 3D and 4D vectors are different from vectors of the linear algebra package, which describe generic N-dimensional vectors. Similar functionality is currently provided by the CLHEP  <uri xmlns:xlink="http://proj-clhep.web.cern.ch/proj-clhep/manual/UserGuide/VectorDefs/index.html">Vector</uri> and  <uri xmlns:xlink="http://www.hep.phy.cam.ac.uk/lhcb/doc/CLHEP/1.9.1.2/html/namespaceHepGeom.html">Geometry</uri> packages and the ROOT Physics vector classes (See “Physics Vectors”). It also re-uses concepts and ideas from the CMS  <uri xmlns:xlink="http://lcgapp.cern.ch/doxygen/SEAL/snapshot/html/dir_000007.html">Common Vector package</uri>. In contrast to CLHEP or the ROOT physics libraries, <code>GenVector</code> provides class templates for modeling the vectors. The user can control how the vector is internally represented. This is expressed by a choice of coordinate system, which is supplied as a template parameter when the vector is constructed. Furthermore, each coordinate system is itself a template, so that the user can specify the underlying scalar type. </para>
<para>The <code>GenVector</code> classes do not inherit from <emphasis role="bold"><code>TObject</code></emphasis>, therefore cannot be used as in the case of the physics vector classes in ROOT collections. </para>
<para>In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of <code>GenVector</code> are described. A more detailed description of all the <code>GenVector</code> classes is available also at  <uri xmlns:xlink="http://seal.cern.ch/documents/mathlib/GenVector.pdf">http://seal.cern.ch/documents/mathlib/GenVector.pdf</uri></para>

<sect2>
<title>Main Characteristics</title>

<sect3>
<title>Optimal Runtime Performances</title>
<para>We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the <code>GenVector</code> concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the <code>GenVector</code> classes polymorphically and developing classes inheriting from them.</para>
</sect3>

<sect3>
<title>Points and Vector Concept</title>
<para>Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points rotate and translate. You can add two vectors but not two points and the difference between two points is a vector. We then distinguish for the 3 dimensional case, between points and vectors, modeling them with different classes: </para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>DisplacementVector2</code></emphasis><emphasis role="bold"><code>D</code></emphasis>         and         <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>DisplacementVector3D</code></emphasis> template classes describing 2 and 3 component direction and magnitude vectors, not rooted at any particular point;</para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>PositionVector2</code></emphasis><emphasis role="bold"><code>D</code></emphasis> and <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>PositionVector3D</code></emphasis> template classes modeling the points in 2 and 3 dimensions. </para></listitem>
</itemizedlist>
<para>For the 4D space-time vectors, we use the same class to model them, <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>LorentzVector</code></emphasis>, since we have recognized a limited need for modeling the functionality of a 4D point. </para>
</sect3>

<sect3>
<title>Generic Coordinate System</title>
<para>The vector classes are based on a generic type of coordinate system, expressed as a template parameter of the class. Various classes exist to describe the various coordinates systems: </para>
<para>2D coordinate system classes: </para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math::Cartesian2D</code></emphasis>, based on (<code>x,y</code>);</para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::Polar2D</code></emphasis>, based on (<code>r,phi</code>);</para></listitem>
</itemizedlist>
<para>3D coordinate system classes: </para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math::Cartesian3D</code></emphasis>, based on (<code>x,y,z</code>);</para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::Polar3D</code></emphasis>, based on (<code>r,theta,phi</code>); </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::Cylindrical3D</code></emphasis>, based on (<code>rho,z,phi</code>)</para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::CylindricalEta3D</code></emphasis>, based on (<code>rho,eta,phi</code>), where <code>eta</code> is the pseudo-rapidity;</para></listitem>
</itemizedlist>
<para>4D coordinate system classes: </para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math::PxPyPzE4D</code></emphasis>, based on based on (<code>px,py,pz,E</code>);</para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::PxPyPzM4D</code></emphasis>, based on based on (<code>px,py,pz,M</code>);</para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::PtEtaPhiE4D</code></emphasis>, based on based on (<code>pt,eta,phi,E</code>);</para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::PtEtaPhiM4D</code></emphasis>, based on based on (<code>pt,eta,phi,M</code>);</para></listitem>
</itemizedlist>
<para>Users can define the vectors according to the coordinate type, which is the most efficient for their use. Transformations between the various coordinate systems are available through copy constructors or the assignment (=) operator. For maximum flexibility and minimize memory allocation, the coordinate system classes are templated on the scalar type. To avoid exposing templated parameter to the users, typedefs are defined for all types of vectors based on doubles. See in the examples for all the possible types of vector classes, which can be constructed by users with the available coordinate system types. </para>
</sect3>

<sect3>
<title>Coordinate System Tag</title>
<para>The 2D and 3D points and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the <emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>DisplacementVector3D</code> and <emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>PositionVector3D</code> (and also for 2D classes). A default tag exists for users who do not need this functionality, <emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>DefaultCoordinateSystemTag</code>.</para>
</sect3>

<sect3>
<title>Transformations</title>
<para>The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in rotations (in 3 dimensions), Lorentz transformations and Poincare transformations, which are translation<code>/</code>rotation combinations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors by using the operator <code>() </code>or the operator <code>*</code> and the transformations can be combined via the operator <code>*</code>. The available transformations are: </para>
<para>▪ 3D rotation classes</para>
<itemizedlist>
<listitem><para>rotation described by a 3x3 matrix (<emphasis role="bold"><code>ROOT::Math::Rotation3D</code></emphasis>)</para></listitem>
<listitem><para>rotation described by Euler angles (<emphasis role="bold"><code>ROOT::Math::EulerAngles</code></emphasis>)</para></listitem>
<listitem><para>rotation described by a direction axis and an angle (<emphasis role="bold"><code>ROOT::Math::AxisAngle</code></emphasis>)</para></listitem>
<listitem><para>rotation described by a quaternion (<emphasis role="bold"><code>ROOT::Math::Quaternion</code></emphasis>) </para></listitem>
<listitem><para>optimized rotation around <code>x</code> (<emphasis role="bold"><code>ROOT::Math::RotationX</code></emphasis>), <code>y</code> (<emphasis role="bold"><code>ROOT::Math::RotationY</code></emphasis>) and <code>z</code> (<emphasis role="bold"><code>ROOT::Math::RotationZ</code></emphasis>) and described by just one angle. </para></listitem>
</itemizedlist>
<para>▪ 3D transformation: we describe the transformations defined as a composition between a rotation and a translation using the class <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>Transform3D</code></emphasis>. It is important to note that transformations act differently on vectors and points. The vectors only rotate, therefore when applying a transformation (rotation + translation) on a vector, only the rotation operates while the translation has no effect. The <emphasis role="bold"><code>Transform3D</code></emphasis> class interface is similar to the one used in the CLHEP Geometry package (class  <uri xmlns:xlink="http://www.hep.phy.cam.ac.uk/lhcb/doc/CLHEP/1.9.1.2/html/classHepGeom_1_1Transform3D.html">HepGeom::Transform3D</uri>). </para>
<para>▪ Lorentz rotation:</para>
<itemizedlist>
<listitem><para>generic Lorentz rotation described by a <code>4x4</code> matrix containing a 3D rotation part and a boost part (class <emphasis role="bold"><code>ROOT::Math::LorentzRotation</code></emphasis>)</para></listitem>
<listitem><para>a pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class <emphasis role="bold"><code>ROOT::Math::Boost</code></emphasis>)</para></listitem>
<listitem><para>boost along the axis:<code> x </code>(<emphasis role="bold"><code>ROOT::Math::BoostX</code></emphasis>), <code>y </code>(<emphasis role="bold"><code>ROOT::Math::BoostY</code></emphasis>) and <code>z </code>(<emphasis role="bold"><code>ROOT::Math::BoostZ</code></emphasis>). </para></listitem>
</itemizedlist>
<para/>
</sect3>

<sect3>
<title>Minimal Vector Classes Interface</title>
<para>We have tried to keep the interface to a minimal level by:</para>
<itemizedlist>
<listitem><para>Avoiding methods that provide the same functionality but use different names (like <code>getX()</code> and <code>x()</code>). </para></listitem>
<listitem><para>Minimizing the number of setter methods, avoiding methods, which can be ambiguous and can set the vector classes in an inconsistent state. We provide only methods which set all the coordinates at the same time or set only the coordinates on which the vector is based, for example <code>SetX()</code> for a Cartesian vector. We then enforce the use of transformations as rotations or translations (additions) for modifying the vector contents. </para></listitem>
<listitem><para>The majority of the functionality, which is present in the CLHEP package, involving operations on two vectors, is moved in separated helper functions (see <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::VectorUtil</code>). This has the advantage that the basic interface will remain more stable with time while additional functions can be added easily. </para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Naming Convention</title>
<para>As part of ROOT, the <code>GenVector</code> package adheres to the prescribed ROOT naming convention, with some (approved) exceptions, as described here: </para>
<itemizedlist>
<listitem><para>Every class and function is in the <emphasis role="bold"><code>ROOT::Math</code></emphasis> namespace.</para></listitem>
<listitem><para>Member function names start with upper-case letter, apart some exceptions (see the next section about CLHEP compatibility). </para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Compatibility with CLHEP Vector Classes</title>
<itemizedlist>
<listitem><para>For backward compatibility with CLHEP the vector classes can be constructed from a CLHEP <code>HepVector</code> or <emphasis role="bold"><code>HepLorentzVector</code></emphasis>, by using a template constructor, which requires only that the classes implement the accessors<code> x()</code>, <code>y()</code>, and <code>z()</code> (and <code>t()</code> for the 4D). </para></listitem>
<listitem><para>We provide vector member function with the same naming convention as CLHEP for the most used functions like <code>x()</code>, <code>y()</code> and <code>z()</code>.</para></listitem>
</itemizedlist>
</sect3>

<sect3>
<title>Connection to Linear Algebra Package</title>
<para>In some use cases, like in track reconstruction, it is needed to use the content of the vector and rotation classes in conjunction with linear algebra operations. We prefer to avoid any direct dependency to any linear algebra package. However, we provide some hooks to convert to and from linear algebra classes. The vector and the transformation classes have methods which allow to get and set their data members (like <code>SetCoordinates</code> and <code>GetCoordinates</code>) passing either a generic iterator or a pointer to a contiguous set of data, like a C array. This allows an easy connection with the linear algebra package, which in turn, allows creation of matrices using C arrays (like the ROOT <emphasis role="bold"><code>TMatrix</code></emphasis> classes) or iterators (<code>SMatrix</code> classes). Multiplication between linear algebra matrices and <code>GenVector</code> vectors is possible by using the template free functions <emphasis role="bold"><code>ROOT::Math::VectorUtil</code></emphasis><code>::Mult</code>. This function works for any linear algebra matrix, which implements the operator (<code>i,j</code>) and with first matrix element at <code>i=j=0</code>. </para>
</sect3>
</sect2>

<sect2>
<title>Example: 3D Vector Classes</title>
<para>To avoid exposing template parameter to the users, typedef's are defined for all types of vectors based on double's and float's. To use them, one must include the header file <code>Math/Vector3D.h</code>. The following typedef's, defined in the header file <code>Math/Vector3Dfwd.h</code>, are available for the different instantiations of the template class <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>DisplacementVector3D</code></emphasis>: </para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>XYZVector</code></emphasis> vector based on <code>x,y,z</code> coordinates (Cartesian) in double precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>XYZVectorF</code></emphasis> vector based on <code>x,y,z</code> coordinates (Cartesian) in float precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>Polar3DVector</code></emphasis> vector based on <code>r,theta,phi</code> coordinates (polar) in double precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>Polar3DVectorF</code></emphasis> vector based on <code>r,theta,phi</code> coordinates (polar) in float precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>RhoZPhiVector</code></emphasis> vector based on <code>rho,z,phi</code> coordinates (cylindrical) in double precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>RhoZPhiVectorF</code></emphasis> vector based on <code>rho,z,phi</code> coordinates (cylindrical) in float precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>RhoEtaPhiVector</code></emphasis> vector based on <code>rho,eta,phi</code> coordinates (cylindrical using <code>eta</code> instead of <code>z</code>) in double precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>RhoEtaPhiVectorF</code></emphasis> vector based on <code>rho,eta,phi</code> coordinates (cylindrical using <code>eta</code> instead of <code>z</code>) in float precision </para></listitem>
</itemizedlist>
<sect3>
<title>Constructors and Assignment</title>
<para>The following declarations are available: </para>

<programlisting language="c++">
XYZVector       v1;             <emphasis role="italic"><code>//an empty vector (x=0, y=0, z=0)</code></emphasis>
XYZVector       v2(1,2,3);      <emphasis role="italic"><code>//vector with x=1, y=2, z=3;</code></emphasis>
Polar3DVector   v3(1,PI/2,PI);  <emphasis role="italic"><code>//vector with r=1, theta=PI/2, phi=PI</code></emphasis>
RhoEtaPHiVector v4(1,2, PI);    <emphasis role="italic"><code>//vector with rho=1, eta=2, phi=PI</code></emphasis>
</programlisting>

<para>Note that each vector type is constructed by passing its coordinate representation, so a <emphasis role="bold"><code>XYZVector</code></emphasis><code>(1,2,3)</code> is different from a <emphasis role="bold"><code>Polar3DVector</code></emphasis><code>(1,2,3)</code>. In addition, the vector classes can be constructed by any vector, which implements the accessors <code>x()</code>, <code>y()</code> and <code>z()</code>. This can be another 3D vector based on a different coordinate system type. It can be even any vector of a different package, like the CLHEP <emphasis role="bold"><code>HepThreeVector</code></emphasis> that implements the required signature. </para>

<programlisting language="c++">
XYZVector    v1(1,2,3);
RhoEtaPhiVector    r2(v1);
CLHEP::HepThreeVector  q(1,2,3);
XYZVector    v3(q);
</programlisting>

</sect3>

<sect3>
<title>Coordinate Accessors</title>
<para>All coordinate accessors are available through the class <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>DisplacementVector3D</code></emphasis>: </para>

<programlisting language="c++">
<emphasis role="italic"><code>//returns cartesian components for the cartesian vector v1</code></emphasis>
v1.X(); v1.Y(); v1.Z();
<emphasis role="italic"><code>//returns cylindrical components for the cartesian vector v1</code></emphasis>
v1.Rho(); v1.Eta(); v1.Phi();
<emphasis role="italic"><code>//returns cartesian components for the cylindrical vector r2               </code></emphasis>
r2.X(); r2.Y(); r2.Z()
</programlisting>

<para>In addition, all the 3 coordinates of the vector can be retrieved with the <code>GetCoordinates</code> method: </para>

<programlisting language="c++">
double d[3];
v1.GetCoordinates(d);       <emphasis role="italic"><code>/</code></emphasis><emphasis role="italic"><code>/</code></emphasis><emphasis role="italic"><code>fill d array with (x,y,z) components of v1</code></emphasis>
r2.GetCoordinates(d);       <emphasis role="italic"><code>//fill d array with (r,eta,phi) components of r2</code></emphasis>
std::vector vc(3);
<emphasis role="italic"><code>//fill std::vector with (x,y,z) components of v1</code></emphasis>
v1.GetCoordinates(vc.begin(),vc.end());
</programlisting>

<para>See the reference documentation of <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>DisplacementVector3D</code></emphasis> for more details on all the coordinate accessors. </para>
</sect3>

<sect3>
<title>Setter Methods</title>
<para>One can set only all the three coordinates via: </para>

<programlisting language="c++">
v1.SetCoordinates(c1,c2,c3);  <emphasis role="italic"><code>//sets the (x,y,z) for a XYZVector</code></emphasis>
r2.SetCoordinates(c1,c2,c3);  <emphasis role="italic"><code>//sets r,theta,phi for a Polar3DVector</code></emphasis>
r2.SetXYZ(x,y,z);             <emphasis role="italic"><code>//sets the 3 cartesian components for Polar3DVector</code></emphasis>
</programlisting>

<para>Single coordinate setter methods are available for the basic vector coordinates, like <code>SetX()</code> for a         <emphasis role="bold"><code>XYZVector</code></emphasis> or <code>SetR()</code> for a polar vector. Attempting to do a <code>SetX()</code> on a polar vector will not compile. </para>

<programlisting language="c++">
XYZVector v1;      v1.SetX(1);   <emphasis role="italic"><code>//OK setting x for a Cartesian vector</code></emphasis>
Polar3DVector v2;  v2.SetX(1);   <emphasis role="italic"><code>//ERROR: cannot set X for a Polar vector.</code></emphasis>
<emphasis role="italic"><code>//Method will not compile</code></emphasis>
v2.SetR(1);                      <emphasis role="italic"><code>//OK setting r for a Polar vector</code></emphasis>
</programlisting>

<para>In addition, there are setter methods from C arrays or iterator </para>

<programlisting language="c++">
double d[3] = {1.,2.,3.};
XYZVector v;
v.SetCoordinates(d);            <emphasis role="italic"><code>//set (x,y,z) components of v using values from d</code></emphasis>
</programlisting>

<para>or, for example, from an <code>std::vector</code> using the iterator </para>

<programlisting language="c++">
std::vector w(3);
<emphasis role="italic"><code>// set (x,y,z) components of v using values from w</code></emphasis>
v.SetCoordinates(w.begin(),w.end());
</programlisting>

</sect3>

<sect3>
<title>Arithmetic Operations</title>
<para>The following operations are possible between vector classes, even of different coordinate system types: (<code>v1,v2</code> are any type of <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>DisplacementVector3D</code></emphasis> classes, <code>v3</code> is the same type of <code>v1</code>; <code>a</code> is a scalar value) </para>

<programlisting language="c++">
v1 += v2;
v1 -= v2;
v1 = - v2;
v1 *= a;
v1 /= a;
v2 = a * v1;
v2 = v1 / a;
v2 = v1 * a;
v3 = v1 + v2;
v3 = v1 - v2;
</programlisting>

</sect3>

<sect3>
<title>Comparison</title>
<para>For <code>v1</code> and <code>v2</code> of the same type (same coordinate system and same scalar type): </para>

<programlisting language="c++">
v1 == v2;
v1 != v2;
</programlisting>

</sect3>

<sect3>
<title>Dot and Cross Product</title>
<para>We support the dot and cross products, through the <code>Dot()</code> and <code>Cross()</code> method, with any vector (<code>q</code>) implementing <code>x()</code>, <code>y()</code> and <code>z()</code>. </para>

<programlisting language="c++">
XYZVector v1(x,y,z);
double s = v1.Dot(q);
XYZVector v2 = v1.Cross(q);
</programlisting>

<para>Note that the multiplication between two vectors using the operator <code>*</code> is not supported because it is ambiguous. </para>
</sect3>

<sect3>
<title>Other Methods</title>

<programlisting language="c++">
XYZVector u = v1.Unit();               <emphasis role="italic"><code>//return unit vector parallel to v1</code></emphasis>
</programlisting>

</sect3>
</sect2>

<sect2>
<title>Example: 3D Point Classes</title>
<para>To use all possible types of 3D points one must include the header file <code>Math/Point3D.h</code>. The following typedef’s defined in the header file <code>Math/Point3Dfwd.h</code>, are available for different instantiations of the template class <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>PositionVector3D</code></emphasis>: </para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>XYZPoint</code></emphasis> point based on <code>x</code>, <code>y</code>, <code>z</code> coordinates (Cartesian) in double precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>XYZPointF</code></emphasis> point based on <code>x</code>, <code>y</code>, <code>z</code> coordinates (Cartesian) in float precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>Polar3DPoint</code></emphasis> point based on <code>r</code>, <code>theta</code>, <code>phi</code> coordinates (polar) in double precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>Polar3DPointF</code></emphasis> point based on <code>r</code>, <code>theta</code>, <code>phi</code> coordinates (polar) in float precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>RhoZPhiPoint</code></emphasis> point based on <code>rho</code>, <code>z</code>, <code>phi</code> coordinates (cylindrical using <code>z</code>) in double precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>RhoZPhiPointF</code></emphasis> point based on <code>rho</code>, <code>z</code>, <code>phi</code> coordinates (cylindrical using <code>z</code>) in float precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>RhoEtaPhiPoint</code></emphasis> point based on <code>rho</code>, <code>eta</code>, <code>phi</code> coordinates (cylindrical using eta instead of <code>z</code>) in double precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>RhoEtaPhiPointF</code></emphasis> point based on <code>rho</code>, <code>eta</code>, <code>phi</code> coordinates (cylindrical using eta instead of <code>z</code>) in float precision </para></listitem>
</itemizedlist>
<sect3>
<title>Constructors and Assignment</title>
<para>The following declarations are available: </para>

<programlisting language="c++">
XYZPoint         p1;             <emphasis role="italic"><code>//an empty vector (x=0, y=0, z=0)</code></emphasis>
XYZPoint         p2(1,2,3);      <emphasis role="italic"><code>/</code></emphasis><emphasis role="italic"><code>/</code></emphasis><emphasis role="italic"><code>vector with x=1, y=2, z=3;</code></emphasis>
Polar3DPoint     p3(1,PI/2,PI);  <emphasis role="italic"><code>//vector with r=1, theta=PI/2, phi=PI</code></emphasis>
RhoEtaPHiPoint   p4(1,2,PI);     <emphasis role="italic"><code>//vector with rho=1, eta=2, phi=PI</code></emphasis>
</programlisting>

<para>Note that each point type is constructed by passing its coordinate representation, so a <emphasis role="bold"><code>XYZPoint</code></emphasis><code>(1,2,3)</code> is different from a         <emphasis role="bold"><code>Polar3DPoint</code></emphasis><code>(1,2,3)</code>. In addition the point classes can be constructed by any vector, which implements the accessors <code>x()</code>, <code>y()</code> and <code>z()</code>. This can be another 3D point based on a different coordinate system type or even any vector of a different package, like the CLHEP <emphasis role="bold"><code>HepThreePoint</code></emphasis> that implements the required signatures. </para>

<programlisting language="c++">
XYZPoint             p1(1,2,3);
RhoEtaPHiPoint       r2(v1);
CLHEP::HepThreePoint q(1,2,3);
XYZPoint             p3(q);
</programlisting>

</sect3>

<sect3>
<title>Coordinate Accessors and Setter Methods</title>
<para>For the points classes we have the same getter and setter methods as for the vector classes. See “Example: 3D Vector Classes”.</para>
</sect3>

<sect3>
<title>Point-Vector Operations</title>
<para>The following operations are possible between points and vector classes: (<code>p1</code>, <code>p2</code> and <code>p3</code> are instantiations of the <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>PositionVector3D</code></emphasis> objects with <code>p1</code> and <code>p3</code> of the same type; <code>v1</code> and <code>v2</code> are  <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>DisplacementVector3D</code></emphasis> objects).</para>

<programlisting language="c++">
p1 += v1;
p1 -= v1;
p3 = p1 + v1;    <emphasis role="italic"><code>//p1 and p3 are the same type </code></emphasis>
p3 = v1 + p1;    <emphasis role="italic"><code>//p3 is based on the same coordinate system as v1</code></emphasis>
p3 = p1 - v1;
p3 = v1 - p1;
v2 = p1 - p2;    <emphasis role="italic"><code>//difference between points returns a vector v2 based on the</code></emphasis>
<emphasis role="italic"><code>//same coordinate system as p1</code></emphasis>
</programlisting>

<para>Note that the addition between two points is <emphasis role="bold">NOT</emphasis> possible and the difference between points returns a vector. </para>
</sect3>

<sect3>
<title>Other Operations</title>
<para>Exactly as for the 3D Vectors, the following operations are allowed: </para>
<itemizedlist>
<listitem><para>comparison of points</para></listitem>
<listitem><para>scaling and division of points with a scalar</para></listitem>
<listitem><para>dot and cross product with any type of vector</para></listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2>
<title>Example: LorentzVector Classes</title>
<para>As in the 3D case, typedef’s are defined for user convenience. and can be used by including the header file <code>Math/Vector4D.h</code>. The following typedef's, defined in the header file <code>Math/Vector4Dfwd.h</code>, are available for the different instantiations of the template class <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>LorentzVector</code></emphasis>: </para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>XYZTVector</code></emphasis> vector based on <code>x</code>, <code>y</code>, <code>z</code>, <code>t</code> coordinates (Cartesian) in double precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>XYZTVectorF</code></emphasis> vector based on <code>x</code>, <code>y</code>, <code>z</code>, <code>t</code> coordinates (Cartesian) in float precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>PtEtaPhiEVector</code></emphasis> vector based on <code>pt(rho)</code>, <code>eta</code>, <code>phi</code> and <code>E(t)</code> coordinates in double precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>PtEtaPhiMVector</code></emphasis> vector based on <code>pt(rho)</code>, <code>eta</code>, <code>phi</code> and <code>M(t)</code> coordinates in double precision </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>PxPyPzMVector</code></emphasis> vector based on <code>px</code>, <code>py</code>, <code>pz</code> and <code>M(mass)</code> coordinates in double precision </para></listitem>
</itemizedlist>
<para>The metric used for all the LorentzVector is (<code>-,-,-,+</code>) .</para>

<sect3>
<title>Constructors and Assignment</title>
<para>The following declarations are available: </para>

<programlisting language="c++">
XYZTVector      v1;               <emphasis role="italic"><code>//create an empty vector (x=0, y=0, z=0, t=0) </code></emphasis>
XYZTVector      v2(1,2,3,4);      <emphasis role="italic"><code>//vector with x=1, y=2, z=3, t=4</code></emphasis>
PtEtaPhiEVector v3(1,2,PI,5);     <emphasis role="italic"><code>//</code></emphasis><emphasis role="italic"><code>vector with pt=1, eta=2, phi=PI, E=5</code></emphasis>
</programlisting>

<para>Note that each type of vector is constructed by passing its coordinate representation, so a <emphasis role="bold"><code>XYZTVector</code></emphasis><code>(1,2,3,4)</code> is different from a <emphasis role="bold"><code>PtEtaPhiEVector</code></emphasis><code>(1,2,3,4)</code>. In addition, the Vector classes can be constructed by any vector, which implements the accessors <code>x()</code>, <code>y()</code>, <code>z()</code> and <code>t()</code>. </para>
<para>This can be another <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>LorentzVector</code></emphasis> based on a different coordinate system or any vector of a different package, like the CLHEP <emphasis role="bold"><code>HepLorentzVector</code></emphasis> that implements the required signature. </para>

<programlisting language="c++">
<code>XYZTVector              v1(1,2,3,4); </code>
<code>PtEtaPhiEVector         v2(v1);</code>
CLHEP::HepLorentzVector q(1,2,3,4);
XYZTVector              v3(q);
</programlisting>

</sect3>

<sect3>
<title>Coordinate Accessors</title>
<para>All the same coordinate accessors are available through the interface of <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>LorentzVector</code></emphasis>. For example: </para>

<programlisting language="c++">
<emphasis role="italic"><code>//returns cartesian components for the cartesian vector v1</code></emphasis>
v1.X(); v1.X(); v1.Z(); v1.T();
<emphasis role="italic"><code>//returns cartesian components for the cylindrical vector v2</code></emphasis>
v2.Px(); v2.Py(); v2.Pz(); v2.E();
<emphasis role="italic"><code>//returns other components for the cartesian vector v1</code></emphasis>
v1.Pt(); v1.Eta(); v1.Phi(); v1.M()
</programlisting>

<para>In addition, all 4 vector coordinates can be retrieved with the <code>GetCoordinates</code> method: </para>

<programlisting language="c++">
double d[4];
v1.GetCoordinates(d);        <emphasis role="italic"><code>//fill d array with (x,y,z,t) components of v1</code></emphasis>
v2.GetCoordinates(d);        <emphasis role="italic"><code>//fill d array with (pt,eta,phi,e) components of v2</code></emphasis>
std::vector w(4);
v1.GetCoordinates(w.begin(),w.end()); <emphasis role="italic"><code>//fill std::vector with (x,y,z,t)</code></emphasis>
<emphasis role="italic"><code>//components of v1</code></emphasis>
</programlisting>

<para>To get information on all the coordinate accessors see the <emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>LorentzVector</code></emphasis> reference documentation. </para>
</sect3>

<sect3>
<title>Setter Methods</title>
<para>One can set only all the three coordinates via: </para>

<programlisting language="c++">
v1.SetCoordinates(c1,c2,c3,c4);  <emphasis role="italic"><code>//sets the (x,y,z,t) for a XYZTVector</code></emphasis>
v2.SetCoordinates(c1,c2,c3,c4);  <emphasis role="italic"><code>//sets pt,eta,phi,e for a PtEtaPhiEVector</code></emphasis>
v2.SetXYZ(x,y,z,t);              <emphasis role="italic"><code>//sets cartesian components for PtEtaPhiEVector</code></emphasis>
</programlisting>

<para>Single coordinate setter methods are available for the basic vector coordinates, like <code>SetX()</code> for a <code>XYZTVector</code> or <code>SetPt()</code> for a <emphasis role="bold"><code>PtEtaPhiEVector</code></emphasis>. Attempting to do a <code>SetX()</code> on a non-Cartesian vector will not compile. </para>

<programlisting language="c++">
XYZTVector      v1; v1.SetX(1);  <emphasis role="italic"><code>//OK setting x for a cartesian vector</code></emphasis>
PtEtaPhiEVector v2; v2.SetX(1);  <code>//ERROR: cannot set X for a non-cartesian </code>
<emphasis role="italic"><code>//vector. Method will not compile</code></emphasis><emphasis role="italic"><code>.</code></emphasis>
v2.SetR(1)                       <emphasis role="italic"><code>// OK setting Pt for a  PtEtaPhiEVector vector</code></emphasis>
</programlisting>

<para>In addition, there are setter methods from C arrays or iterators. </para>

<programlisting language="c++">
double d[4] = {1.,2.,3.,4.};
XYZTVector v;
v.SetCoordinates(d);         <emphasis role="italic"><code>//set (x,y,z,t) components of v using values from d</code></emphasis>
</programlisting>

<para>or for example from an <code>std::vector </code>using the iterators </para>

<programlisting language="c++">
std::vector w(4);
<emphasis role="italic"><code>//set (x,y,z,t) components of v using values from w</code></emphasis>
v.SetCoordinates(w.begin(),w.end());
</programlisting>

</sect3>

<sect3>
<title>Arithmetic Operations</title>
<para>The following operations are possible between Lorentz vectors classes, even of different coordinate system types: (<code>v</code> and<code> w</code> are two Lorentz vector of the same type, <code>q </code>is a generic Lorentz vector implementing <code>x()</code>, <code>y()</code>, <code>z()</code> and <code>t()</code>, and <code>a</code> is a generic scalar type: double, float, int, etc.) .</para>

<programlisting language="c++">
v += q;
v -= q;
v  = -q;
v *= a;
v /= a;
w = v + q;
w = v - q;
w = v * a;
w = a * v;
w = v / a;
</programlisting>

</sect3>

<sect3>
<title>Comparison</title>

<programlisting language="c++">
v == w;
v != w;
</programlisting>

</sect3>

<sect3>
<title>Other Methods</title>

<programlisting language="c++">
a =  v.Dot(q);               <emphasis role="italic"><code>//dot product in metric(+,+,+,-) of 2 LorentzVectors</code></emphasis>
XYZVector s = v.Vect()       <emphasis role="italic"><code>//return the spatial components (x,y,z)</code></emphasis>
v.Beta();                    <emphasis role="italic"><code>//return beta and gamma value (vector must</code></emphasis>
v.Gamma()                    <emphasis role="italic"><code>// be time-like otherwise result is meaningless)</code></emphasis>
XYZVector b = v.BoostToCM(); <emphasis role="italic"><code>//return boost vector which will bring the Vector</code></emphasis>
<emphasis role="italic"><code>//in its mas frame (P=0)</code></emphasis>
</programlisting>

</sect3>
</sect2>

<sect2>
<title>Example: Vector Transformations</title>
<para>Transformation classes are grouped in rotations (in three dimensions), Lorentz transformations and Poincarre transformations, which are translation<code>/</code>rotation combinations. Each group has several members which may model physically equivalent transformations but with different internal representations. All the classes are non-template and use double precision as the scalar type. The following types of transformation classes are defined: </para>
<para>3D rotations: </para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>Rotation3D</code></emphasis>, rotation described by a 3x3 matrix of doubles </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>EulerAngles</code></emphasis> rotation described by the three Euler angles (<code>phi</code>, <code>theta</code> and <code>psi</code>) following the  <uri xmlns:xlink="http://mathworld.wolfram.com/EulerAngles.html">GoldStein definition</uri>. </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::RotationZYX</code></emphasis> rotation described by three angles defining a rotation first along the <code>Z</code> axis, then along the rotated <code>Y'</code> axis and then along the rotated <code>X''</code> axis.</para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>AxisAngle</code></emphasis>, rotation described by a vector (axis) and an angle </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>Quaternion</code></emphasis>, rotation described by a quaternion (4 numbers) </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>RotationX</code></emphasis>, specialized rotation along the X axis </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>RotationY</code></emphasis>, specialized rotation along the Y axis </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>RotationZ</code></emphasis>, specialized rotation along the Z axis </para></listitem>
</itemizedlist>
<para>3D transformations (rotations + translations) </para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>Transform3D</code></emphasis>, (rotations and then translation) described by a 3x4 matrix (12 double numbers) </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::Translation3D</code></emphasis> (only translation) described by a 3D Vector</para></listitem>
</itemizedlist>
<para>Lorentz rotations and boosts </para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>LorentzRotation</code></emphasis>, 4D rotation (3D rotation plus a boost) described by a 4x4 matrix </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>Boost</code></emphasis>, a Lorentz boost in an arbitrary direction and described by a 4x4 symmetrix matrix (10 numbers) </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>BoostX</code></emphasis>, a boost in the X axis direction </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>BoostY</code></emphasis>, a boost in the Y axis direction </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::</code><emphasis role="bold"><code>BoostZ</code></emphasis>, a boost in the Z axis direction </para></listitem>
</itemizedlist>
<sect3>
<title>Constructors</title>
<para>All rotations and transformations are default constructible (giving the identity transformation). All rotations are constructible taking a number of scalar arguments matching the number (and order of components).</para>

<programlisting language="c++">
Rotation3D  rI;                 <emphasis role="italic"><code>//a summy rotation (Identity matrix)</code></emphasis>
RotationX   rX(PI);             <emphasis role="italic"><code>//a RotationX with an angle PI</code></emphasis>
EulerAngles rE(phi,theta,psi);  <emphasis role="italic"><code>//an Euler rotation with phi,theta,psi angles</code></emphasis>
XYZVector   u(ux,uy,uz);
AxisAngle   rA(u,delta);        <emphasis role="italic"><code>//a rotation based on direction u, angle delta</code></emphasis>
</programlisting>

<para>In addition, all rotations and transformations (other than the axial rotations) and transformations are constructible from (<code>begin</code>,<code>end</code>) iterators or from pointers behave like iterators. </para>

<programlisting language="c++">
double      data[9];
Rotation3D  r(data,data+9);       <emphasis role="italic"><code>//create a rotation from a rotation matrix</code></emphasis>
std::vector w(12);
Transform3D t(w.begin(),w.end()); <emphasis role="italic"><code>//create Transform3D from std::vector content</code></emphasis>
</programlisting>

<para>All rotations, except the axial rotations, are constructible and assigned from any other type of rotation (including the axial):</para>
<para/>

<programlisting language="c++">
<emphasis role="italic"><code>//create a rotation 3D from a rotation along X axis of angle PI</code></emphasis>
Rotation3D  r(ROOT::Math::RotationX(PI));

<emphasis role="italic"><code>//construct an Euler rotation from A Rotation3D</code></emphasis>
EulerAngles r2(r);

<emphasis role="italic"><code>//assign an Axis rotation from an Euler Rotation</code></emphasis>
AxisAngle   r3; r3 = r2;
</programlisting>

<para><emphasis role="bold"><code>Transform3D</code></emphasis> (rotation + translation) can be constructed from a rotation and a translation vector:</para>

<programlisting language="c++">
Rotation3D  r;
XYZVector   v;
Transform3D t1(r,v);   <emphasis role="italic"><code>//construct from rotation and then translation</code></emphasis>
Transform3D t2(v,r);   <emphasis role="italic"><code>//construct inverse from first translation then rotation</code></emphasis>
Transform3D t3(r);     <emphasis role="italic"><code>//construct from only a rotation (zero translation)</code></emphasis>
Transform3D t4(v);     <emphasis role="italic"><code>//construct from only translation (identity rotation)</code></emphasis>
</programlisting>

</sect3>

<sect3>
<title>Operations</title>
<para>All transformations can be applied to vector and points using the operator * or using the operator() </para>

<programlisting language="c++">
XYZVector  v1(...);
Rotation3D r(...);
XYZVector  v2 = r*v1;       <emphasis role="italic"><code>//rotate vector v1 using r</code></emphasis>
v2 = r(v1);                 <emphasis role="italic"><code>//equivalent</code></emphasis>
</programlisting>

<para>Transformations can be combined using the operator <code>*</code>. Rotation, translation and <emphasis role="bold"><code>Transform3D</code></emphasis> classes can be all combined with the operator *. The result of a combination of a rotation and a translation will be a <emphasis role="bold"><code>Transform3D</code></emphasis> class. Note that the rotations are not commutative, the order is then important.</para>

<programlisting language="c++">
Rotation3D  r1(...);
Rotation3D  r2(...);
Rotation3D  r3 = r2*r1;      <emphasis role="italic"><code>//a combine rotation r3 by applying first r1 then r2</code></emphasis>
</programlisting>

<para>We can combine rotations of different types, like <code>Rotation3D</code> with any other type of rotations. The product of two different axial rotations returns a <code>Rotation3D</code>: </para>

<programlisting language="c++">
RotationX   rx(1.);
RotationY   ry(2.);
Rotation3D  r = ry * rx;       <emphasis role="italic"><code>//</code></emphasis><emphasis role="italic"><code>rotation along X and then Y axis </code></emphasis>
</programlisting>

<para>It is also possible to invert all the transformation or return their inverse:</para>

<programlisting language="c++">
Rotation3D  r1(...);
r1.Invert();       <emphasis role="italic"><code>//invert the rotation modifying its content</code></emphasis>
Rotation3D  r2 =r1.Inverse();  <emphasis role="italic"><code>//return the inverse in a new rotation class</code></emphasis>
</programlisting>

<para>We have used rotation as examples, but all these operations can be applied to all the transformation classes. </para>
</sect3>

<sect3>
<title>Set/GetComponents Methods</title>
<para>Common methods to all transformations are <code>Get</code> and <code>SetComponents</code>. They can be used to retrieve all the scalar values on which the transformation is based. </para>

<programlisting language="c++">
RotationX  rx;
rx.SetComponents(1.);          <emphasis role="italic"><code>//set agle of the X rotation</code></emphasis>
double d[9] = {........};
Rotation3D r;
r.SetComponents(d,d+9);        <emphasis role="italic"><code>//set 9 components of 3D rotation</code></emphasis>
double d[16];
LorentzRotation lr;
lr.GetComponents(d,d+16);      <emphasis role="italic"><code>//get 16 components of a LorentzRotation</code></emphasis>
TMatrixD(3,4) m;
Transform3D t;
t.GetComponens(m);            <emphasis role="italic"><code>//fill 3x4 matrix with components of t</code></emphasis>
</programlisting>

<para>The<code> GetComponents</code> and <code>SetComponents</code> methods can be used with a signature based iterators or by using any foreign matrix which implements the <code>operator(i,j)</code> or a different signatures depending on the transformation type. For more details on all methods see the reference documentation of any specific transformation class.</para>
</sect3>
</sect2>

<sect2>
<title>Example with External Packages</title>

<sect3>
<title>Connection to Linear Algebra Classes</title>
<para>It is possible to use the vector and rotation classes together with the linear algebra classes and to set and get the contents of any 3D or 4D vector from a linear algebra vector class which implements an iterator or something which behaves like an iterator. For example a pointer to a C array (double<code>*</code>) behaves like an iterator. It is then assumed that the coordinates, like (<code>x,y,z</code>) will be stored contiguously. </para>

<programlisting language="c++">
TVectorD   r2(N);           <emphasis role="italic"><code>//ROOT Linear Algebra Vector containing many vectors</code></emphasis>
XYZVector  v2;
<emphasis role="italic"><code>//construct vector from x=r[INDEX], y=r[INDEX+1], z=r[INDEX+2]</code></emphasis>
v2.SetCoordinates(&amp;r2[INDEX],&amp;r2[index]+3);
</programlisting>

<para>To fill a linear algebra vector from a 3D or 4D vector, with <code>GetCoordinates()</code> one can get the internal coordinate data. </para>

<programlisting language="c++">
HepVector      c(3);        <emphasis role="italic"><code>//CLHEP Linear algebra vector</code></emphasis>
<emphasis role="italic"><code>//fill HepVector c with c[0]=x, c[1]=y, c[2]=z</code></emphasis>
v2.GetCoordinates(&amp;c[0],&amp;c[index]+3)
</programlisting>

<para>or using <emphasis role="bold"><code>TVectorD</code></emphasis>:</para>

<programlisting language="c++">
double   *data[3];
v2.GetCoordinates(data,data+3);
TVectorD  r1(3,data);       <emphasis role="italic"><code>//create a new Linear Algebra vector copying the data</code></emphasis>
</programlisting>

<para>In the case of transformations, constructor and method to set<code>/</code>get components exist with linear algebra matrices. The requisite is that the matrix data are stored, for example in the case of a Lorentz rotation, from (<code>0,0</code>) thru (<code>3,3</code>) </para>

<programlisting language="c++">
TMatrixD(4,4)   m;
LorentzRotation r(m);       <emphasis role="italic"><code>//create Lorentz</code></emphasis><emphasis role="italic"><code> r</code></emphasis><emphasis role="italic"><code>otation from matrix m </code></emphasis>
r.GetComponents(m);         <emphasis role="italic"><code>//fill matrix m with LorentzRotation components</code></emphasis>
</programlisting>

</sect3>

<sect3>
<title>Connection to Other Vector Classes</title>
<para>The 3D and 4D vectors of the <code>GenVector</code> package can be constructed and assigned from any vector which satisfies the following requisites: </para>
<itemizedlist>
<listitem><para>for 3D vectors implementing the <code>x()</code>, <code>y()</code> and <code>z()</code> methods </para></listitem>
<listitem><para>for Lorentz vectors implementing the <code>x()</code>, <code>y()</code>, <code>z()</code> and <code>t()</code> methods.</para></listitem>
</itemizedlist>
<programlisting language="c++">
CLHEP::Hep3Vector hv;
XYZVector         v1(hv);      <emphasis role="italic"><code>//create  3D v</code></emphasis><emphasis role="italic"><code>ector from  CLHEP 3D Vector</code></emphasis>
HepGeom::Point3D  hp;
XYZPoint          p1(hp);      <emphasis role="italic"><code>//</code></emphasis><emphasis role="italic"><code>create a 3D p</code></emphasis><emphasis role="italic"><code>oint from CLHEP geom Point</code></emphasis>
CLHEP::HepLorentzVector hq;
XYZTVector           q(hq);    <emphasis role="italic"><code>//create a Lorentz</code></emphasis><emphasis role="italic"><code> v</code></emphasis><emphasis role="italic"><code>ector  from CLHEP L.V.</code></emphasis>
</programlisting>

</sect3>
</sect2>
</sect1>

<sect1>
<title>MathMore Library</title>
<para>The <code>MathMore</code> library provides an advanced collection of functions and C++ classes for numerical computing. This is an extension of the functionality provided by the <code>MathCore</code> library. The current set includes: </para>
<para>▪  Special functions (see Special Functions in MathMore)</para>
<para>▪ Mathematical functions used in statistics such as probability density functions, cumulative distributions  functions and their inverse.</para>
<para>▪ Numerical algorithms for one dimensional functions based on implementation of the GNU Scientific Library (GSL): </para>
<itemizedlist>
<listitem><para>Numerical integration using the class <emphasis role="bold"><code>ROOT::Math::Integrator</code></emphasis> which is based on the  Adaptive integration algorithms of QUADPACK</para></listitem>
<listitem><para>Numerical differentiation via <emphasis role="bold"><code>ROOT::Math::Derivator</code></emphasis></para></listitem>
<listitem><para>Root finder via <emphasis role="bold"><code>ROOT::Math::RootFinder</code></emphasis> which uses different solver algorithms from GSL</para></listitem>
<listitem><para>Minimization via <emphasis role="bold"><code>ROOT::Math::Minimizer1D</code></emphasis></para></listitem>
<listitem><para>Interpolation via <emphasis role="bold"><code>ROOT::Math::Interpolation</code></emphasis>. All the GSL interpolation types are supported</para></listitem>
<listitem><para>Function approximation based on Chebyshev polynomials via the class <emphasis role="bold"><code>ROOT::Math::Chebyshev</code></emphasis></para></listitem>
<listitem><para>Random number generators and distributions</para></listitem>
<listitem><para>Polynomial evaluation and root solvers</para></listitem>
</itemizedlist>
<para>The mathematical functions are implemented as a set of free functions in the namespace <emphasis role="bold"><code>ROOT::Math</code></emphasis>. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension  <uri xmlns:xlink="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1687.pdf">proposal document</uri>).The <code>MathCore</code> library is implemented wrapping in C++ the GNU Scientific Library ( <uri xmlns:xlink="http://www.gnu.org/software/gsl">GSL</uri>). Building <code>MathMore</code> requires a version of GSL larger or equal 1.8. The source code of <code>MathMore</code> is distributed under the GNU General Public License. </para>
<para><code>MathMore</code> (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. The GSL library and header file location can be specified in the ROOT configure script, by doing:  <code>./configure --with-gsl-incdir=... --with-gsl-libdir=...</code></para>
<para><code>MathMore</code> can be built also a stand-alone library (without requiring ROOT) downloding the tar file from the Web at this link. In this case the library will not contain the dictionary information and therefore cannot be used interactively</para>
<para>More information on the classes and functions present in <code>MathMore</code> is available in the  <uri xmlns:xlink="http://seal.web.cern.ch/seal/MathLibs/MathMore/html/index.html">online reference documentation</uri>.</para>
</sect1>

<sect1>
<title>Mathematical Functions</title>
<para>The mathematical functions are present in both <code>MathCore</code> and <code>MathMore</code> libraries. All mathematical functions are implemented as free functions in the namespace <emphasis role="bold"><code>ROOT::Math</code></emphasis>. The most used functions are in the <code>MathCore</code> library while the others are in the <code>MathMore</code> library. The functions in <code>MathMore</code> are all using the implementation of the GNU Scientific Library (GSL). The naming of the special functions is the same defined in the C++  <uri xmlns:xlink="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1687.pdf">Technical Report on Standard Library extensions</uri>. The special functions are defined in the header file <code>Math/SpecFunc.h</code>. </para>

<sect2>
<title>Special Functions in MathCore</title>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::beta(double x,double y) - </code>evaluates the beta function: <inlinemediaobject><imageobject><imagedata fileref="pictures/0600010E.png" width="1in" depth="24.85pt"/></imageobject></inlinemediaobject></para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::erf(double x)</code> - evaluates the error function encountered in integrating the normal distribution:<inlinemediaobject><imageobject><imagedata fileref="pictures/0600010F.png" width="75.1pt" depth="28.55pt"/></imageobject></inlinemediaobject></para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::erfc(double x)</code> – evaluates the complementary error function: <inlinemediaobject><imageobject><imagedata fileref="pictures/06000110.png" width="127.85pt" depth="31.05pt"/></imageobject></inlinemediaobject></para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::tgamma(double x)</code> - calculates the gamma function: <inlinemediaobject><imageobject><imagedata fileref="pictures/06000111.png" width="1in" depth="32.9pt"/></imageobject></inlinemediaobject></para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>Special Functions in MathMore</title>
<itemizedlist>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::assoc_legendre(unsigned l,unsigned m,double x) -</code>computes the associated Legendre polynomials (with <emphasis role="italic"><code>m</code></emphasis><code>≥0</code>, <code>l≥m</code>         and <code>|x|&lt;1)</code>:<inlinemediaobject><imageobject><imagedata fileref="pictures/06000112.png" width="124.15pt" depth="28.55pt"/></imageobject></inlinemediaobject></para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::comp_ellint_1(double k)</code> - calculates the complete elliptic integral of the first kind (with <code>0≤k2≤1)</code>:<inlinemediaobject><imageobject><imagedata fileref="pictures/06000113.png" width="142.15pt" depth="29.8pt"/></imageobject></inlinemediaobject></para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::comp_ellint_2(double k)</code> - calculates the complete elliptic integral of the second kind (with <code>0≤k2≤1</code>):<inlinemediaobject><imageobject><imagedata fileref="pictures/06000114.png" width="157.65pt" depth="32.3pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::comp_ellint_3(double n,double k)</code>         - calculates the complete elliptic integral of the third kind (with <code>0≤k2≤1</code>): <inlinemediaobject><imageobject><imagedata fileref="pictures/06000115.png" width="190.55pt" depth="34.75pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::conf_hyperg(double a,double b,double z)</code> - calculates the confluent hyper-geometric functions of the first kind: <inlinemediaobject><imageobject><imagedata fileref="pictures/06000116.png" width="145.25pt" depth="33.5pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para> <code>double</code> <emphasis role="bold"><code>ROOT::Math::</code></emphasis> <code>conf_hypergU(double a,double b,double z) - calculates the confluent hyper-geometric functions of the second kind, known also as Kummer function of the second type. It is related to the confluent hyper-geometric function of the first kind:</code></para></listitem>
<listitem><para> <inlinemediaobject><imageobject><imagedata fileref="pictures/06000117.png" width="230.9pt" depth="31.05pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::cyl_bessel_i(double nu,double x)</code> - calculates the modified Bessel function of the first kind, also called regular modified (cylindrical) Bessel function: <inlinemediaobject><imageobject><imagedata fileref="pictures/06000118.png" width="152.7pt" depth="41.6pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::cyl_bessel_j(double nu,double x)</code> - calculates the (cylindrical) Bessel function of the first kind, also called regular (cylindrical) Bessel function: <inlinemediaobject><imageobject><imagedata fileref="pictures/06000119.png" width="108pt" depth="40.35pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::cyl_bessel_k(double nu,double x)</code> - calculates the modified Bessel function of the second kind, also called irregular modified (cylindrical) Bessel function for <code>x&gt;0</code>, <code>v&gt;0</code>: <inlinemediaobject><imageobject><imagedata fileref="pictures/0600011A.png" width="313.45pt" depth="55.85pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::cyl_neumann(double nu,double x)</code> - calculates the (cylindrical) Bessel function of the second kind, also called irregular (cylindrical) Bessel function or (cylindrical) Neumann function: <inlinemediaobject><imageobject><imagedata fileref="pictures/0600011B.png" width="257.6pt" depth="54pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::ellint_1(double k,double phi)</code> - calculates incomplete elliptic integral of the first kind (with <code>0≤k2≤1</code>): <inlinemediaobject><imageobject><imagedata fileref="pictures/0600011C.png" width="117.95pt" depth="35.4pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::ellint_2(double k,double phi)</code> - calculates the complete elliptic integral of the second kind (with <code>0≤k2≤1</code>): <inlinemediaobject><imageobject><imagedata fileref="pictures/0600011D.png" width="129.1pt" depth="36pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::ellint_3(double n,double k,double phi) - </code>calculates  the complete elliptic integral of the third kind (with <code>0≤k2≤1</code>): <inlinemediaobject><imageobject><imagedata fileref="pictures/0600011E.png" width="175.05pt" depth="34.15pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::expint(double x)</code> - calculates the exponential integral: <inlinemediaobject><imageobject><imagedata fileref="pictures/0600011F.png" width="78.2pt" depth="35.4pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::hyperg(double a,double b,double c,double x)</code> - calculates Gauss' hyper-geometric function: <inlinemediaobject><imageobject><imagedata fileref="pictures/06000120.png" width="229.65pt" depth="34.75pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::legendre(unsigned l,double x)</code> - calculates the Legendre polynomials for <code>l≥0</code>, <code>|x|≤1</code>  in the Rodrigues representation: <inlinemediaobject><imageobject><imagedata fileref="pictures/06000121.png" width="114.85pt" depth="32.9pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::riemann_zeta(double x)</code> - calculates the Riemann zeta function: <inlinemediaobject><imageobject><imagedata fileref="pictures/06000122.png" width="212.9pt" depth="48.4pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::sph_bessel(unsigned n,double x)</code> - calculates the spherical Bessel functions of the first kind (also called regular spherical Bessel functions): <inlinemediaobject><imageobject><imagedata fileref="pictures/06000123.png" width="104.9pt" depth="34.75pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><code>double </code><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::sph_neumann(unsigned n,double x)</code> - calculates the spherical Bessel functions of the second kind (also called irregular spherical Bessel functions or spherical Neumann functions):<inlinemediaobject><imageobject><imagedata fileref="pictures/06000124.png" width="145.85pt" depth="34.75pt"/></imageobject></inlinemediaobject></para></listitem>
</itemizedlist>
</sect2>

<sect2>
<title>Probability Density Functions (PDF)</title>
<para>Probability density functions of various distributions. All the functions, apart from the discrete ones, have the extra location parameter <code>x0</code>, which by default is zero. For example, in the case of a gaussian <code>pdf</code>, <code>x0</code> is the <code>mean</code>, <code>mu</code>, of the distribution. All the probability density functions are defined in the header file <code>Math/DistFunc.h</code> and are part of the <code>MathCore</code> libraries. The definition of these functions is documented in the  <uri xmlns:xlink="http://seal.web.cern.ch/seal/MathLibs/5_0_8/MathCore/html/group__StatFunc.html">reference doc for statistical functions</uri>:</para>

<programlisting language="c++">
<code>double ROOT::Math::beta_pdf(double x,double a, double b);</code>
<code>double ROOT::Math::binomial_pdf(unsigned int k,double p,unsigned int n);</code>
<code>double ROOT::Math::breitwigner_pdf(double x,double gamma,double x0=0);</code>
<code>double ROOT::Math::cauchy_pdf(double x,double b=1,double x0=0);</code>
<code>double ROOT::Math::chisquared_pdf(double x,double r,double x0=0);</code>
<code>double ROOT::Math::exponential_pdf(double x,double lambda,double x0=0);</code>
<code>double ROOT::Math::fdistribution_pdf(double x,double n,double m,double x0=0);</code>
double ROOT::Math::gamma_pdf(double x,double alpha,double theta,double x0=0);
double ROOT::Math::gaussian_pdf(double x,double sigma,double x0=0);
double ROOT::Math::landau_pdf(double x,double s,double x0=0);
double ROOT::Math::lognormal_pdf(double x,double m,double s,double x0=0);
double ROOT::Math::normal_pdf(double x,double sigma,double x0=0);
double ROOT::Math::poisson_pdf(unsigned int n,double mu);
double ROOT::Math::tdistribution_pdf(double x,double r,double x0=0);
double ROOT::Math::uniform_pdf(double x,double a,double b,double x0=0);
</programlisting>

</sect2>

<sect2>
<title>Cumulative Distribution Functions (CDF)</title>
<para>For all the probability density functions, we have the corresponding cumulative distribution functions and their complements. The functions with extension <code>_cdf</code> calculate the lower tail integral of the probability density function:</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/06000125.png" width="81.3pt" depth="33.5pt"/></imageobject></inlinemediaobject>
</para>
<para>while those with the <code>cdf_c</code> extension calculate the upper tail of the probability density function, so-called in statistics the survival function. For example, the function: </para>

<programlisting language="c++">
double ROOT::Math::gaussian_cdf(double x,double sigma,double x0=0);
</programlisting>

<para>evaluates the lower tail of the Gaussian distribution: </para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/06000126.png" width="144.6pt" depth="34.15pt"/></imageobject></inlinemediaobject>
</para>
<para>while the function:</para>

<programlisting language="c++">
double ROOT::Math::gaussian_cdf_c(double x, double sigma, double x0=0);
</programlisting>

<para>evaluates the upper tail of the Gaussian distribution: </para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/06000127.png" width="144.6pt" depth="36.6pt"/></imageobject></inlinemediaobject>
</para>
<para>The cumulative distributions functions are defined in the header file <code>Math/ProbFunc.h</code>. The majority of the CDF's are present in the <code>MathCore</code>, apart from the <code>chisquared</code>, <code>fdistribution</code>, <code>gamma</code> and <code>tdistribution</code>, which are in the <code>MathMore</code> library.</para>

<sect3>
<title>Inverse of the Cumulative Distribution Functions(Quantiles)</title>
<para>For almost all the cumulative distribution functions (<code>_cdf</code>) and their complements (<code>_cdf_c</code>) present in the library, we provide the inverse functions. The inverse of the cumulative distribution function is called in statistics quantile function. The functions with the extension <code>_quantile</code> calculate the inverse of the cumulative distribution function (lower tail integral of the probability density function), while those with the <emphasis role="italic"><code>quantile_c</code></emphasis> extension calculate the inverse of the complement of the cumulative distribution (upper tail integral). All the inverse distributions are in the MathMore library and are defined in the header file <code>Math/ProbFuncInv.h</code>. </para>
<para>The following picture illustrates the available statistical functions (PDF, CDF and quantiles) in the case of the normal distribution.</para>

<figure><title>PDF, CDF and quantiles in the case of the normal distribution</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/03000128.png" width="362.5pt" depth="122.9pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect3>
</sect2>
</sect1>

<sect1>
<title>Linear Algebra: SMatrix Package</title>
<para>The ROOT Linear algebra package is documented in a separate chapter (see “Linear Algebra in ROOT”).  <code>SMatrix</code> is a C++ package, for high performance vector and matrix computations. It has been introduced in ROOT v5.08. It is optimized for describing small matrices and vectors and It can be used only in problems when the size of the matrices is known at compile time, like in the tracking reconstruction of physics experiments. It is based on a C++ technique, called expression templates, to achieve an high level optimization. The C++ templates can be used to implement vector and matrix expressions such that these expressions can be transformed at compile time to code which is equivalent to hand optimized code in a low-level language like FORTRAN or C (see for example T. Veldhuizen, Expression Templates, C++ Report, 1995).</para>
<para>The <code>SMatrix</code> has been developed initially by T. Glebe in Max-Planck-Institut, Heidelberg, as part of the <code>HeraB</code> analysis framework. A subset of the original package has been now incorporated in the ROOT distribution, with the aim to provide a stand-alone and high performance matrix package. The API of the current package differs from the original one, in order to be compliant to the ROOT coding conventions. </para>
<para><code>SMatrix</code> contains the generic <emphasis role="bold"><code>ROOT::Math::SMatrix</code></emphasis> and <emphasis role="bold"><code>ROOT::Math::SVector</code></emphasis> classes for describing matrices and vectors of arbitrary dimensions and of arbitrary type. The classes are templated on the scalar type and on the size, like number of rows and columns for a matrix . Therefore, the matrix/vector dimension has to be known at compile time. An advantage of using the dimension as template parameters is that the correctness of dimension in the matrix/vector operations can be checked at compile time. </para>
<para><code>SMatrix</code> supports, since ROOT v5.10, symmetric matrices using a storage class (<emphasis role="bold"><code>ROOT::Math::MatRepSym</code></emphasis>) which contains only the <code>N*(N+1)/2</code> independent element of a <code>NxN</code> symmetric matrix. It is not in the mandate of this package to provide complete linear algebra functionality. It provides basic matrix and vector functions such as matrix-matrix, matrix-vector, vector-vector operations, plus some extra functionality for square matrices, like inversion and determinant calculation.  The inversion is based on the optimized Cramer method for squared matrices of size up to <code>6x6</code>. </para>
<para>The <code>SMatrix</code> package contains only header files. Normally one does not need to build any library. In the ROOT distribution a library, <code>libSmatrix</code> is produced with the C++ dictionary information for squared and symmetric matrices and vectors up to dimension 7 and based on <emphasis role="bold"><code>Double</code></emphasis><emphasis role="bold"><code>_t</code></emphasis>, <emphasis role="bold"><code>F</code></emphasis><emphasis role="bold"><code>l</code></emphasis><emphasis role="bold"><code>oat_t</code></emphasis> and <emphasis role="bold"><code>Double32_t</code></emphasis>. The following paragraphs describe the main characteristics of the matrix and vector classes. More detailed information about the <code>SMatrix</code> classes API is available in the  <uri xmlns:xlink="http://seal.web.cern.ch/seal/MathLibs/SMatrix/html">online reference documentation</uri>.</para>

<sect2>
<title>Example: Vector Class (SVector)</title>
<para>The template class <emphasis role="bold"><code>ROOT::Math::SVector</code></emphasis> represents <code>n</code>-dimensional vectors for objects of arbitrary type. This class has 2 template parameters, which define at compile time, its properties: 1) type of the contained elements (for example <emphasis role="italic">float</emphasis> or <emphasis role="italic">double</emphasis>); 2) size of the vector. The use of this dictionary is mandatory if one want to use <code>Smatrix</code>         in CINT and with I/O.</para>

<sect3>
<title>Creating a Vector</title>
<para>The following constructors are available to create a vector:</para>

<itemizedlist>
<listitem><para>Default constructor for a zero vector (all elements equal to zero).</para></listitem>
<listitem><para>Constructor (and assignment) from a vector expression, like <code>v=p*q+w</code>. Due to the expression template technique, no temporary objects are created in this operation.</para></listitem>
<listitem><para>Constructor by passing directly the elements. This is possible only for vectors up to size 10.</para></listitem>
<listitem><para>Constructor from an iterator copying the data referred by the iterator. It is possible to specify the <emphasis role="italic">begin</emphasis> and <emphasis role="italic">end</emphasis> of the iterator or the <emphasis role="italic">begin</emphasis> and the <emphasis role="italic">size</emphasis>. Note that for the Vector the iterator is not generic and must be of type <code>T*</code>, where <code>T</code> is the type of the contained elements. </para></listitem>
</itemizedlist>

<para>In the following example we assume that we are using the namespace <emphasis role="bold"><code>ROOT::Math</code></emphasis> </para>

<programlisting language="c++">
SVector&lt;double,3&gt; v;       <emphasis role="italic"><code>//create a</code></emphasis><emphasis role="italic"><code>n empty vector of size 3 ( v[0]=v[1]=v[2]=</code></emphasis><emphasis role="italic"><code>0)</code></emphasis>
double d[3] = {1,2,3};
SVector&lt;double,3&gt; v(d,3);  <emphasis role="italic"><code>//create a vector from a C array</code></emphasis>
</programlisting>

</sect3>

<sect3>
<title>Accessing and Setting Methods</title>
<para>The single vector elements can be set or retrieved using the <code>operator[i]</code>, <code>operator(i)</code> or the iterator interface. Notice that the index starts from zero and not from one as in FORTRAN. Also no check is performed on the passed index. The full vector elements can be set also by using the SetElements function passing a generic iterator. </para>

<programlisting language="c++">
double x = m(i);          <emphasis role="italic"><code>// return the i-th element</code></emphasis>
x = *(m.begin()+i);       <emphasis role="italic"><code>// return the i-th element</code></emphasis>
v[0] = 1;                 <emphasis role="italic"><code>// set the first element</code></emphasis>
v(1) = 2;                 <emphasis role="italic"><code>// set the second element</code></emphasis>
*(v.begin()+3) = 3;       <emphasis role="italic"><code>// set the third element</code></emphasis>
std::vector&lt;double&gt; w(3);

<emphasis role="italic"><code>// set vector elements from a std::vector&lt;double&gt;::iterator</code></emphasis>
v.SetElements(w.begin(),w.end());
</programlisting>

<para>In addition there are methods to place a sub-vector in a vector. If the size of the sub-vector is larger than the vector size a static assert (a compilation error) is produced.</para>

<programlisting language="c++">
SVector&gt;double,N&gt;  v;
SVector&gt;double,M&gt;  w;
<emphasis role="italic"><code>// M &lt;= N otherwise a compilation error is obtained later    </code></emphasis>
<emphasis role="italic"><code>// place a vector of size M starting from element ioff, v[ioff+i]=w[i]</code></emphasis>
v.Place_at(w,ioff);
<emphasis role="italic"><code>// return a sub-vector of size M starting from v[ioff]: w[i]=v[ioff+i]</code></emphasis>
w = v.Sub &lt; SVector&gt;double,M&gt; &gt; (ioff);
</programlisting>

<para>For the vector functions see later in the Matrix and Vector Operators and Functions paragraph. </para>
</sect3>
</sect2>

<sect2>
<title>Example: Matrix Class (SMatrix)</title>
<para>The template class <emphasis role="bold"><code>ROOT::Math::SMatrix</code></emphasis> represents a matrix of arbitrary type with <code>nrows</code>         <code>x</code>         <code>ncol</code> dimension. The class has 4 template parameters, which define at compile time, its properties:</para>
<itemizedlist>
<listitem><para>type of the contained elements, T, for example float or double;</para></listitem>
<listitem><para>number of rows;</para></listitem>
<listitem><para>number of columns;</para></listitem>
<listitem><para>representation type. This is a class describing the underlined storage model of the Matrix. Presently exists only two types of this class: </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::MatRepStd</code></emphasis> for a general <code>nrows x ncols</code> matrix. This class is itself a template on the contained type <code>T</code>, the number of rows and the number of columns. Its data member is an array <code>T[nrows*ncols]</code> containing the matrix data. The data are stored in the row-major C convention. For example, for a matrix <code>M</code>, of size <code>3x3</code>, the data <code>{a0,a1,…,a8}</code>  are stored in the following order:</para></listitem>
<listitem><para><inlinemediaobject><imageobject><imagedata fileref="pictures/06000129.png" width="69.5pt" depth="40.35pt"/></imageobject></inlinemediaobject> </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::MatRepSym</code></emphasis> for a symmetric matrix of size <code>NxN</code>. This class is a template on the contained type and on the symmetric matrix size <code>N</code>. It has as data member an array of type <code>T</code> of size <code>N*(N+1)/2</code>, containing the lower diagonal block of the matrix. The order follows the lower diagonal block, still in a row-major convention. For example for a symmetric <code>3x3</code> matrix the order of the <code>6</code> independent elements <code>{a0,a1,…,a5}</code>  is: </para></listitem>
<listitem><para><inlinemediaobject><imageobject><imagedata fileref="pictures/0600012A.png" width="69.5pt" depth="40.35pt"/></imageobject></inlinemediaobject> </para></listitem>
</itemizedlist>
<sect3>
<title>Creating a Matrix</title>
<para>The following constructors are available to create a matrix: </para>
<itemizedlist>
<listitem><para>Default constructor for a zero matrix (all elements equal to zero).</para></listitem>
<listitem><para>Constructor of an identity matrix.</para></listitem>
<listitem><para>Copy constructor (and assignment) for a matrix with the same representation, or from a different one when possible, for example from a symmetric to a general matrix. </para></listitem>
<listitem><para>Constructor (and assignment) from a matrix expression, like <code>D=A*B+C</code>. Due to the expression template technique, no temporary objects are created in this operation. In the case of an operation like <code>A=A*B+C</code>, a temporary object is needed and it is created automatically to store the intermediary result in order to preserve the validity of this operation. </para></listitem>
<listitem><para>Constructor from a generic STL-like iterator copying the data referred by the iterator, following its order. It is both possible to specify the begin and end of the iterator or the begin and the size. In case of a symmetric matrix, it is required only the triangular block and the user can specify whether giving a block representing the lower (default case) or the upper diagonal part.</para></listitem>
</itemizedlist>
<para>Here are some examples on how to create a matrix. We use typedef's in the following examples to avoid the full C++ names for the matrix classes. Notice that for a general matrix the representation has the default value, <emphasis role="bold"><code>ROOT::Math::MatRepStd</code></emphasis>, and it is not needed to be specified. Furthermore, for a general square matrix, the number of column may be as well omitted.</para>

<programlisting language="c++">
<emphasis role="italic"><code>// typedef definitions used in the following declarations </code></emphasis>
typedef ROOT::Math::SMatrix&lt;double,3&gt;       SMatrix33;
typedef ROOT::Math::SMatrix&lt;double,2&gt;       SMatrix22;
typedef ROOT::Math::SMatrix&lt;double,3,3,
ROOT::Math::MatRepSym&lt;double,3&gt;&gt; SMatrixSym3;
typedef ROOT::Math::SVector&gt;double,2&gt;       SVector2;
typedef ROOT::Math::SVector&gt;double,3&gt;       SVector3;
typedef ROOT::Math::SVector&gt;double,6&gt;       SVector6;
SMatrix33   m0;                         <emphasis role="italic"><code>// create a zero 3x3 matrix</code></emphasis>
<emphasis role="italic"><code>// create an 3x3 identity matrix </code></emphasis>
SMatrix33   i = ROOT::Math::SMatrixIdentity();
double   a[9] = {1,2,3,4,5,6,7,8,9};    <emphasis role="italic"><code>// input matrix data</code></emphasis>
<emphasis role="italic"><code>// create a matrix using the a[] data</code></emphasis>
SMatrix33   m(a,9);                     <emphasis role="italic"><code>// this will produce the 3x3 matrix</code></emphasis>
<emphasis role="italic"><code>                                        //    (  1    2    3  )</code></emphasis>
<emphasis role="italic"><code>                                        //    (  4    5    6  )</code></emphasis>
<emphasis role="italic"><code>                                        //    (  7    8    9  )</code></emphasis>
</programlisting>

<para>Example to fill a symmetric matrix from an <code>std::vector</code>:</para>

<programlisting language="c++">
std::vector&lt;double&gt; v(6);
for (int i = 0; i&lt;6; ++i) v[i] = double(i+1);
SMatrixSym3  s(v.begin(),v.end())   <emphasis role="italic"><code>// this will produce the symmetric  matrix</code></emphasis>
<emphasis role="italic"><code>//    (  1    2    4 </code></emphasis> <emphasis role="italic"><code>)</code></emphasis>
<emphasis role="italic"><code>                                    //    (  2    3    5  )</code></emphasis>
<emphasis role="italic"><code>                                    //    (  4    5    6  )</code></emphasis>
<emphasis role="italic"><code>//create a general matrix from a symmetric matrix (the opposite will not compile)
SMatrix33    m2 = s;</code></emphasis>
</programlisting>

</sect3>

<sect3>
<title>Accessing and Setting Methods</title>
<para>The matrix elements can be set using the <code>operator()(irow,icol)</code>, where <code>irow</code> and <code>icol</code> are the row and column indexes
or by using the iterator interface. Notice that the indexes start from zero and not from one as in FORTRAN. Furthermore, all the matrix elements can be set also
by using the SetElements function passing a generic iterator. The elements can be accessed by the same methods as well as by using the function
<emphasis role="bold"><code>ROOT::Math::SMatrix::</code></emphasis><code>apply</code>. The <code>apply(i)</code> has exactly the same behavior for general and
symmetric matrices; in contrast to the iterator access methods which behave differently (it follows the data order).</para>

<programlisting language="c++">
SMatrix33   m;
m(0,0) = 1;                     <emphasis role="italic"><code>// set the element in first row and first column</code></emphasis>
*(m.begin()+1) = 2;             <emphasis role="italic"><code>// set the second element (0,1)</code></emphasis>
<code>double d[9]={1,2,3,4,5,6,7,8,9};</code>
m.SetElements(d,d+9);           <emphasis role="italic"><code>// set the d[] values in m</code></emphasis>
double x = m(2,1);              <emphasis role="italic"><code>// return the element in </code></emphasis><emphasis role="italic"><code>3</code></emphasis><emphasis role="italic"><code>rd row and </code></emphasis><emphasis role="italic"><code>1</code></emphasis><emphasis role="italic"><code>st column</code></emphasis>
x = m.apply(7);                 <emphasis role="italic"><code>// return the 8-th element (row=2,col=1)</code></emphasis>
x = *(m.begin()+7);             <emphasis role="italic"><code>// return the 8-th element (row=2,col=1)</code></emphasis>
<emphasis role="italic"><code>// symmetric matrices </code></emphasis>
<emphasis role="italic"><code>//(note the difference in behavior between apply and the iterators)</code></emphasis>
x = *(m.begin()+4)              <emphasis role="italic"><code>// r</code></emphasis><emphasis role="italic"><code>eturn the element (row=2,col=1)</code></emphasis>
x = m.apply(7);                 <emphasis role="italic"><code>// returns again the (row=2,col=1) element</code></emphasis>
</programlisting>

<para>There are methods to place and/or retrieve <emphasis role="bold"><code>ROOT::Math::SVector</code></emphasis> objects as rows or columns in (from) a matrix. In addition one can put (get) a sub-matrix as another <emphasis role="bold"><code>ROOT::Math::SMatrix</code></emphasis> object in a matrix. If the size of the sub-vector or sub-matrix is larger than the matrix size a static assert (a compilation error) is produced. The non-const methods are:</para>

<programlisting language="c++">
SMatrix33 m;
SVector2  v2(1,2);
<emphasis role="italic"><code>// place a vector in the first row from element (0,1) : m(0,1)=v2[0]</code></emphasis>
m.Place_in_row(v2,0,1);
<emphasis role="italic"><code>// place the vector in the second column from (0,1) : m(0,1) = v2[0]                </code></emphasis>
m.Place in_col(v2,0,1);
SMatrix22 m2;
<emphasis role="italic"><code>// place m2 in m starting from the element (1,1) : m(1,1) = m2(0,0)   </code></emphasis>
m.Place_at(m2,1,1);
SVector3 v3(1,2,3);
<emphasis role="italic"><code>// set v3 as the diagonal elements of m  : m(i,i) = v3[i] for i=0,1,2</code></emphasis>
m.SetDiagonal(v3)
</programlisting>

<para>The const methods retrieving contents (getting slices of a matrix) are:</para>

<programlisting language="c++">
a = {1,2,3,4,5,6,7,8,9};
SMatrix33       m(a,a+9);
SVector3 irow = m.Row(0);       <emphasis role="italic"><code>// return as vector the first row </code></emphasis>
SVector3 jcol = m.Col(1);       <emphasis role="italic"><code>// return as vector the second column</code></emphasis>

<emphasis role="italic"><code>// return a slice of the first row from (0,1): r2[0]= m(0,1); r2[1]=m(0,2)</code></emphasis>
SVector2 r2   =  m.SubRow&lt;SVector2&gt; (0,1);
<emphasis role="italic"><code>// return a slice of the second column from (0,1): c2[0] = m(0,1); c2[1] = m(1,1)</code></emphasis>
SVector2 c2   =  m.SubCol&lt;SVector2&gt; (1,0);

<emphasis role="italic"><code>// return a sub-matrix 2x2 with the upper left corner at(1,1)</code></emphasis>
SMatrix22 subM = m.Sub&lt;SMatrix22&gt;   (1,1);

<emphasis role="italic"><code>// return the diagonal element in a SVector</code></emphasis>
SVector3  diag = m.Diagonal();

<emphasis role="italic"><code>// return the upper(lower) block of the matrix m</code></emphasis>
SVector6 vub = m.UpperBlock();        //  vub = [ 1, 2, 3, 5, 6, 9 ]
SVector6 vlb = m.LowerBlock();        //  vlb = [ 1, 4, 5, 7, 8, 9 ]
</programlisting>

</sect3>

<sect3>
<title>Linear Algebra Matrix Functions (Inversion, Determinant)</title>
<para>Only limited linear algebra functionality is available for <code>SMatrix</code>. It is possible for squared matrices <code>NxN</code>, to find the inverse or to calculate the determinant. Different inversion algorithms are used if the matrix is smaller than <code>6x6</code> or if it is symmetric. In the case of a small matrix, a faster direct inversion is used. For a large <code>(N&gt;6) </code>symmetric matrix the Bunch-Kaufman diagonal pivoting method is used while for a large <code>(N&gt;6)</code> general matrix an LU factorization is performed using the same algorithm as in the CERNLIB routine <code>dinv</code>.</para>

<programlisting language="c++">
<emphasis role="italic"><code>// Invert a NxN matrix. </code></emphasis>
<emphasis role="italic"><code>// The inverted matrix replaces the existing one if the result is successful</code></emphasis>
bool ret = m.Invert();               <emphasis role="italic"><code>// return the inverse matrix of m. </code></emphasis>

<emphasis role="italic"><code>// If the inversion fails ifail is different than zero  ???</code></emphasis>
int ifail = 0;
ifail = m.Inverse(ifail);

<emphasis role="italic"><code>// determinant of a square matrix - calculate the determinant modyfing the </code></emphasis>
<emphasis role="italic"><code>// matrix content and returns it if the calculation was successful</code></emphasis>
double det;
bool ret = m.Det(det);

<emphasis role="italic"><code>// calculate determinant by using a temporary matrix; preserves matrix content </code></emphasis>
bool ret = n.Det2(det);
</programlisting>

</sect3>
</sect2>

<sect2>
<title>Example: Matrix and Vector Functions and Operators</title>

<sect3>
<title>Matrix and Vector Operators</title>
<para>The <emphasis role="bold"><code>ROOT::Math::SVector</code></emphasis> and <emphasis role="bold"><code>ROOT::Math::SMatrix</code></emphasis> classes define the following operators described below. The <code>m1</code>, <code>m2</code>, <code>m3</code> are vectors or matrices of the same type (and size) and <code>a</code> is a scalar value:</para>

<programlisting language="c++">
m1 == m2  <emphasis role="italic"><code>//returns whether m1 is equal to m2 (element by element comparison)</code></emphasis>
m1 != m2  <emphasis role="italic"><code>//returns whether m1 is NOT equal to m2 (element by element comparison)</code></emphasis>
m1 &lt; m2   <emphasis role="italic"><code>//returns whether m1 is less than m2 (element wise comparison)</code></emphasis>
m1 &gt; m2   <emphasis role="italic"><code>//returns whether m1 is greater than m2 (element wise comparison)</code></emphasis>

<emphasis role="italic"><code>//in the following m1 and m3 can be general and m2 symmetric, but not vice-versa</code></emphasis>

m1 += m2           <emphasis role="italic"><code>// add m2 to m1</code></emphasis>
m1 -= m2           <emphasis role="italic"><code>// subtract m2 to m1</code></emphasis>
m3 = m1 + m2       <emphasis role="italic"><code>// addition</code></emphasis>
m1 - m2            <emphasis role="italic"><code>// subtraction</code></emphasis>

<emphasis role="italic"><code>// Multiplication and division via a scalar value a </code></emphasis>

m3 = a*m1; m3 = m1*a; m3 = m1/a;
</programlisting>

<para><emphasis role="bold">Vector-Vector multiplication:</emphasis> The operator <code>*</code> defines an element by element multiplication between vectors. For the standard vector-vector algebraic multiplication returning a scalar, <code>vTv</code> (dot product), one must use the <emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>Dot</code> function. In addition, the Cross (only for vector sizes of 3), <emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>Cross</code>, and the Tensor product, <emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>TensorProd</code>, are defined. </para>
<para><emphasis role="bold">Matrix - Vector multiplication:</emphasis> The operator <code>*</code> defines the matrix-vector multiplication: </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/0600012B.png" width="64.55pt" depth="19.85pt"/></imageobject></inlinemediaobject>. The operation compiles only if the matrix and the vectors have the right sizes.</para>

<programlisting language="c++">
<emphasis role="italic"><code>// M is a N1xN2 matrix, x is a N2 size vector, y is a N1 size vector</code></emphasis>
y = M * x
</programlisting>

<para><emphasis role="bold">Matrix - Matrix multiplication:</emphasis> The operator <code>*</code> defines the matrix-matrix multiplication: </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/0600012C.png" width="69.5pt" depth="18pt"/></imageobject></inlinemediaobject>.</para>

<programlisting language="c++">
// A is a N1xN2 matrix, B is a N2xN3 matrix and C is a N1xN3 matrix
C = A * B
</programlisting>

<para>The operation compiles only if the matrices have the right size. In the case that <code>A</code> and <code>B</code> are symmetric matrices, <code>C</code> is a general one, since their product is not guaranteed to be symmetric.</para>
<para/>
</sect3>
</sect2>

<sect2>
<title>Matrix and Vector Functions</title>
<para>The most used matrix functions are:</para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>Transpose(M)</code> returns the transpose matrix <code>MT</code></para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>Similarity(v,M)</code>         returns the scalar value resulting from the matrix-vector product <code>vTMv</code></para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math</code></emphasis><code>::Similarity(U,M)</code> returns the matrix resulting from the product: <code>U M UT</code>. If <code>M</code> is symmetric, the returned resulting matrix is also symmetric</para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>SimilarityT(U,M)</code> returns the matrix resulting from the product: <code>UT M U</code>. If <code>M</code> is symmetric, the returned resulting matrix is also symmetric</para></listitem>
</itemizedlist>
<para>The major vector functions are: </para>
<itemizedlist>
<listitem><para><emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>Dot(v1,v2)</code> returns the scalar value resulting from the vector dot product</para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>Cross(v1,v2)</code> returns the vector cross product for two vectors of size 3. Note that the <code>Cross</code> product is not defined for other vector sizes</para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>Unit(v)</code> returns unit vector. One can use also the <code>v.Unit() </code>method. </para></listitem>
<listitem><para><emphasis role="bold"><code>ROOT::Math::</code></emphasis><code>TensorProd(v1,v2)</code> returns a general matrix <code>M </code>of size <code>N1xN2</code> resulting from the tensor product between the vector <code>v1</code> of size <code>N1</code> and <code>v2</code> of size <code>N2</code>:  </para></listitem>
</itemizedlist>
<para>For a list of all the available matrix and vector functions see the <code>SMatrix</code> online reference documentation.</para>

<sect3>
<title>Matrix and Vector I/O</title>
<para>One can print (or write in an output stream) Vectors and Matrices) using the <code>Print</code> method or the <code>&lt;&lt;</code> operator: </para>

<programlisting language="c++">
<emphasis role="italic"><code>// m is a SMatrix or a SVector object</code></emphasis>
m.Print(std::cout);
std::cout &lt;&lt; m &lt;&lt; std::endl;
</programlisting>

<para>In the ROOT distribution, the CINT dictionary is generated for <code>SMatrix</code> and <code>SVector</code> for for <emphasis role="bold"><code>Double_t</code></emphasis>, <emphasis role="bold"><code>Float_t</code></emphasis> and <emphasis role="bold"><code>Double32_t</code></emphasis> up to dimension 7. This allows the possibility to store them in a ROOT file. </para>
</sect3>
</sect2>
</sect1>

<sect1>
<title>Minuit2 Package</title>
<para><code>Minuit2</code> is a new object-oriented implementation, written in C++, of the popular <code>MINUIT</code> minimization package. Compared with the <emphasis role="bold"><code>TMinuit</code></emphasis> class, which is a direct conversion from FORTRAN to C++, <code>Minuit2</code> is a complete redesign and re-implementation of the package. This new version provides all the functionality present in the old FORTRAN version, with almost equivalent numerical accuracy and computational performances. Furthermore, it contains new functionality, like the possibility to set single side parameter limits or the FUMILI algorithm (see “FUMILI Minimization Package” in “Fitting Histograms” chapter), which is an optimized method for least square and log likelihood minimizations. Minuit2 has been originally developed by M. Winkler and F. James in the SEAL project. More information can be found on the  <uri xmlns:xlink="http://www.cern.ch/minuit">MINUIT Web Site</uri> and in particular at the following documentation page at  <uri xmlns:xlink="http://www.cern.ch/minuit/doc/doc.html">http://www.cern.ch/minuit/doc/doc.html</uri>.</para>
<para>The API has been then changed in this new version to follow the ROOT coding convention (function names starting with capital letters) and the classes have been moved inside the namespace <emphasis role="bold"><code>ROOT::Minuit2</code></emphasis>. In addition, the ROOT distribution contains classes needed to integrate <code>Minuit2</code> in the ROOT framework, like <emphasis role="bold"><code>TFitterMinuit</code></emphasis> and <emphasis role="bold"><code>TFitterFumili</code></emphasis>. <code>Minuit2</code> can be used in ROOT as another fitter plug-in. For example for using it in histogram fitting, one only needs to do: </para>

<programlisting language="c++">
TVirtualFitter::SetDefaultFitter("Minuit2");  <emphasis role="italic"><code>//or Fumili2 for the FUMILI</code></emphasis> algorithmhistogram-&gt;Fit();
</programlisting>

<para>For minimization problem, providing an FCN function to minimize, one can do:</para>

<programlisting language="c++">
TVirtualFitter::SetDefaultFitter("Minuit2");
TVirtualFitter * minuit2 = TVirtualFitter::Fitter(0,2);
</programlisting>

<para>Then set the parameters, the FCN and minimize using the <emphasis role="bold"><code>TVirtualFitter</code></emphasis> methods: <code>SetParameter</code>, <code>SetFCN</code> and <code>ExecuteCommand</code>. The FCN function can also be given to Minuit2 as an instance of a class implementing the <emphasis role="bold"><code>ROOT::Minuit2::FCNBase</code></emphasis> interface. In this case one must use directly the <emphasis role="bold"><code>TFitterMinuit</code></emphasis> class via the method <code>SetMinuitFCN</code>. </para>
<para>Examples on how to use the <code>Minuit2</code> and <code>Fumili2</code> plug-ins are provided in the tutorials’ directory $ROOTSYS/<code>tutorials/fit</code>:         <code>minuit2FitBench.C</code>, <code>minuit2FitBench2D.C</code> and <code>minuit2GausFit.C</code>. More information on the classes and functions present in <code>Minuit2</code> is available at  <uri xmlns:xlink="http://seal.web.cern.ch/seal/MathLibs/Minuit2/html/">online reference documentation</uri>. In addition, the C++ MINUIT User Guide provides all the information needed for using directly the package without <emphasis role="bold"><code>TVirtualFitter</code></emphasis> interface (see  <uri xmlns:xlink="http://seal.cern.ch/documents/minuit/mnusersguide.pdf">http://seal.cern.ch/documents/minuit/mnusersguide.pdf</uri>). Useful information on MINUIT and minimization in general is provided in the following documents: </para>
<para>F. James, <emphasis role="italic">Minuit Tutorial on Function Minimization </emphasis>
( <uri xmlns:xlink="http://seal.cern.ch/documents/minuit/mntutorial.pdf">http://seal.cern.ch/documents/minuit/mntutorial.pdf</uri>);
F. James, <emphasis role="italic">The Interpretation of Errors in Minuit </emphasis>
( <uri xmlns:xlink="http://seal.cern.ch/documents/minuit/mnerror.pdf">http://seal.cern.ch/documents/minuit/mnerror.pdf</uri>);</para>
</sect1>

<sect1>
<title>ROOT Statistics Classes</title>

<sect2>
<title>Classes for Computing Limits and Confidence Levels</title>
<para>
<emphasis role="bold"><code>TFeldmanCousins</code></emphasis> class calculates the <code>CL</code> upper/lower limit for a Poisson process using the Feldman-Cousins
method (as described in PRD V57 #7, p3873-3889). No treatment is provided in this method for the uncertainties in the signal or the background.
</para>

<para>
<emphasis role="bold"><code>TRolke</code></emphasis> computes confidence intervals for the rate of a Poisson process in the presence of background and efficiency,
using the profile likelihood technique for treating the uncertainties in the efficiency and background estimate. The signal is always assumed to be Poisson; background may
be Poisson, Gaussian, or user-supplied; efficiency may be Binomial, Gaussian, or user-supplied. See publication at Nucl. Instrum. Meth. A551:493-503,2005.
</para>

<para>
<emphasis role="bold"><code>TLimit</code></emphasis> class computes 95% C.L.
limits using the Likelihood ratio semi-Bayesian method
( <uri xmlns:xlink="http://root.cern.ch/root/doc/TomJunk.pdf">CLs</uri>
method; see e.g. T. Junk, NIM A434, p. 435-443, 1999). It takes signal background
and data histograms
wrapped in a <code>TLimitDataSource</code> as input, and runs a set of Monte Carlo
experiments in order to compute the limits. If needed, inputs are fluctuated
according to systematic.
</para>

</sect2>

<sect2>
<title>Specialized Classes for  Fitting</title>
<para><emphasis role="bold"><code>TFractionFitter</code></emphasis> fits Monte Carlo (MC) fractions to data histogram (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993) 219-228). It takes into account both data and Monte Carlo statistical uncertainties through a likelihood fit using Poisson statistics. However, the template (MC) predictions are also varied within statistics, leading to additional contributions to the overall likelihood. This leads to many more fit parameters (one per bin per template), but the minimization with respect to these additional parameters is done analytically rather than introducing them as formal fit parameters. Some special care needs to be taken in the case of bins with zero content.</para>
<para><emphasis role="bold"><code>TMultiDimFit</code></emphasis> implements multi-dimensional function parameterization for multi-dimensional data by fitting them to multi-dimensional data using polynomial or Chebyshev or Legendre polynomial</para>
<para><emphasis role="bold"><code>TSpe</code></emphasis><emphasis role="bold"><code>c</code></emphasis><emphasis role="bold"><code>trum</code></emphasis> contains advanced spectra processing functions for 1- and 2-dimensional background estimation, smoothing, deconvolution, peak search and fitting, and orthogonal transformations.</para>
<para><emphasis role="bold"><code>RooFit</code></emphasis> is a complete toolkit for fitting and data analysis modeling (see the RooFit User Guide at ftp://root.cern.ch/root/doc/RooFit_Users_Manual_2.07-29.pdf)</para>
<para><emphasis role="bold"><code>TSplot</code></emphasis><emphasis role="bold"><code> - </code></emphasis>to disentangle signal from background via an extended maximum likelihood fit and with a tool to access the quality and validity of the fit producing distributions for the control variables. (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369, 2005).</para>
</sect2>

<sect2>
<title>Multi-variate Analysis Classes</title>
<para><emphasis role="bold"><code>TMultiLayerPerceptron</code></emphasis> is a Neural Network class (see for more details the chapter “Neural Networks”).</para>
<para><emphasis role="bold"><code>TPrincipal</code></emphasis> provides the Principal Component Analysis.</para>
<para><emphasis role="bold"><code>TRobustEstimator</code></emphasis> is a robust method for minimum covariance determinant estimator (MCD).</para>
<para><emphasis role="bold"><code>TMVA</code></emphasis> is a package for multivariate data analysis (see  <uri xmlns:xlink="http://tmva.sourceforge.net/docu/TMVAUsersGuide.pdf">http://tmva.sourceforge.net/docu/TMVAUsersGuide.pdf</uri> the User’s Guide).</para>
</sect2>

</sect1>

</chapter>



