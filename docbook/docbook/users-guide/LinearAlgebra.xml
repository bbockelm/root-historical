<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0">
<title>Linear Algebra in ROOT</title>
<para>The linear algebra package is supposed to give a complete environment in ROOT to perform calculations like equation solving and eigenvalue decompositions. Most calculations are performed in double precision. For backward compatibility, some classes are also provided in single precision like <emphasis role="bold"><code>TMatrixF</code></emphasis>, <emphasis role="bold"><code>TMatrixFSym</code></emphasis> and <emphasis role="bold"><code>TVectorF</code></emphasis>. Copy constructors exist to transform these into their double precision equivalent, thereby allowing easy access to decomposition and eigenvalue classes, only available in double precision.</para>
<para>The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex numbers will take about a factor of 8 more computations, the alternative of introducing a set of complex classes in this non-template library would create a major maintenance challenge.</para>
<para>Another choice was to fill in both the upper-right corner and the bottom-left corner of a symmetric matrix. Although most algorithms use only the upper-right corner, implementation of the different matrix views was more straightforward this way. When stored only the upper-right part is written to file.</para>
<para>For a detailed description of the interface, the user should look at the root reference guide at:  <uri xmlns:xlink="http://root.cern.ch/root/Reference.html">http://root.cern.ch/root/Reference.html</uri></para>

<sect1>
<title>Overview of Matrix Classes</title>
<para>The figure below shows an overview of the classes available in the linear algebra library,<code> libMatrix.so</code>. At the center is the base class <emphasis role="bold"><code>TMatrixDBase</code></emphasis> from which three different matrix classes, <emphasis role="bold"><code>TMatrixD</code></emphasis>, <emphasis role="bold"><code>TMatrixDSym</code></emphasis> and <emphasis role="bold"><code>TMatrixDFSparse</code></emphasis> derive. The user can define customized matrix operations through the classes <emphasis role="bold"><code>TElementActionD</code></emphasis> and <emphasis role="bold"><code>TElementsPosActionD</code></emphasis>.</para>

<figure><title>Overview of matrix classes</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0300012D.png" width="289.25pt" depth="196.75pt"/></imageobject></inlinemediaobject>
</para>
</figure>

<para>Reference to different views of the matrix can be created through the classes on the right-hand side, see “Matrix Views”. These references provide a natural connection to vectors.</para>
<para>Matrix decompositions (used in equation solving and matrix inversion) are available through the classes on the left-hand side (see “Matrix Decompositions”). They inherit from the <emphasis role="bold"><code>TDecompBase</code></emphasis> class. The Eigen Analysis is performed through the classes at the top, see “Matrix Eigen Analysis”. In both cases, only some matrix types can be analyzed. For instance, <emphasis role="bold"><code>TDecompChol</code></emphasis> will only accept symmetric matrices as defined <emphasis role="bold"><code>TMatrixDSym</code></emphasis>. The assignment operator behaves somewhat different than of most other classes. The following lines will result in an error: </para>

<programlisting language="c++">
<code>TMatrixD a(3,4);</code>
<code>TMatrixD b(5,6);</code>
<code>b = a;</code>
</programlisting>

<para>It required to first resize matrix b to the shape of <code>a</code>.</para>

<programlisting language="c++">
TMatrixD a(3,4);
TMatrixD b(5,6);
b.ResizeTo(a);
b = a;
</programlisting>

</sect1>

<sect1>
<title>Matrix Properties</title>
<para>A matrix has five properties, which are all set in the constructor:</para>
<itemizedlist>
<listitem><para><code>precision</code> - float or double. In the first case you will use the <emphasis role="bold"><code>TMatrixF</code></emphasis> class family, in the latter case the <emphasis role="bold"><code>TMatrixD</code></emphasis> one;</para></listitem>
<listitem><para><code>type</code> - general (<emphasis role="bold"><code>TMatrixD</code></emphasis>), symmetric (<emphasis role="bold"><code>TMatrixDSym</code></emphasis>) or sparse (<emphasis role="bold"><code>TMatrixDSparse</code></emphasis>);</para></listitem>
<listitem><para><code>size</code> - number of rows and columns;</para></listitem>
<listitem><para><code>index</code> - range start of row and column index. By default these start at zero;</para></listitem>
<listitem><para><code>sparse</code> <code>map</code> - this property is only relevant for a sparse matrix. It indicates where elements are unequal zero.</para></listitem>
</itemizedlist>
<sect2>
<title>Accessing Properties</title>
<para>The following table shows the methods to access the information about the relevant matrix property:</para>
<informaltable frame="all">
<tgroup cols="2">
<colspec colwidth="3439*" colname="column-1"/>
<colspec colwidth="5430*" colname="column-2"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Method</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Descriptions</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Int_t GetRowLwb</code>






<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>row lower-bound index</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Int_t GetRowUpb</code>






<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>row upper-bound index</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Int_t GetNrows</code>








<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>number of rows</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Int_t GetColLwb</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>column lower-bound index</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Int_t GetColUpb</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>column upper-bound index</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Int_t GetNcols</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>number of columns</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Int_t GetNoElements</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>number of elements, for a dense matrix this equals: <code>fNrows x fNcols</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Double_t GetTol</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>tolerance number which is used in decomposition operations</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Int_t *GetRowIndexArray</code>








<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>for sparse matrices, access to the row index of <code>fNrows+1</code> entries</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Int_t *GetColIndexArray</code>








<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>for sparse matrices, access to the column index of <code>fNelems</code> entries</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>The last two methods in this table are specific to the sparse matrix, which is implemented according to the Harwell-Boeing format. Here, besides the usual shape/size descriptors of the matrix like <code>fNrows</code>, <code>fRowLwb</code>, <code>fNcols</code> and <code>fColLwb</code>, we also store a row index, <code>fRowIndex</code> and column index, <code>fColIndex</code> for the elements unequal zero:</para>
<informaltable frame="all">
<tgroup cols="2">
<colspec colwidth="3439*" colname="column-1"/>
<colspec colwidth="5430*" colname="column-2"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>fRowIndex[0,..,fNrows]:</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Stores for each row the index range of the elements in the data and column array</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>fColIndex[0,..,fNelems-1]:</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Stores the column number for each data element   != 0.</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>The code to print all matrix elements unequal zero would look like:</para>

<programlisting language="c++">
TMatrixDSparse a;
const Int_t *rIndex = a.GetRowIndexArray();
const Int_t *cIndex = a.GetColIndexArray();
const Double_t *pData = a.GetMatrixArray();
for (Int_t irow = 0; irow &lt; a.getNrows(); irow++) {
const Int_t sIndex = rIndex[irow];
const Int_t eIndex = rIndex[irow+1];
for (Int_t index = sIndex; index &lt; eIndex; index++) {
const Int_t icol = cIndex[index];
const Double_t data = pData[index];
printf("data(%d,%d) = %.4en",irow+a.GetfRowLwb(),
icol+a.GetColLwb(),data);
}
}
</programlisting>

</sect2>

<sect2>
<title>Setting Properties</title>
<para>The following table shows the methods to set some of the matrix properties. The resizing procedures will maintain the matrix elements that overlap with the old shape. The optional last argument <code>nr_zeros</code> is only relevant for sparse matrices. If supplied, it sets the number of non-zero elements. If it is smaller than the number overlapping with the old matrix, only the first (row-wise)<code> nr_zeros</code> are copied to the new matrix.</para>
<informaltable frame="all">
<tgroup cols="2">
<colspec colwidth="4887*" colname="column-1"/>
<colspec colwidth="3982*" colname="column-2"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Method</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Descriptions</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>SetTol</code>





<code>(Double_t tol)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>set the tolerance number</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>ResizeTo</code>





<code>(Int_t nrows,Int_t ncols,</code>
</para>
<para>
<code>         Int_t nr_nonzeros=-1)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>change matrix shape to <code>nrows</code> × <code>ncols</code>. Index will start at zero</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>ResizeTo(Int_t row_lwb,Int_t row_upb,</code>
</para>
<para>

<code>Int_t col_lwb,Int_t col_upb,</code>
</para>
<para>

<code>Int_t nr_nonzeros=-1)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>change matrix shape to </para>
<para><code>row_lwb:row_upb</code> × <code>col_lwb:col_upb</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>SetRowIndexArray</code>






<code>(Int_t *data)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>for sparse matrices, set the row index. The array data should contains at least<code> fNrows+1</code> entries column lower-bound index</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>SetColIndexArray</code>







<code>(Int_t *data)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>for sparse matrices, set the column index. The array data should contains at least <code>fNelems</code> entries</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>SetSparseIndex</code>





<code>(Int_t nelems new)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>allocate memory for a sparse map of <code>nelems_new</code> elements and copy (if exists) at most <code>nelems_new</code> matrix elements over to the new structure</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>SetSparseIndex</code>





<code>(const TMatrixDBase &amp;a)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>copy the sparse map from matrix <code>a</code> Note that this can be a dense matrix!</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>SetSparseIndexAB</code>





<code>(const TMatrixDSparse &amp;a,</code>
<code>
const TMatrixDSparse &amp;b)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>set the sparse map to the same of the map of matrix <code>a</code> and <code>b</code></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>The second half of the table is only relevant for sparse matrices. These methods define the sparse structure. It should be clear that a call to any of these methods has to be followed by a <emphasis role="bold"><code>SetMatrixArray</code></emphasis> (...) which will supply the matrix data, see the next chapter “Creating and Filling a Matrix”.</para>
</sect2>
</sect1>

<sect1>
<title>Creating and Filling a Matrix</title>
<para>The matrix constructors are listed in the next table. In the simplest ones, only the number of rows and columns is given. In a slightly more elaborate version, one can define the row and column index range. Finally, one can also define the matrix data in the constructor. In Matrix Operators and Methods we will encounter more fancy constructors that will allow arithmetic operations.</para>
<informaltable frame="all">
<tgroup cols="1">
<colspec colwidth="9023*" colname="column-1"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixD(Int_t nrows,Int_t ncols)</code>
</para>
<para>
<code>TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb)</code>
</para>
<para>
<code>TMatrixD(Int_t nrows,Int_t ncols,const Double_t *data, Option_t option="")</code>
</para>
<para>
<code>TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,</code>
</para>
<para>
<code>         const Double_t *data,Option_t *option="")</code>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDSym(Int_t nrows)</code>
</para>
<para>
<code>TMatrixDSym(Int_t row_lwb,Int_t row_upb) </code>
</para>
<para>
<code>TMatrixDSym(Int_t nrows,const Double_t *data,Option_t *option="")</code>
</para>
<para>
<code>TMatrixDSym(Int_t row_lwb,Int_t row_upb,const Double_t *data, Option_t *opt="")            </code>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDSparse(Int_t nrows,Int_t ncols)</code>
</para>
<para>
<code>TMatrixDSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb, Int_t col_upb)</code>
</para>
<para>
<code>TMatrixDSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,</code>
</para>
<para>
<code>               Int_t nr_nonzeros,Int_t *row,Int_t *col,Double_t *data)</code>
</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>If only the matrix shape is defined in the constructor, matrix data has to be supplied and possibly the sparse structure. In “Setting Properties” was discussed how to set the sparse structure.</para>
<para>Several methods exist to fill a matrix with data:</para>
<para><code>SetMatrixArray(const Double_t*data,Option_t*option="")</code>, copies the array data. If option<code>="F"</code>, the array fills the matrix column-wise else row-wise. This option is only implemented for <emphasis role="bold"><code>TMatrixD</code></emphasis> and <emphasis role="bold"><code>TMatrixDSym</code></emphasis>. It is expected that the array data contains at least <code>fNelems</code> entries.</para>
<para><code>SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Double_t *data)</code>, is only available for sparse matrices. The three arrays should each contain <code>nr</code> entries with row index, column index and data entry. Only the entries with non-zero data value are inserted!</para>
<para><code>operator() </code>or <code>operator[]</code>, these operators provide the easiest way to fill a matrix but are in particular for a sparse matrix expensive. If no entry for slot (<code>i,j</code>) is found in the sparse index table it will be entered, which involves some memory management! Therefore, before invoking this method in a loop it is wise to set the index table first through a call to the <code>SetSparseIndex</code> method.</para>
<para><code>SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixDBase &amp;source)</code>, the matrix to be inserted at position <code>(row_lwb,col_lwb)</code> can be both, dense or sparse.</para>
<para><code>Use(...)</code> allows inserting another matrix or data array without actually copying the data. Next table shows the different flavors for the different matrix types.</para>
<informaltable frame="all">
<tgroup cols="1">
<colspec colwidth="8869*" colname="column-1"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Use(TMatrixD &amp;a)</code>
</para>
<para>
<code>Use(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,Double_t *data)</code>
</para>
<para>
<code>Use(Int_t nrows,Int_t ncols,Double_t *data)</code>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Use(TMatrixDSym &amp;a)</code>
</para>
<para>
<code>Use(Int_t nrows,Double_t *data)</code>
</para>
<para>
<code>Use(Int_t row_lwb,Int_t row_upb,Double_t *data)</code>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Use(TMatrixDSparse &amp;a)</code>
</para>
<para>
<code>Use(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,Int_t nr_nonzeros,</code>
</para>
<para>
<code>    Int_t *pRowIndex,Int_t *pColIndex,Double_t *pData)</code>
</para>
<para>
<code>Use(Int_t nrows,Int_t ncols,Int_t nr_nonzeros,Int_t *pRowIndex,</code>
</para>
<para>
<code>    Int_t *pColIndex,Double_t *pData)</code>
</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>Below follow a few examples of creating and filling a matrix. First we create a Hilbert matrix by copying an array.</para>

<programlisting language="c++">
TMatrixD h(5,5);
TArrayD data(25);
for (Int_t = 0; i &lt; 25; i++) {
const Int_t ir = i/5;
const Int_t ic = i%5;
data[i] = 1./(ir+ic);
}
h.SetMatrixArray(data.GetArray());
</programlisting>

<para>We also could assign the data array to the matrix without actually copying it.</para>

<programlisting language="c++">
TMatrixD h; h.Use(5,5,data.GetArray());
h.Invert();
</programlisting>

<para>The array <code>data</code> now contains the inverted matrix. Finally, create a unit matrix in sparse format.</para>

<programlisting language="c++">
TMatrixDSparse unit1(5,5);
TArrayI row(5),col(5);
for (Int_t i = 0; i &lt; 5; i++) row[i] = col[i] = i;
TArrayD data(5); data.Reset(1.);
unit1.SetMatrixArray(5,row.GetArray(),col.GetArray(),data.GetArray());

TMatrixDSparse unit2(5,5);
unit2.SetSparseIndex(5);
unit2.SetRowIndexArray(row.GetArray());
unit2.SetColIndexArray(col.GetArray());
unit2.SetMatrixArray(data.GetArray());
</programlisting>

</sect1>

<sect1>
<title>Matrix Operators and Methods</title>
<para>It is common to classify matrix/vector operations according to BLAS (Basic Linear Algebra Subroutines) levels, see following table:</para>
<informaltable frame="all">
<tgroup cols="4">
<colspec colwidth="1428*" colname="column-1"/>
<colspec colwidth="2376*" colname="column-2"/>
<colspec colwidth="1902*" colname="column-3"/>
<colspec colwidth="3163*" colname="column-4"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>BLAS level</para>
</entry>
<entry rowsep="1" colsep="1">
<para>operations</para>
</entry>
<entry rowsep="1" colsep="1">
<para>example</para>
</entry>
<entry rowsep="1" colsep="1">
<para>floating-point operations</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>1</para>
</entry>
<entry rowsep="1" colsep="1">
<para>vector-vector</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>x</code>
<code>T</code>
<code>y</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<emphasis role="italic">n</emphasis>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>2</para>
</entry>
<entry rowsep="1" colsep="1">
<para>matrix-vector matrix</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0800012E.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>
<code> x</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para><emphasis role="italic">n</emphasis>2</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>3</para>
</entry>
<entry rowsep="1" colsep="1">
<para>matrix-matrix</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0800012F.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>

<inlinemediaobject><imageobject><imagedata fileref="pictures/08000130.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para><emphasis role="italic">n</emphasis>3</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>Most level 1, 2 and 3 BLAS are implemented. However, we will present them not according to that classification scheme it is already boring enough.</para>

<sect2>
<title>Arithmetic Operations between Matrices</title>
<informaltable frame="all">
<tgroup cols="3">
<colspec colwidth="2353*" colname="column-1"/>
<colspec colwidth="4200*" colname="column-2"/>
<colspec colwidth="2316*" colname="column-3"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Description</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Format</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Comment</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>element </code>
</para>
<para>
<code>wise sum</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>C=A+B</code>
</para>
<para>
<code>A+=B </code>
</para>
<para>
<code>Add</code>


<code>(A,alpha,B) </code>
</para>
<para>
<code>TMatrixD(A,TMatrixD::kPlus,B) </code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>
</code>
<code>overwrites</code>

<inlinemediaobject><imageobject><imagedata fileref="pictures/08000131.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>

</para>
<para>
<code>A += α B </code>
<code>constructor</code>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>element wise subtraction</code>




</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>C=A-B</code>
</para>
<para>
<code>A-=B </code>
</para>
<para>
<code>TMatrixD(A,TMatrixD::kMinus,B) </code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>overwrites</code>

<inlinemediaobject><imageobject><imagedata fileref="pictures/08000132.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>
</para>
<para>
<code>constructor</code>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>matrix multiplication</code>


</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>C=A*B</code>
</para>
<para>
<code>A*=B </code>
</para>
<para>
<code>C.Mult(A,B)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>overwrites</code>

<inlinemediaobject><imageobject><imagedata fileref="pictures/08000133.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixD(A,</code>
<code>TMatrixD::kMult,B)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>constructor of </code>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000134.png" width="27.3pt" depth="13.05pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixD(A,</code>
<code>TMatrixD::kTransposeMult</code>
<code>,B)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>constructor of </code>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000135.png" width="32.9pt" depth="14.9pt"/></imageobject></inlinemediaobject>

</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixD(A,</code>
<code>TMatrixD::kMultTranspose</code>
<code>,B)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>constructor of </code>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000136.png" width="29.8pt" depth="14.3pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>element wise</code>
</para>
<para>
<code>multiplication</code>
</para>
<para>
<code>element wise division</code>



</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>ElementMult(A,B) </code>
</para>
<para>
<code>ElementDiv(A,B)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>A(i,j)*= B(i,j)</code>
</para>
<para>
<code>A(i,j)/= B(i,j)</code>
</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect2>

<sect2>
<title>Arithmetic Operations between Matrices and Real Numbers</title>
<informaltable frame="all">
<tgroup cols="3">
<colspec colwidth="2896*" colname="column-1"/>
<colspec colwidth="2172*" colname="column-2"/>
<colspec colwidth="3801*" colname="column-3"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Description</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Format</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Comment</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>element wise</code>


<code> sum</code>


</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>C=r+A</code>
</para>
<para>
<code>C=A+r</code>
</para>
<para>
<code>A+=r</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>overwrites</code>

<inlinemediaobject><imageobject><imagedata fileref="pictures/08000137.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>element wise subtraction</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>C=r-A</code>
</para>
<para>
<code>C=A-r</code>
</para>
<para>
<code>A-=r</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>overwrites <inlinemediaobject><imageobject><imagedata fileref="pictures/08000138.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>matrix multiplication</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>C=r*A</code>
</para>
<para>
<code>C=A*r</code>
</para>
<para>
<code>A*=r</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>overwrites <inlinemediaobject><imageobject><imagedata fileref="pictures/08000139.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect2>

<sect2>
<title>Comparisons and Boolean Operations</title>
<para>The following table shows element wise comparisons between two matrices:</para>
<informaltable frame="all">
<tgroup cols="3">
<colspec colwidth="4344*" colname="column-1"/>
<colspec colwidth="1086*" colname="column-2"/>
<colspec colwidth="3439*" colname="column-3"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Format </para>
</entry>
<entry rowsep="1" colsep="1">
<para>Output</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Description</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A == B</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>Bool_t</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>equal to</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A != B </code>
</para>
<para>
<code>A &gt; B </code>
</para>
<para>
<code>A &gt;= B </code>
</para>
<para>
<code>A &lt; B </code>
</para>
<para>
<code>A &lt;= B</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>matrix </para>
<para>matrix </para>
<para>matrix </para>
<para>matrix </para>
<para>matrix</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Not equal </para>
<para>Greater than </para>
<para>Greater than or equal to </para>
<para>Smaller than </para>
<para>Smaller than or equal to</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>AreCompatible(A,B) </code>
</para>
<para/>
<para>
<code>Compare(A,B) </code>
</para>
<para/>
<para>
<code>VerifyMatrixIdentity(A,B,verb, maxDev) </code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para/>
<para>
<code>Bool_t</code>
<code>
</code>
</para>
<para/>
<para/>
<para>
<code>Bool_t</code>
</para>
<para/>
</entry>
<entry rowsep="1" colsep="1">
<para/>
<para>Compare matrix properties </para>
<para/>
<para>return summary of comparison </para>
<para/>
<para>Check matrix identity within <code>maxDev</code> tolerance</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para/>
<para>
The following table shows element wise comparisons between matrix and real:</para>
<informaltable frame="all">
<tgroup cols="3">
<colspec colwidth="4344*" colname="column-1"/>
<colspec colwidth="1086*" colname="column-2"/>
<colspec colwidth="3439*" colname="column-3"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Format </para>
</entry>
<entry rowsep="1" colsep="1">
<para>Output</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Description</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A == r</code>
</para>
<para>A != r </para>
<para>A &gt; r </para>
<para>A &gt;= r </para>
<para>A &lt; r </para>
<para>A &lt;= r </para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>Bool_t</code>
</para>
<para>
<code>Bool_t</code>
</para>
<para>
<code>Bool_t Bool_t</code>
</para>
<para>
<code>Bool_t Bool_t</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>equal to</para>
<para>Not equal </para>
<para>Greater than </para>
<para>Greater than or equal to </para>
<para>Smaller than </para>
<para>Smaller than or equal to</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>VerifyMatrixValue(A,r,verb, maxDev) </code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>Bool_t</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Compare matrix value with r within <code>maxDev</code> tolerance</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect2>

<sect2>
<title>Matrix Norms</title>
<informaltable frame="all">
<tgroup cols="3">
<colspec colwidth="2508*" colname="column-1"/>
<colspec colwidth="1474*" colname="column-2"/>
<colspec colwidth="4706*" colname="column-3"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Format </para>
</entry>
<entry rowsep="1" colsep="1">
<para>Output</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Description</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.RowNorm</code>





<code>()</code>
</para>
<para/>
<para/>
<para/>
<para>
<code>A.NormInf</code>





<code>()</code>
</para>
<para/>
<para/>
<para>
<code>A.ColNorm</code>





<code>()</code>
</para>
<para/>
<para/>
<para>
<code>A.Norm1</code>





<code>()</code>
</para>
<para/>
<para/>
<para>
<code>A.E2Norm</code>





<code>()</code>
</para>
<para/>
<para/>
<para>
<code>A.NonZeros</code>





<code>()</code>
</para>
<para/>
<para>
<code>A.Sum</code>





<code>()</code>
</para>
<para/>
<para>
<code>A.Min</code>





<code>()</code>
</para>
<para/>
<para>
<code>A.Max</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>Double_t</code>
</para>
<para>

</para>
<para/>
<para/>
<para>
<code>Double_t</code>
</para>
<para/>
<para/>
<para>
<code>Double_t</code>
</para>
<para/>
<para/>
<para>
<code>Double_t</code>
</para>
<para/>
<para/>
<para>
<code>Double_t</code>
</para>
<para/>
<para/>
<para>
<code>Int_t</code>
</para>
<para/>
<para>
<code>Double_t</code>
</para>
<para/>
<para>
<code>Double_t</code>
</para>
<para/>
<para>
<code>Double_t</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>norm induced by the infinity vector norm, max<emphasis role="italic">i</emphasis><inlinemediaobject><imageobject><imagedata fileref="pictures/0800013A.png" width="45.3pt" depth="21.7pt"/></imageobject></inlinemediaobject></para>
<para>max<emphasis role="italic">i</emphasis><inlinemediaobject><imageobject><imagedata fileref="pictures/0800013B.png" width="47.15pt" depth="21.7pt"/></imageobject></inlinemediaobject> </para>
<para/>
<para>norm induced by the 1 vector norm, max<emphasis role="italic">j</emphasis><inlinemediaobject><imageobject><imagedata fileref="pictures/0800013C.png" width="45.3pt" depth="21.7pt"/></imageobject></inlinemediaobject></para>
<para>max<emphasis role="italic">j</emphasis><inlinemediaobject><imageobject><imagedata fileref="pictures/0800013D.png" width="45.3pt" depth="21.7pt"/></imageobject></inlinemediaobject> </para>
<para/>
<para>Square of the Euclidean norm,</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0800013E.png" width="45.95pt" depth="19.85pt"/></imageobject></inlinemediaobject>
</para>
<para>number of elements unequal zero</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0800013F.png" width="45.95pt" depth="19.85pt"/></imageobject></inlinemediaobject>
</para>
<para>min<emphasis role="italic">ij</emphasis> <inlinemediaobject><imageobject><imagedata fileref="pictures/08000140.png" width="22.95pt" depth="19.85pt"/></imageobject></inlinemediaobject></para>
<para>max<emphasis role="italic">ij</emphasis> <inlinemediaobject><imageobject><imagedata fileref="pictures/08000141.png" width="22.95pt" depth="19.85pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para/>
<para>
<code>A.NormByColumn</code>





<code>(v,"D") </code>
</para>
<para/>
<para/>
<para>
<code>A.NormByRow</code>





<code>(v,"D")</code>
</para>
<para/>
<para/>
</entry>
<entry rowsep="1" colsep="1">
<para/>
<para>
<code>TMatrixD</code>
</para>
<para/>
<para/>
<para>
<code>TMatrixD</code>
</para>
<para/>
<para/>
</entry>
<entry rowsep="1" colsep="1">
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/08000142.png" width="42.2pt" depth="19.25pt"/></imageobject></inlinemediaobject>, divide each matrix column by vector v. If the second argument is “<code>M</code>“, the column is multiplied.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/08000143.png" width="42.85pt" depth="19.25pt"/></imageobject></inlinemediaobject>, divide each matrix row by vector v. If the second argument is “<code>M</code>“, the row is multiplied.</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect2>

<sect2>
<title>Miscellaneous Operators</title>
<informaltable frame="all">
<tgroup cols="3">
<colspec colwidth="3620*" colname="column-1"/>
<colspec colwidth="1200*" colname="column-2"/>
<colspec colwidth="3868*" colname="column-3"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Format </para>
</entry>
<entry rowsep="1" colsep="1">
<para>Output</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Description</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.Zero</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixX</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000144.png" width="34.15pt" depth="19.25pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.Abs</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixX</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000145.png" width="62.05pt" depth="21.7pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.Sqr</code>







<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixX</code>
</para>
<para/>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000146.png" width="52.15pt" depth="19.85pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.Sqrt</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixX</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000147.png" width="57.7pt" depth="21.7pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.UnitMatrix</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixX</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/08000148.png" width="32.9pt" depth="19.25pt"/></imageobject></inlinemediaobject>for <emphasis role="italic">i ==j</emphasis> else 0  </para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.Randomize</code>





<code>(alpha,beta,seed)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixX</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/08000149.png" width="117.3pt" depth="19.25pt"/></imageobject></inlinemediaobject>, a random matrix is generated with elements uniformly distributed between α and β</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.</code>


<code>T</code>



<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixX</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0800014A.png" width="42.2pt" depth="19.25pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.Transpose</code>





<code>(B)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixX</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/0800014B.png" width="42.2pt" depth="19.25pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.Invert</code>











<code>(&amp;det)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixX</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Invert matrix A. If the optional pointer to the <code>Double_t</code> argument <code>det</code> is supplied, the matrix determinant is calculated.</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.InvertFast</code>











<code>(&amp;det)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixX</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>like Invert but for matrices </para>
<para>i =(6x6)a faster but less accurate Cramer algorithm is used</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.Rank1Update</code>











<code>(v,alpha)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixX</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Perform with vector v a rank 1 operation on the matrix: <inlinemediaobject><imageobject><imagedata fileref="pictures/0800014C.png" width="83.8pt" depth="16.15pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.RandomizePD</code>






<code> (alpha,beta,seed)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixX</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/0800014D.png" width="112.95pt" depth="19.25pt"/></imageobject></inlinemediaobject>, a </para>
<para>random symmetric positive-definite matrix is generated with elements uniformly distributed between<inlinemediaobject><imageobject><imagedata fileref="pictures/0800014E.png" width="11.8pt" depth="11.15pt"/></imageobject></inlinemediaobject>and<inlinemediaobject><imageobject><imagedata fileref="pictures/0800014F.png" width="11.8pt" depth="16.15pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>Output <emphasis role="bold"><code>TMatrixX</code></emphasis> indicates that the returned matrix is of the same type as <code>A</code>, being <emphasis role="bold"><code>TMatrixD</code></emphasis>, <emphasis role="bold"><code>TMatrixDSym</code></emphasis> or <emphasis role="bold"><code>TMatrixDSparse</code></emphasis>. Next table shows miscellaneous operations for <emphasis role="bold"><code>TMatrixD</code></emphasis>.</para>
<informaltable frame="all">
<tgroup cols="3">
<colspec colwidth="3620*" colname="column-1"/>
<colspec colwidth="1267*" colname="column-2"/>
<colspec colwidth="3801*" colname="column-3"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Format </para>
</entry>
<entry rowsep="1" colsep="1">
<para>Output</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Description</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>A.Rank1Update(v1,v2,alpha)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixD</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Perform with vector v1 and v2, a rank 1 operation on the matrix: <inlinemediaobject><imageobject><imagedata fileref="pictures/08000150.png" width="85.65pt" depth="16.15pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect2>
</sect1>

<sect1>
<title>Matrix Views</title>
<para>Another way to access matrix elements is through the matrix-view classes, <emphasis role="bold"><code>TMatrixDRow</code></emphasis>, <emphasis role="bold"><code>TMatrixDColumn</code></emphasis>, <emphasis role="bold"><code>TMatrixDDiag</code></emphasis> and <emphasis role="bold"><code>TMatrixDSub</code></emphasis> (each has also a const version which is obtained by simply appending const to the class name). These classes create a reference to the underlying matrix, so no memory management is involved. The next table shows how the classes access different parts of the matrix:</para>
<informaltable frame="all">
<tgroup cols="2">
<colspec colwidth="3588*" colname="column-1"/>
<colspec colwidth="2520*" colname="column-2"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>class</para>
</entry>
<entry rowsep="1" colsep="1">
<para>view</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDRow const(X,i)</code>
</para>
<para>
<code>TMatrixDRow(X,i)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000151.png" width="94.95pt" depth="76.35pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDColumn const(X,j)</code>
</para>
<para>
<code>TMatrixDColumn(X,j)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000152.png" width="94.95pt" depth="77.6pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDDiag const(X)</code>
</para>
<para>
<code>TMatrixDDiag(X)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000153.png" width="94.95pt" depth="78.85pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDSub const(X,i,l,j,k)</code>
</para>
<para>
<code>TMatrixDSub(X,i,l,j,k)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000154.png" width="94.95pt" depth="76.35pt"/></imageobject></inlinemediaobject>
</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<sect2>
<title>View Operators</title>
<para>For the matrix views <emphasis role="bold"><code>TMatrixDRow</code></emphasis>, <emphasis role="bold"><code>TMatrixDColumn</code></emphasis> and <emphasis role="bold"><code>TMatrixDDiag</code></emphasis>, the necessary assignment operators are available to interact with the vector class <emphasis role="bold"><code>TVectorD</code></emphasis>. The sub matrix view <emphasis role="bold"><code>TMatrixDSub</code></emphasis> has links to the matrix classes <emphasis role="bold"><code>TMatrixD</code></emphasis> and <emphasis role="bold"><code>TMatrixDSym</code></emphasis>. The next table summarizes how the access individual matrix elements in the matrix views:</para>
<informaltable frame="all">
<tgroup cols="2">
<colspec colwidth="4706*" colname="column-1"/>
<colspec colwidth="4163*" colname="column-2"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Format </para>
</entry>
<entry rowsep="1" colsep="1">
<para>Comment</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDRow(A,i)(j)</code>
</para>
<para>
<code>TMatrixDRow(A,i)[j]</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>element <inlinemediaobject><imageobject><imagedata fileref="pictures/08000155.png" width="16.15pt" depth="19.25pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDColumn(A,j)(i)</code>
</para>
<para>
<code>TMatrixDColumn(A,j)[i]</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>element <inlinemediaobject><imageobject><imagedata fileref="pictures/08000156.png" width="16.15pt" depth="19.25pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDDiag(A(i)</code>
</para>
<para>
<code>TMatrixDDiag(A[i]</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>element <inlinemediaobject><imageobject><imagedata fileref="pictures/08000157.png" width="16.15pt" depth="18pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDSub(A(i)</code>
</para>
<para>
<code>TMatrixDSub(A,rl,rh,cl,ch)(i,j)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>element <inlinemediaobject><imageobject><imagedata fileref="pictures/08000158.png" width="16.15pt" depth="18pt"/></imageobject></inlinemediaobject></para>
<para>element <inlinemediaobject><imageobject><imagedata fileref="pictures/08000159.png" width="39.1pt" depth="19.25pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>The next two tables show the possible operations with real numbers, and the operations between the matrix views:</para>
<informaltable frame="all">
<tgroup cols="3">
<colspec colwidth="1320*" colname="column-1"/>
<colspec colwidth="3386*" colname="column-2"/>
<colspec colwidth="4163*" colname="column-3"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Description</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Format</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Comment</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>assign real</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDRow(A,i) = r</code>
</para>
<para>
<code>TMatrixDColumn(A,j) = r</code>
</para>
<para>
<code>TMatrixDDiag(A) = r</code>
</para>
<para>
<code>TMatrixDSub(A,i,l,j,k) = r</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>row <inlinemediaobject><imageobject><imagedata fileref="pictures/0800015A.png" width="6.85pt" depth="13.05pt"/></imageobject></inlinemediaobject></para>
<para>column <inlinemediaobject><imageobject><imagedata fileref="pictures/0800015B.png" width="8.7pt" depth="12.4pt"/></imageobject></inlinemediaobject></para>
<para>matrix diagonal </para>
<para>sub matrix</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>add real</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDRow(A,i) += r</code>
</para>
<para>
<code>TMatrixDColumn(A,j) += r</code>
</para>
<para>
<code>TMatrixDDiag(A) += r</code>
</para>
<para>
<code>TMatrixDSub(A,i,l,j,k) += r</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>row <inlinemediaobject><imageobject><imagedata fileref="pictures/0800015C.png" width="6.85pt" depth="13.05pt"/></imageobject></inlinemediaobject></para>
<para>column <inlinemediaobject><imageobject><imagedata fileref="pictures/0800015D.png" width="8.7pt" depth="12.4pt"/></imageobject></inlinemediaobject></para>
<para>matrix diagonal</para>
<para>sub matrix</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>multiply with</para>
<para>real</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDRow(A,i) *= r</code>
</para>
<para>
<code>TMatrixDColumn(A,j) *= r</code>
</para>
<para>
<code>TMatrixDDiag(A) *= r</code>
</para>
<para>
<code>TMatrixDSub(A,i,l,j,k) *= r</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>row <inlinemediaobject><imageobject><imagedata fileref="pictures/0800015E.png" width="6.85pt" depth="13.05pt"/></imageobject></inlinemediaobject></para>
<para>column <inlinemediaobject><imageobject><imagedata fileref="pictures/0800015F.png" width="8.7pt" depth="12.4pt"/></imageobject></inlinemediaobject></para>
<para>matrix diagonal</para>
<para>sub matrix</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para/>
<informaltable frame="all">
<tgroup cols="3">
<colspec colwidth="1320*" colname="column-1"/>
<colspec colwidth="3386*" colname="column-2"/>
<colspec colwidth="4163*" colname="column-3"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Description</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Format</para>
</entry>
<entry rowsep="1">
<para>Comment</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>add matrix slice</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDRow(A,i1) +=</code>
</para>
<para>
<code>TMatrixDRow const(B,i2)</code>
</para>
</entry>
<entry rowsep="1">
<para>add row <inlinemediaobject><imageobject><imagedata fileref="pictures/08000160.png" width="13.05pt" depth="13.65pt"/></imageobject></inlinemediaobject> to row <inlinemediaobject><imageobject><imagedata fileref="pictures/08000161.png" width="11.15pt" depth="13.65pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para/>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDColumn(A,j1) +=</code>
</para>
<para>
<code>TMatrixDColumn const(A,j2)</code>
</para>
</entry>
<entry rowsep="1">
<para>add column<inlinemediaobject><imageobject><imagedata fileref="pictures/08000162.png" width="16.15pt" depth="16.15pt"/></imageobject></inlinemediaobject> to column<inlinemediaobject><imageobject><imagedata fileref="pictures/08000163.png" width="13.65pt" depth="16.15pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para/>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDDiag(A) +=</code>
</para>
<para>
<code>TMatrixDDiag const(B)</code>
</para>
</entry>
<entry rowsep="1">
<para>add <inlinemediaobject><imageobject><imagedata fileref="pictures/08000164.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject> diagonal to <inlinemediaobject><imageobject><imagedata fileref="pictures/08000165.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject> diagonal</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>multiply matrix slice</para>
<para/>
</entry>
<entry colsep="1">
<para>
<code>TMatrixDRow(A,i1) *=</code>
</para>
<para>
<code>TMatrixDRow const(B,i2)</code>
</para>
</entry>
<entry>
<para>multiply row <inlinemediaobject><imageobject><imagedata fileref="pictures/08000166.png" width="13.05pt" depth="13.65pt"/></imageobject></inlinemediaobject> with row <inlinemediaobject><imageobject><imagedata fileref="pictures/08000167.png" width="11.15pt" depth="13.65pt"/></imageobject></inlinemediaobject> element wise</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para/>
</entry>
<entry colsep="1">
<para>
<code>TMatrixDColumn(A,j1) *=</code>
</para>
<para>
<code>TMatrixDColumn const(A,j2)</code>
</para>
</entry>
<entry>
<para>multiply column<inlinemediaobject><imageobject><imagedata fileref="pictures/08000168.png" width="16.15pt" depth="16.15pt"/></imageobject></inlinemediaobject> with column<inlinemediaobject><imageobject><imagedata fileref="pictures/08000169.png" width="13.65pt" depth="16.15pt"/></imageobject></inlinemediaobject> element wise</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para/>
</entry>
<entry colsep="1">
<para>
<code>TMatrixDDiag(A) *=</code>
</para>
<para>
<code>TMatrixDDiag const(B)</code>
</para>
</entry>
<entry>
<para>multiply <inlinemediaobject><imageobject><imagedata fileref="pictures/0800016A.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject> diagonal with <inlinemediaobject><imageobject><imagedata fileref="pictures/0800016B.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject> diagonal element wise</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para/>
</entry>
<entry colsep="1">
<para>
<code>TMatrixDSub(A,i1,l1,j1,k1) *=</code>
</para>
<para>
<code>TMatrixDSub(B,i2,l2,j2,k2)</code>
</para>
</entry>
<entry>
<para>multiply sub matrix of <inlinemediaobject><imageobject><imagedata fileref="pictures/0800016C.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject> with sub matrix of <inlinemediaobject><imageobject><imagedata fileref="pictures/0800016D.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para/>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixDSub(A,i,l,j,k) *= B</code>
</para>
</entry>
<entry rowsep="1">
<para>multiply sub matrix of <inlinemediaobject><imageobject><imagedata fileref="pictures/0800016E.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject> with matrix of <inlinemediaobject><imageobject><imagedata fileref="pictures/0800016F.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject></para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>In the current implementation of the matrix views, the user could perform operations on a symmetric matrix that violate the symmetry. No checking is done. For instance, the following code violates the symmetry.</para>

<programlisting language="c++">
TMatrixDSym A(5);
A.UnitMatrix();
TMatrixDRow(A,1)[0] = 1;
TMatrixDRow(A,1)[2] = 1;
</programlisting>

</sect2>

<sect2>
<title>View Examples</title>
<para>Inserting row <code>i1 </code>into row<code> i2</code> of matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/08000170.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject> can easily accomplished through:</para>

<programlisting language="c++">
TMatrixDRow(A,i1) = TMatrixDRow(A,i2)
</programlisting>

<para>Which more readable than:</para>

<programlisting language="c++">
const Int_t ncols = A.GetNcols();
Double_t *start = A.GetMatrixArray();
Double_t *rp1 = start+i*ncols;
const Double_t *rp2 = start+j*ncols;
while (rp1 &lt; start+ncols)
*rp1++ = *rp2++;
</programlisting>

<para>Check that the columns of a Haar -matrix of order <code>order</code> are indeed orthogonal:</para>

<programlisting language="c++">
const TMatrixD haar = THaarMatrixD(order);
TVectorD colj(1&lt;&lt;order);
TVectorD coll(1&lt;&lt;order);
for (Int_t j = haar.GetColLwb(); j &lt;= haar.GetColUpb(); j++) {
colj = TMatrixDColumn_const(haar,j);
Assert(TMath::Abs(colj*colj-1.0) &lt;= 1.0e-15);

for (Int_t l = j+1; l &lt;= haar.GetColUpb(); l++) {
coll = TMatrixDColumn_const(haar,l);
Assert(TMath::Abs(colj*coll) &lt;= 1.0e-15);
}
}
</programlisting>

<para>Multiplying part of a matrix with another part of that matrix (they can overlap)</para>

<programlisting language="c++">
TMatrixDSub(m,1,3,1,3) *= m.GetSub(5,7,5,7);
</programlisting>

</sect2>
</sect1>

<sect1>
<title>Matrix Decompositions</title>
<para>The linear algebra package offers several classes to assist in matrix decompositions. Each of the decomposition methods performs a set of matrix transformations to facilitate solving a system of linear equations, the formation of inverses as well as the estimation of determinants and condition numbers. More specifically the classes <emphasis role="bold"><code>TDecompLU</code></emphasis>, <emphasis role="bold"><code>TDecompBK</code></emphasis><emphasis role="bold"><code>, TDecompChol</code></emphasis>, <emphasis role="bold"><code>TDecompQRH</code></emphasis> and <emphasis role="bold"><code>TDecompSVD</code></emphasis> give a simple and consistent interface to the LU, Bunch-Kaufman, Cholesky, QR and SVD decompositions. All of these classes are derived from the base class <emphasis role="bold"><code>TDecompBase</code></emphasis> of which the important methods are listed in next table:</para>
<informaltable frame="all">
<tgroup cols="2">
<colspec colwidth="4706*" colname="column-1"/>
<colspec colwidth="4163*" colname="column-2"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Method</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Action</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Bool_t Decompose</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>perform the matrix decomposition</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Double_t Condition</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>calculate ||<emphasis role="italic">A</emphasis>||1 ||<emphasis role="italic">A</emphasis>-1||1, see “Condition number“ </para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>void Det</code>





<code>(Double_t &amp;d1,Double_t &amp;d2)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>the determinant is <code>d1</code> <code>2</code><inlinemediaobject><imageobject><imagedata fileref="pictures/08000171.png" width="13.05pt" depth="17.4pt"/></imageobject></inlinemediaobject>. Expressing the determinant this way makes under/over-flow very unlikely</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Bool_t Solve</code>





<code>(TVectorD &amp;b)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>solve <code>Ax=b</code>; vector<code> b</code> is supplied through the argument and replaced with solution <code>x</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TVectorD Solve(const TVectorD &amp;b,</code>
<code>
Bool_t &amp;ok)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>solve <code>Ax=b; x</code> is returned</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Bool_t Solve(TMatrixDColumn &amp;b)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>solve <code>Ax=column(B,j)</code>;<code> column(B,j)</code> is supplied through the argument and replaced with solution <code>x</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Bool_t TransSolve</code>





<code>(TVectorD &amp;b)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>solve <code>ATx=b;</code> vector <code>b</code> is supplied through the argument and replaced with solution <code>x</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TVectorD TransSolve(const TVectorD b,</code>
<code>
Bool_t &amp;ok)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>solve <code>ATx=b;</code> vector <code>x</code> is returned</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Bool_t TransSolve(TMatrixDColumn &amp;b)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>solve <code>ATx=column(B,j); column(B,j)</code> is supplied through the argument and replaced with solution <code>x</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>Bool_t MultiSolve</code>





<code>(TMatrixD &amp;B)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>solve <code>AX=B</code>. matrix <code>B</code> is supplied through the argument and replaced with solution <code>X</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>void Invert</code>





<code>(TMatrixD &amp;inv)</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>call to <code>MultiSolve</code> with as input argument the unit matrix. Note that for a matrix (<code>m </code>x <code>n</code>)− <code>A</code> with <code>m&gt;n</code>, a pseudo-inverse is calculated</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixD Invert()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>call to <code>MultiSolve</code> with as input argument the unit matrix. Note that for a matrix  (<code>m </code>x <code>n</code>)− <code>A</code> with <code>m&gt;n</code>, a pseudo-inverse is calculated</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>Through <emphasis role="bold"><code>TDecompSVD</code></emphasis> and <emphasis role="bold"><code>TDecompQRH</code></emphasis> one can solve systems for a (<code>m </code>x <code>n</code>) − <code>A</code> with <code>m&gt;n</code>. However, care has to be taken for methods where the input vector/matrix is replaced by the solution. For instance in the method <emphasis role="bold"><code>Solve(b)</code></emphasis>, the input vector should have length m but only the first n entries of the output contain the solution. For the <emphasis role="bold"><code>Invert(B)</code></emphasis> method, the input matrix B should have size (<code>m </code>x <code>m</code>) so that the returned (<code>m </code>x <code>n</code>) pseudo-inverse can fit in it.</para>
<para>The classes store the state of the decomposition process of matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/08000172.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject> in the user-definable part of <emphasis role="bold"><code>TObject::fBits</code></emphasis>, see the next table. This guarantees the correct order of the operations:</para>
<informaltable frame="all">
<tgroup cols="2">
<colspec colwidth="1630*" colname="column-1"/>
<colspec colwidth="7239*" colname="column-2"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>kMatrixSet</code>
</para>
<para/>
<para>
<code>kDecomposed</code>
</para>
<para/>
<para>
<code>kDetermined</code>
</para>
<para/>
<para>
<code>kCondition</code>
</para>
<para/>
<para>
<code>kSingular</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/08000173.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject><code>assigned</code> </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/08000174.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>decomposed, bit <code>kMatrixSet</code> must have been set.</para>
<para><code>det</code> (<inlinemediaobject><imageobject><imagedata fileref="pictures/08000175.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>) calculated, bit <code>kDecomposed</code> must have been set.</para>
<para>||<emphasis role="italic">A</emphasis>||1 ||<emphasis role="italic">A</emphasis>-1||1 is calculated bit <code>kDecomposed</code> must have been set.</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/08000176.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>is singular </para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>The state is reset by assigning a new matrix through   <code>SetMatrix(</code><emphasis role="bold"><code>TMatrixD</code></emphasis><code> &amp;A)</code> for <emphasis role="bold"><code>TDecompBK</code></emphasis> and <emphasis role="bold"><code>TDecompChol</code></emphasis> (actually<code> SetMatrix(</code><emphasis role="bold"><code>TMatrixDSym</code></emphasis><code> &amp;A)</code> and <code>SetMatrix(</code><emphasis role="bold"><code>TMatrixDSparse</code></emphasis><code> &amp;A)</code> for <emphasis role="bold"><code>TMatrixDSparse</code></emphasis>).</para>
<para>As the code example below shows, the user does not have to worry about the decomposition step before calling a solve method, because the decomposition class checks before invoking <code>Solve</code> that the matrix has been decomposed.</para>

<programlisting language="c++">
TVectorD b = ..;
TMatrixD a = ..;
.
TDecompLU lu(a);
Bool_t ok;
lu.Solve(b,ok);
</programlisting>

<para>In the next example, we show again the same decomposition but now performed in a loop and all necessary steps are manually invoked. This example also demonstrates another very important point concerning memory management! Note that the vector, matrix and decomposition class are constructed outside the loop since the dimensions of vector/matrix are constant. If we would have replaced <code>lu.SetMatrix(a)</code> by <emphasis role="bold"><code>TDecompLU</code></emphasis>         <code>lu(a)</code>, we would construct/deconstruct the array elements of <code>lu</code> on the stack<emphasis role="italic">.</emphasis></para>

<programlisting language="c++">
TVectorD b(n);
TMatrixD a(n,n);
TDecompLU lu(n);
Bool_t ok;
for (....) {
b = ..;
a = ..;
lu.SetMatrix(a);
lu.Decompose();
lu.Solve(b,ok);
}
</programlisting>

<sect2>
<title>Tolerances and Scaling</title>
<para>The tolerance parameter <code>fTol</code> (a member of the base class <emphasis role="bold"><code>TDecompBase</code></emphasis>) plays a crucial role in all operations of the decomposition classes. It gives the user a tool to monitor and steer the operations its default value is<code> ε</code> where <code>1+ε=1</code>.</para>
<para>If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set the tolerance with <code>SetTol</code> to an arbitrary small number. The tolerance number is used by each decomposition method to decide whether the matrix is near singular, except of course SVD that can handle singular matrices. This will be checked in a different way for any decomposition. For instance in LU, a matrix is considered singular in the solving stage when a diagonal element of the decomposed matrix is smaller than <code>fTol</code>. Here an important point is raised. The <code>Decompose()</code> method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.</para>
<para>If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices or vectors that are invalid. If one would like to monitor the tolerance parameter but not have the code stop in case of a number smaller than <code>fTol</code>, one could proceed as follows:</para>

<programlisting language="c++">
TVectorD b = ..;
TMatrixD a = ..;
.
TDecompLU lu(a);
Bool_t ok;
TVectorD x = lu.Solve(b,ok);
Int_t nr = 0;
while (!ok) {
lu.SetMatrix(a);
lu.SetTol(0.1*lu.GetTol());
if (nr++ &gt; 10) break;
x = lu.Solve(b,ok);
}
if (x.IsValid())
cout &lt;&lt; "solved with tol =" &lt;&lt; lu.GetTol() &lt;&lt; endl;
else
cout &lt;&lt; "solving failed " &lt;&lt; endl;
</programlisting>

<para>The observant reader will notice that by scaling the complete matrix by some small number the decomposition will detect a singular matrix. In this case, the user will have to reduce the tolerance number by this factor. (For CPU time saving we decided not to make this an automatic procedure).</para>
</sect2>

<sect2>
<title>Condition number</title>
<para>The numerical accuracy of the solution <code>x</code> in <code>Ax = b</code> can be accurately estimated by calculating the condition number <code>k</code> of matrix<inlinemediaobject><imageobject><imagedata fileref="pictures/08000177.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>, which is defined as:</para>
<para><emphasis role="italic">k</emphasis> = <inlinemediaobject><imageobject><imagedata fileref="pictures/08000178.png" width="21.1pt" depth="19.85pt"/></imageobject></inlinemediaobject><inlinemediaobject><imageobject><imagedata fileref="pictures/08000179.png" width="27.3pt" depth="20.5pt"/></imageobject></inlinemediaobject>  where <inlinemediaobject><imageobject><imagedata fileref="pictures/0800017A.png" width="21.1pt" depth="19.85pt"/></imageobject></inlinemediaobject>= <inlinemediaobject><imageobject><imagedata fileref="pictures/0800017B.png" width="60.85pt" depth="30.4pt"/></imageobject></inlinemediaobject></para>
<para>A good rule of thumb is that if the matrix condition number is 10n, the accuracy in <code>x </code>is <code>15−n</code> digits for double precision. </para>
<para>Hager devised an iterative method (W.W. Hager, Condition estimators, SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to determine<inlinemediaobject><imageobject><imagedata fileref="pictures/0800017C.png" width="29.15pt" depth="21.7pt"/></imageobject></inlinemediaobject> without actually having to calculate<inlinemediaobject><imageobject><imagedata fileref="pictures/0800017D.png" width="19.85pt" depth="14.9pt"/></imageobject></inlinemediaobject>. It is used when calling Condition ().</para>
<para>A code example below shows the usage of the condition number. The matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/0800017E.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject> is a (10x10) <emphasis role="italic">Hilbert</emphasis> matrix that is badly conditioned as its determinant shows. We construct a vector <code>b</code> by summing the matrix rows. Therefore, the components of the solution vector <code>x</code> should be exactly 1. Our rule of thumb to the 2.1012 condition number predicts that the solution accuracy should be around 15−12 = 3 digits. Indeed, the largest deviation is 0.00055 in component 6.</para>

<programlisting language="c++">
TMatrixDSym H = THilbertMatrixDSym(10);
TVectorD rowsum(10);
for (Int_t irow = 0; irow &lt; 10; irow++)
for (Int_t icol = 0; icol &lt; 10; icol++)
rowsum(irow) += H(irow,icol);
TDecompLU lu(H);
Bool_t ok;
TVectorD x = lu.Solve(rowsum,ok);
Double_t d1,d2;
lu.Det(d1,d2);
cout &lt;&lt; "cond:" &lt;&lt; lu.Condition() &lt;&lt; endl;
cout &lt;&lt; "det :" &lt;&lt; d1*TMath:Power(2.,d2) &lt;&lt; endl;
cout &lt;&lt; "tol :" &lt;&lt; lu.GetTol() &lt;&lt; endl;
x.Print();
cond:3.9569e+12
det :2.16439e-53
tol :2.22045e-16
Vector 10 is as follows
|          1   |
------------------
0 |1
1 |1
2 |0.999997
3 |1.00003
4 |0.999878
5 |1.00033
6 |0.999452
7 |1.00053
8 |0.999723
9 |1.00006
</programlisting>

</sect2>

<sect2>
<title>LU</title>
<para>Decompose an <code>n×n </code>matrix<inlinemediaobject><imageobject><imagedata fileref="pictures/0800017F.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>.</para>

<programlisting language="c++">
PA = LU
</programlisting>

<para><emphasis role="italic">P </emphasis>permutation matrix stored in the index array <code>fIndex</code>: <code>j=fIndex[i]</code> indicates that row j and row<code> i </code>should be swapped. Sign of the permutation, <code>-1n</code>, where <code>n</code> is the number of interchanges in the permutation, stored in <code>fSign</code>.</para>
<para><emphasis role="italic">L </emphasis>is lower triangular matrix, stored in the strict lower triangular part of <code>fLU.</code> The diagonal elements of <emphasis role="italic">L</emphasis> are unity and are not stored.</para>
<para><emphasis role="italic">U </emphasis>is upper triangular matrix, stored in the diagonal and upper triangular part of <code>fU</code>.</para>
<para>The decomposition fails if a diagonal element of <code>fLU</code> equals 0.</para>
</sect2>

<sect2>
<title>Bunch-Kaufman</title>
<para>Decompose a real symmetric matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/08000180.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject></para>

<programlisting language="c++">
A = UDUT
</programlisting>

<para><emphasis role="italic">D </emphasis>is a block diagonal matrix with 1-by-1 and 2-by-2 diagonal blocks <emphasis role="italic">D</emphasis><emphasis role="italic">k</emphasis>.</para>
<para><emphasis role="italic">U </emphasis>is product of permutation and unit upper triangular matrices: </para>
<para><emphasis role="italic">U = P</emphasis><emphasis role="italic">n-1</emphasis><emphasis role="italic">U</emphasis><emphasis role="italic">n-1</emphasis><emphasis role="italic"> · · ·P</emphasis><emphasis role="italic">k</emphasis><emphasis role="italic">U</emphasis><emphasis role="italic">k</emphasis><emphasis role="italic"> · · · </emphasis>where<emphasis role="italic"> k</emphasis> decreases from <emphasis role="italic">n</emphasis> − 1 to 0 in steps of 1 or 2. Permutation matrix <emphasis role="italic">P</emphasis><emphasis role="italic">k</emphasis> is stored in <code>fIpiv</code>. <emphasis role="italic">U</emphasis><emphasis role="italic">k</emphasis> is a unit upper triangular matrix, such that if the diagonal block <emphasis role="italic">D</emphasis><emphasis role="italic">k</emphasis> is of order <emphasis role="italic">s</emphasis> (<emphasis role="italic">s</emphasis> = 1, 2), then</para>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/08000181.png" width="81.3pt" depth="55.25pt"/></imageobject></inlinemediaobject>
</para>
<para>If <emphasis role="italic">s</emphasis> = 1, <code>Dk</code> overwrites <inlinemediaobject><imageobject><imagedata fileref="pictures/08000182.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject><emphasis role="italic"> (k, k)</emphasis>, and v overwrites <inlinemediaobject><imageobject><imagedata fileref="pictures/08000183.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject><emphasis role="italic"> (0: k − 1, k)</emphasis>.</para>
<para>If <emphasis role="italic">s</emphasis> = 2, the upper triangle of <code>Dk</code>         overwrites <inlinemediaobject><imageobject><imagedata fileref="pictures/08000184.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject><emphasis role="italic"> (k−1, k−1), </emphasis><inlinemediaobject><imageobject><imagedata fileref="pictures/08000185.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject><emphasis role="italic"> (k−1, k)</emphasis>, and <inlinemediaobject><imageobject><imagedata fileref="pictures/08000186.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject><emphasis role="italic"> (k, k)</emphasis>, and v overwrites </para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/08000187.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject><emphasis role="italic"> (0 : k − 2, k − 1 : k)</emphasis>.</para>
</sect2>

<sect2>
<title>Cholesky</title>
<para>Decompose a symmetric, positive definite matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/08000188.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>.</para>

<programlisting language="c++">
A = UTU
</programlisting>

<para><emphasis role="italic">U</emphasis> is an upper triangular matrix. The decomposition fails if a diagonal element of <code>fU≤0</code>, the matrix is not positive negative.</para>
</sect2>

<sect2>
<title>QRH</title>
<para>Decompose a (<emphasis role="italic">m</emphasis> x<emphasis role="italic"> n</emphasis>) - matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/08000189.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>with <emphasis role="italic">m ≥ n</emphasis><emphasis role="italic">.</emphasis></para>

<programlisting language="c++">
A = QRH
</programlisting>

<para><emphasis role="italic">Q</emphasis> orthogonal (<emphasis role="italic">m</emphasis> x <emphasis role="italic">n</emphasis>) - matrix, stored in <code>fQ</code>;</para>
<para><emphasis role="italic">R</emphasis> upper triangular (<emphasis role="italic">n</emphasis> x <emphasis role="italic">n</emphasis>) - matrix, stored in <code>fR</code>;</para>
<para><emphasis role="italic">H</emphasis> (<emphasis role="italic">n</emphasis> x <emphasis role="italic">n</emphasis>) - Householder matrix, stored through;</para>
<para><code>fUp</code> n - vector with Householder up’s;</para>
<para><code>fW</code> n - vector with Householder beta’s.</para>
<para>The decomposition fails if in the formation of reflectors a zero appears, i.e. singularity. </para>
</sect2>

<sect2>
<title>SVD</title>
<para>Decompose a (<emphasis role="italic">m</emphasis> x <emphasis role="italic">n</emphasis>) - matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/0800018A.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>with <emphasis role="italic">m ≥ n</emphasis>.</para>

<programlisting language="c++">
A = USVT
</programlisting>

<para><emphasis role="italic">U</emphasis>  (<emphasis role="italic">m</emphasis> x <emphasis role="italic">m</emphasis>) orthogonal matrix, stored in <code>fU</code>;</para>
<para><emphasis role="italic">S</emphasis> is diagonal matrix containing the singular values. Diagonal stored in vector <code>fSig</code> which is ordered so that <code>fSig[0] &gt;= fSig[1] &gt;= ... &gt;= fSig[n-1]</code>;</para>
<para><emphasis role="italic">V</emphasis> (<emphasis role="italic">n</emphasis> x <emphasis role="italic">n</emphasis>) orthogonal matrix, stored in <code>fV</code>.</para>
<para>The singular value decomposition always exists, so the decomposition will (as long as m ≥ n) never fail. If <emphasis role="italic">m</emphasis> &lt; <emphasis role="italic">n</emphasis>, the user should add sufficient zero rows to <inlinemediaobject><imageobject><imagedata fileref="pictures/0800018B.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject>, so that <emphasis role="italic">m</emphasis> == <emphasis role="italic">n</emphasis>. In the <code>SVD</code>, <code>fTol</code> is used to set the threshold on the minimum allowed value of the singular values: <code>min singular = fTol maxi(Sii)</code>.</para>
</sect2>
</sect1>

<sect1>
<title>Matrix Eigen Analysis</title>
<para>Classes <emphasis role="bold"><code>TMatrixDEigen</code></emphasis> and <emphasis role="bold"><code>TMatrixDSymEigen</code></emphasis> compute eigenvalues and eigenvectors for general dense and symmetric real matrices, respectively. If matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/0800018C.png" width="11.8pt" depth="13.05pt"/></imageobject></inlinemediaobject> is symmetric, then<inlinemediaobject><imageobject><imagedata fileref="pictures/0800018D.png" width="68.9pt" depth="16.15pt"/></imageobject></inlinemediaobject>, where the eigenvalue matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/0800018E.png" width="13.05pt" depth="13.05pt"/></imageobject></inlinemediaobject> is diagonal and the eigenvector matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/0800018F.png" width="11.8pt" depth="13.65pt"/></imageobject></inlinemediaobject>is orthogonal. That is, the diagonal values of <inlinemediaobject><imageobject><imagedata fileref="pictures/08000190.png" width="13.05pt" depth="13.05pt"/></imageobject></inlinemediaobject> are the eigenvalues, and<inlinemediaobject><imageobject><imagedata fileref="pictures/08000191.png" width="49.65pt" depth="16.15pt"/></imageobject></inlinemediaobject>, where <inlinemediaobject><imageobject><imagedata fileref="pictures/08000192.png" width="9.95pt" depth="13.05pt"/></imageobject></inlinemediaobject>- is the identity matrix. The columns of <inlinemediaobject><imageobject><imagedata fileref="pictures/08000193.png" width="11.8pt" depth="13.65pt"/></imageobject></inlinemediaobject>represent the eigenvectors in the sense that<inlinemediaobject><imageobject><imagedata fileref="pictures/08000194.png" width="60.85pt" depth="13.65pt"/></imageobject></inlinemediaobject>. If A is not symmetric, the eigenvalue matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/08000195.png" width="13.05pt" depth="13.05pt"/></imageobject></inlinemediaobject> is block diagonal with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues, <code>a+i*b</code>, in 2-by-2 blocks, <code>[a,b;−b,a]</code>. That is, if the complex eigenvalues look like:</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/08000196.png" width="180.6pt" depth="85.05pt"/></imageobject></inlinemediaobject>    then<inlinemediaobject><imageobject><imagedata fileref="pictures/08000197.png" width="13.05pt" depth="13.05pt"/></imageobject></inlinemediaobject> looks like  <inlinemediaobject><imageobject><imagedata fileref="pictures/08000198.png" width="127.25pt" depth="86.9pt"/></imageobject></inlinemediaobject></para>
<para>This keeps <inlinemediaobject><imageobject><imagedata fileref="pictures/08000199.png" width="11.8pt" depth="13.65pt"/></imageobject></inlinemediaobject> a real matrix in both symmetric and non-symmetric cases, and<inlinemediaobject><imageobject><imagedata fileref="pictures/0800019A.png" width="60.85pt" depth="13.65pt"/></imageobject></inlinemediaobject>. The matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/0800019B.png" width="11.8pt" depth="13.65pt"/></imageobject></inlinemediaobject>may be badly conditioned, or even singular, so the validity of the equation <inlinemediaobject><imageobject><imagedata fileref="pictures/0800019C.png" width="67.65pt" depth="16.15pt"/></imageobject></inlinemediaobject> depends upon the condition number of <inlinemediaobject><imageobject><imagedata fileref="pictures/0800019D.png" width="11.8pt" depth="13.65pt"/></imageobject></inlinemediaobject>. Next table shows the methods of the classes <emphasis role="bold"><code>TMatrixDEigen</code></emphasis> and <emphasis role="bold"><code>TMatrixDSymEigen</code></emphasis> to obtain the eigenvalues and eigenvectors. Obviously, <emphasis role="bold"><code>MatrixDSymEigen</code></emphasis> constructors can only be called with <emphasis role="bold"><code>TMatrixDSym</code></emphasis>:</para>
<informaltable frame="all">
<tgroup cols="3">
<colspec colwidth="3468*" colname="column-1"/>
<colspec colwidth="1200*" colname="column-2"/>
<colspec colwidth="4201*" colname="column-3"/>
<tbody>
<row>
<entry rowsep="1" colsep="1">
<para>Format </para>
</entry>
<entry rowsep="1" colsep="1">
<para>Output</para>
</entry>
<entry rowsep="1" colsep="1">
<para>Description</para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>eig.GetEigenVectors</code>












<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixD</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>eigenvectors for both <code>TMatrixDEigen</code> and <code>TMatrixDSymEigen</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>eig.GetEigenValues</code>












<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TVectorD</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>eigenvalues vector for <code>TMatrixDSymEigen</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>eig.GetEigenValues()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TMatrixD</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>eigenvalues matrix for <code>TMatrixDEigen</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>eig.GetEigenValuesRe</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TVectorD</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>real part of eigenvalues for <code>TMatrixDEigen</code></para>
</entry>
</row>
<row>
<entry rowsep="1" colsep="1">
<para>
<code>eig.GetEigenValuesIm</code>





<code>()</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>
<code>TVectorD</code>
</para>
</entry>
<entry rowsep="1" colsep="1">
<para>imaginary part of eigenvalues for</para>
<para>
<code>TMatrixDEigen</code>
</para>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>Below, usage of the eigenvalue class is shown in an example where it is checked that the square of the singular values of a matrix <inlinemediaobject><imageobject><imagedata fileref="pictures/0800019E.png" width="11.15pt" depth="16.75pt"/></imageobject></inlinemediaobject> are identical to the eigenvalues of<inlinemediaobject><imageobject><imagedata fileref="pictures/0800019F.png" width="16.15pt" depth="18pt"/></imageobject></inlinemediaobject>. <inlinemediaobject><imageobject><imagedata fileref="pictures/080001A0.png" width="11.15pt" depth="16.75pt"/></imageobject></inlinemediaobject>:   </para>

<programlisting language="c++">
const TMatrixD m = THilbertMatrixD(10,10);
TDecompSVD svd(m);
TVectorD sig = svd.GetSig(); sig.Sqr();
<emphasis role="italic"><code>// Symmetric matrix EigenVector algorithm</code></emphasis>
TMatrixDSym mtm(TMatrixDBase::kAtA,m);
const TMatrixDSymEigen eigen(mtm);
const TVectorD eigenVal = eigen.GetEigenValues();
const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);
</programlisting>

</sect1>

<sect1>
<title>Speed Comparisons</title>
<para>Speed of four matrix operations have been compared between four matrix libraries, <code>GSL</code> <code>CLHEP</code>, <code>ROOT v3.10</code> and <code>ROOT v4.0</code>. Next figure shows the <code>CPU</code> time for these four operations as a function of the matrix size: </para>
<para>1. <code>A*B</code> The execution time is measured for the sum of A * Bsym, Bsym* A and A * B. Notice the matrix_size3 dependence of execution time. <code>CLHEP</code> results are hampered by a poor implementation of symmetric matrix multiplications. For instance, for general matrices of size 100x100, the time is 0.015 sec. while A * Bsym takes 0.028 sec and Bsym* A takes 0.059 sec.</para>
<para>Both <code>GSL</code> and <code>ROOT v4.0</code> can be setup to use the hardware-optimized multiplication routines of the <code>BLAS</code> libraries. It was tested on a G4 PowerPC. The improvement becomes clearly visible around sizes of (50x50) were the execution speed improvement of the Altivec processor becomes more significant than the overhead of filling its pipe.</para>
<para>2. <code>A-1</code> Here, the time is measured for an in-place matrix inversion. </para>
<para>Except for <code>ROOT v3.10</code>, the algorithms are all based on an <code>LU </code>factorization followed by forward/back-substitution. <code>ROOT v3.10</code> is using the slower Gaussian elimination method. The numerical accuracy of the <code>CLHEP</code> routine is poor: </para>
<para>- up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating <code>U=H*H-1</code>, where <code>H</code> is a (5x5) Hilbert matrix, results in off-diagonal elements of 10-7 instead of the 10-13 using an <code>LU </code>according to <code>Crout</code>. </para>
<para>- scaling protection is non-existent and limits are hard-coded, as a consequence inversion of a Hilbert matrix for <code>sizes&gt;(12x12)</code> fails. In order to gain speed the <code>CLHEP</code> algorithm stores its permutation info of the pivots points in a static array, making multi-threading not possible.</para>
<para><code>GSL</code> uses LU decomposition without the implicit scaling of <code>Crout</code>. Therefore, its accuracy is not as good. For instance a (10x10) Hilbert matrix has errors 10 times larger than the <code>LU Crout</code> result. In <code>ROOT v4.0</code>, the user can choose between the         <code>Invert()</code> and <code>IvertFast()</code> routines, where the latter is using the Cramer algorithm for <code>sizes&lt;7x7</code>. The speed graph shows the result for <code>InvertFast()</code>.</para>
<para>3. <code>A*x=b</code> the execution time is measured for solving the linear equation <code>A*x=b</code>. The same factorizations are used as in the matrix inversion. However, only 1 forward/back-substitution has to be used instead of msize as in the inversion of (msize x msize) matrix. As a consequence the same differences are observed but less amplified. CLHEP shows the same numerical issues as in step the matrix inversion. Since ROOT3.10 has no dedicated equation solver, the solution is calculated through <code>x=A-1*b</code>. This will be slower and numerically not as stable.</para>
<para>4. <code>(AT*A)-1*AT</code> timing results for calculation of the pseudo inverse of matrix a. The sequence of operations measures the impact of several calls to constructors and destructors in the <code>C++</code> packages versus a <code>C</code> library like <code>GSL</code>.</para>

<figure><title>Speed comparison between the different matrix packages</title>
<para>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001A1.png" width="135.3pt" depth="192.4pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001A2.png" width="135.95pt" depth="191.15pt"/></imageobject></inlinemediaobject>
</para>
</figure>

</sect1>
</chapter>



