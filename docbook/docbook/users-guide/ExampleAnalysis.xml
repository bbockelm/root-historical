<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0">
<title>Example Analysis</title>
<para>This chapter is an example of a typical physics analysis. Large data files are chained together and analyzed using the <emphasis role="bold"><code>TSelector</code></emphasis> class. </para>

<sect1>
<title>Explanation</title>
<para>This script uses four large data sets from the H1 collaboration at DESY Hamburg. One can access these data sets (277 Mbytes) from the ROOT web site at:  <uri xmlns:xlink="ftp://root.cern.ch/root/h1analysis/">ftp://root.cern.ch/root/h1analysis/</uri></para>
<para>The physics plots generated by this example cannot be produced using smaller data sets.</para>
<para>There are several ways to analyze data stored in a ROOT Tree</para>
<itemizedlist>
<listitem><para>Using <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code>:</para></listitem>
<listitem><para>This is very convenient and efficient for small tasks. A <emphasis role="bold"><code>TTree</code></emphasis>::Draw call produces one histogram at the time. The histogram is automatically generated. The selection expression may be specified in the command line.</para></listitem>
<listitem><para>Using the <emphasis role="bold"><code>TTreeViewer</code></emphasis>: </para></listitem>
<listitem><para>This is a graphical interface to <emphasis role="bold"><code>TTree</code></emphasis><code>::Draw</code> with the same functionality.</para></listitem>
<listitem><para>Using the code generated by <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeClass</code>:</para></listitem>
<listitem><para>In this case, the user creates an instance of the analysis class. He has the control over the event loop and he can generate an unlimited number of histograms. </para></listitem>
<listitem><para>Using the code generated by <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeSelector</code>: Like for the code generated by <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeClass</code>, the user can do complex analysis. However, he cannot control the event loop. The event loop is controlled by <emphasis role="bold"><code>TTree</code></emphasis><code>::Process</code> called by the user. This solution is illustrated by the code below. The advantage of this method is that it can be run in a parallel environment using PROOF (the Parallel Root Facility).</para></listitem>
</itemizedlist>
<para>A chain of four files (originally converted from PAW ntuples) is used to illustrate the various ways to loop on ROOT data sets. Each contains a ROOT Tree named "<code>h42</code>". The class definition in h1analysis.h has been generated automatically by the ROOT utility <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeSelector</code> using one of the files with:</para>

<programlisting language="c++">
h42-&gt;MakeSelector("h1analysis");
</programlisting>

<para>This produces two files: h1analysis.h and <code>h1analysis.C</code>. A skeleton of <code>h1analysis.C</code> file is made for you to customize. The h1analysis class is derived from the ROOT class <emphasis role="bold"><code>TSelector</code></emphasis>. The following members functions of h1analyhsis (i.e. <emphasis role="bold"><code>TSelector</code></emphasis>) are called by the <emphasis role="bold"><code>TTree</code></emphasis><code>::Process</code> method.</para>
<itemizedlist>
<listitem><para><code>Begin</code>: This function is called every time a loop over the tree starts. This is a convenient place to create your histograms.</para></listitem>
<listitem><para><code>Notify():</code> This function is called at the first entry of a new tree in a chain.</para></listitem>
<listitem><para><code>ProcessCut</code>:  This function is called at the beginning of each entry to return a flag true if the entry must be analyzed.</para></listitem>
<listitem><para><code>ProcessFill</code>: This function is called in the entry loop for all entries accepted by Select.</para></listitem>
<listitem><para><code>Terminate</code>: This function is called at the end of a loop on a <emphasis role="bold"><code>TTree</code></emphasis>. This is a convenient place to draw and fit your histograms.</para></listitem>
</itemizedlist>
<para>To use this program, try the following session.</para>
<para>First, turn the timer on to show the real and CPU time per command.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>gROOT</code></emphasis><emphasis role="bold"><code>-&gt;Time();</code></emphasis>
</programlisting>

<para><emphasis role="underline">Step A:</emphasis>  create a <emphasis role="bold"><code>TChain</code></emphasis> with the four H1 data files. The chain can be created by executed this short script <code>h1chain.C</code> below.  $H1 is a system symbol pointing to the H1 data directory.</para>

<programlisting language="c++">
{
TChain chain("h42");
chain.Add("$H1/dstarmb.root");
<code>//21330730 bytes, 21920 events</code>
chain.Add("$H1/dstarp1a.root");
<code>//71464503 bytes, 73243 events</code>
chain.Add("$H1/dstarp1b.root");
<code>//83827959 bytes, 85597 events</code>
chain.Add("$H1/dstarp2.root");
<code>//100675234 bytes, 103053 events</code>
}
</programlisting>

<para>Run the above script from the command line:</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>.x h1chain.C</code></emphasis>
</programlisting>

<para><emphasis role="underline">Step B</emphasis>: Now we have a directory containing the four data files. Since a <emphasis role="bold"><code>TChain</code></emphasis> is a descendent of <emphasis role="bold"><code>TTree</code></emphasis> we can call <emphasis role="bold"><code>TChain</code></emphasis><code>::Process</code> to loop on all events in the chain. The parameter to the <emphasis role="bold"><code>TChain</code></emphasis><code>::Process</code> method is the name of the file containing the created <emphasis role="bold"><code>TSelector</code></emphasis> class (<code>h1analysis.C</code>).</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>chain.Process("h1analysis.C")</code></emphasis>
</programlisting>

<para><emphasis role="underline">Step C</emphasis>: Same as step B, but in addition fill the event list with selected entries. The event list is saved to a file "<code>elist.root</code>" by the <emphasis role="bold"><code>TSelector</code></emphasis><code>::Terminate</code> method. To see the list of selected events, you can do <code>elist-&gt;Print("all")</code>. The selection function has selected 7525 events out of the 283813 events in the chain of files. (2.65 per cent)</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>chain.Process("h1analysis.C","fillList")</code></emphasis>
</programlisting>

<para><emphasis role="underline">Step D:</emphasis> Process only entries in the event list. The event list is read from the file in <code>elist.root</code> generated by step C.</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>chain.Process("h1analysis.C","useList")</code></emphasis>
</programlisting>

<para><emphasis role="underline">Step E</emphasis>: The above steps have been executed with the interpreter. You can repeat the steps B, C, and D using ACLiC by replacing "<code>h1analysis.C</code>" by "<code>h1analysis.C+</code>" or "<code>h1analysis.C++</code>".</para>
<para><emphasis role="underline">Step F:</emphasis> If you want to see the differences between the interpreter speed and ACLiC speed start a new session, create the chain as in step 1, then execute</para>

<programlisting language="c++">
root[] <emphasis role="bold"><code>chain</code></emphasis><emphasis role="bold"><code>.Process("h1analysis.C+","useList")</code></emphasis>
</programlisting>

<para>The commands executed with the four different methods B, C, D and E produce two canvases shown below:</para>
<para><inlinemediaobject><imageobject><imagedata fileref="pictures/030001FD.png" width="295.45pt" depth="213.5pt"/></imageobject></inlinemediaobject>
<inlinemediaobject><imageobject><imagedata fileref="pictures/030001FE.png" width="296.05pt" depth="213.5pt"/></imageobject></inlinemediaobject></para>
<para/>
</sect1>

<sect1>
<title>Script</title>
<para>This is the <code>h1analsysis.C</code> file that was generated by <emphasis role="bold"><code>TTree</code></emphasis><code>::MakeSelector</code> and then modified to perform the analysis.</para>

<programlisting language="c++">
#include "h1analysis.h"
#include "TH2.h"
#include "TF1.h"
#include "TStyle.h"
#include "TCanvas.h"
#include "TLine.h"
#include "TEventList.h"

const Double_t dxbin = (0.17-0.13)/40;   // Bin-width
const Double_t sigma = 0.0012;
TEventList *elist = 0;
Bool_t useList, fillList;
TH1F *hdmd;
TH2F *h2;

<code>//_________________________________________________________</code>
Double_t fdm5(Double_t *xx, Double_t *par)
{
Double_t x = xx[0];
if (x &lt;= 0.13957) return 0;
Double_t xp3 = (x-par[3])*(x-par[3]);
Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957,par[1])
+ par[2]/2.5066/par[4]*TMath::Exp(-xp3/2/par[4]/par[4]));
return res;
}

<code>//_________________________________________________________</code>
Double_t fdm2(Double_t *xx, Double_t *par)
{
Double_t x = xx[0];
if (x &lt;= 0.13957) return 0;
Double_t xp3 = (x-0.1454)*(x-0.1454);
Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957,0.25)
+ par[1]/2.5066/sigma*TMath::Exp(-xp3/2/sigma/sigma));
return res;
}

<code>//_________________________________________________________</code>
void h1analysis::Begin(TTree *tree)
{
<code>// function called before starting the event loop</code>
<code>//  -it performs some cleanup</code>
<code>//  -it creates histograms</code>
<code>//  -it sets some initialization for the event list</code>

<code>  //initialize the Tree branch addresses</code>
Init(tree);

<code>  //print the option specified in the Process function</code>
TString option = GetOption();
printf("Starting h1analysis with process option: %sn",option.Data());

<code>//Some cleanup in case this function had already been executed</code>
<code>  //Delete any previously generated histograms or functions</code>
gDirectory-&gt;Delete("hdmd");
gDirectory-&gt;Delete("h2*");
delete gROOT-&gt;GetFunction("f5");
delete gROOT-&gt;GetFunction("f2");

<code>//create histograms</code>
hdmd = new TH1F("hdmd","dm_d",40,0.13,0.17);
h2   = new TH2F("h2","ptD0 vs dm_d",30,0.135,0.165,30,-3,6);

<code>  //process cases with event list</code>
fillList = kFALSE;
useList  = kFALSE;
fChain-&gt;SetEventList(0);
delete gDirectory-&gt;GetList()-&gt;FindObject("elist");

<code>  // case when one creates/fills the event list</code>
if (option.Contains("fillList")) {
fillList = kTRUE;
elist = new TEventList("elist","selection from Cut",5000);
}
<code>  // case when one uses the event list generated in a previous call</code>
if (option.Contains("useList")) {
useList  = kTRUE;
TFile f("elist.root");
elist = (TEventList*)f.Get("elist");
if (elist) elist-&gt;SetDirectory(0);
<code>//otherwise the file destructor will delete elist</code>
fChain-&gt;SetEventList(elist);
}
}
<code>//_________________________________________________________</code>
Bool_t h1analysis::ProcessCut(Int_t entry)
{ <code>// Selection function to select D* and D0.</code>

<code>  //in case one event list is given in input, </code>
<code>  //the selection has already been done.</code>
if (useList) return kTRUE;
<code>  // Read only the necessary branches to select entries.</code>
<code>  // return as soon as a bad entry is detected</code>
b_md0_d-&gt;GetEntry(entry);
if (TMath::Abs(md0_d-1.8646) &gt;= 0.04) return kFALSE;
b_ptds_d-&gt;GetEntry(entry);
if (ptds_d &lt;= 2.5) return kFALSE;
b_etads_d-&gt;GetEntry(entry);
if (TMath::Abs(etads_d) &gt;= 1.5) return kFALSE;
b_ik-&gt;GetEntry(entry);  ik--;
<code>//original ik used f77 convention starting at 1</code>
b_ipi-&gt;GetEntry(entry);
ipi--;
b_ntracks-&gt;GetEntry(entry);
b_nhitrp-&gt;GetEntry(entry);
if (nhitrp[ik]*nhitrp[ipi] &lt;= 1) return kFALSE;
b_rend-&gt;GetEntry(entry);
b_rstart-&gt;GetEntry(entry);
if (rend[ik]-rstart[ik] &lt;= 22)   return kFALSE;
if (rend[ipi]-rstart[ipi] &lt;= 22) return kFALSE;
b_nlhk-&gt;GetEntry(entry);
if (nlhk[ik] &lt;= 0.1)    return kFALSE;
b_nlhpi-&gt;GetEntry(entry);
if (nlhpi[ipi] &lt;= 0.1)  return kFALSE;
b_ipis-&gt;GetEntry(entry);
ipis--;
if (nlhpi[ipis] &lt;= 0.1) return kFALSE;
b_njets-&gt;GetEntry(entry);
if (njets &lt; 1)          return kFALSE;

<code>   // if option fillList, fill the event list</code>
if (fillList) elist-&gt;Enter(fChain-&gt;GetChainEntryNumber(entry));

return kTRUE;
}

<code>//_________________________________________________________</code>
void h1analysis::ProcessFill(Int_t entry)
{ <code>// Function called for selected entries only</code>

<code>  // read branches not processed in ProcessCut</code>
b_dm_d-&gt;GetEntry(entry);
<code>        //read branch holding dm_d</code>
b_rpd0_t-&gt;GetEntry(entry);
<code>       //read branch holding rpd0_t</code>
b_ptd0_d-&gt;GetEntry(entry);
<code>       //read branch holding ptd0_d                              //continued…</code>
<code>  //fill some histograms</code>
hdmd-&gt;Fill(dm_d);
h2-&gt;Fill(dm_d,rpd0_t/0.029979*1.8646/ptd0_d);
}

<code>//_________________________________________________________</code>
void h1analysis::Terminate()
{  <code>// Function called at the end of the event loop</code>

<code>  //create the canvas for the h1analysis fit</code>
gStyle-&gt;SetOptFit();
TCanvas *c1 = new TCanvas("c1","h1analysis analysis",10,10,800,600);
c1-&gt;SetBottomMargin(0.15);
hdmd-&gt;GetXaxis()-&gt;SetTitle("m_{K#pi#pi}-m_{K#pi}[GeV/c^{2}]");
hdmd-&gt;GetXaxis()-&gt;SetTitleOffset(1.4);

<code>  //fit histogram hdmd with function f5 using</code>
<code>  //the loglikelihood option</code>
TF1 *f5 = new TF1("f5",fdm5,0.139,0.17,5);
f5-&gt;SetParameters(1000000,.25,2000,.1454,.001);
hdmd-&gt;Fit("f5","lr");

<code>  //create the canvas for tau d0</code>
gStyle-&gt;SetOptFit(0);
gStyle-&gt;SetOptStat(1100);
TCanvas *c2 = new TCanvas("c2","tauD0",100,100,800,600);
c2-&gt;SetGrid();
c2-&gt;SetBottomMargin(0.15);

<code>   // Project slices of 2-d histogram h2 along X ,</code>
<code>   // then fit each slice with function f2 and make a </code>
<code>   // histogram for each fit parameter.</code>
<code>   // Note that the generated histograms are added </code>
<code>   // to the list of objects in the current directory.</code>

TF1 *f2 = new TF1("f2",fdm2,0.139,0.17,2);
f2-&gt;SetParameters(10000,10);
h2-&gt;FitSlicesX(f2,0,0,1,"qln");
TH1D *h2_1 = (TH1D*)gDirectory-&gt;Get("h2_1");
h2_1-&gt;GetXaxis()-&gt;SetTitle("#tau[ps]");
h2_1-&gt;SetMarkerStyle(21);
h2_1-&gt;Draw();
c2-&gt;Update();
TLine *line = new TLine(0,0,0,c2-&gt;GetUymax());
line-&gt;Draw();

<code>   // save the event list to a Root file if one was</code>
<code>   // produced</code>
if (fillList) {
TFile efile("elist.root","recreate");
elist-&gt;Write();
}
}
</programlisting>

</sect1>
</chapter>



